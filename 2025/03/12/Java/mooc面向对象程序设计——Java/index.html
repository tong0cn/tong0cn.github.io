<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>mooc面向对象程序设计——Java | Blog</title><meta name="author" content="tong"><meta name="copyright" content="tong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="mooc面向对象程序设计——Java 2023年11月13日 ~ 2024年01月31日	第14次开课	翁恺 第1周	类与对象1.1 用类制造对象（类和对象的关系与封装）  [!NOTE] 之前我们学习了如何使用系统提供的类，比如String，来创建对象和使用对象。 尤其重要的是我们理解了对象变量和普通变量的不同，对象变量是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较都与普通变量有所">
<meta property="og:type" content="article">
<meta property="og:title" content="mooc面向对象程序设计——Java">
<meta property="og:url" content="http://example.com/2025/03/12/Java/mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="mooc面向对象程序设计——Java 2023年11月13日 ~ 2024年01月31日	第14次开课	翁恺 第1周	类与对象1.1 用类制造对象（类和对象的关系与封装）  [!NOTE] 之前我们学习了如何使用系统提供的类，比如String，来创建对象和使用对象。 尤其重要的是我们理解了对象变量和普通变量的不同，对象变量是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较都与普通变量有所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/touxiang.png">
<meta property="article:published_time" content="2025-03-12T10:22:00.000Z">
<meta property="article:modified_time" content="2025-06-28T10:00:17.785Z">
<meta property="article:author" content="tong">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/touxiang.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "mooc面向对象程序设计——Java",
  "url": "http://example.com/2025/03/12/Java/mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java/",
  "image": "http://example.com/img/touxiang.png",
  "datePublished": "2025-03-12T10:22:00.000Z",
  "dateModified": "2025-06-28T10:00:17.785Z",
  "author": [
    {
      "@type": "Person",
      "name": "tong",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/./img/favicon1.ico"><link rel="canonical" href="http://example.com/2025/03/12/Java/mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mooc面向对象程序设计——Java',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://i.loli.net/2019/09/09/5oDRkWVKctx2b6A.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/./img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">mooc面向对象程序设计——Java</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">mooc面向对象程序设计——Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-12T10:22:00.000Z" title="发表于 2025-03-12 18:22:00">2025-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-28T10:00:17.785Z" title="更新于 2025-06-28 18:00:17">2025-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="mooc面向对象程序设计——Java"><a href="#mooc面向对象程序设计——Java" class="headerlink" title="mooc面向对象程序设计——Java"></a>mooc面向对象程序设计——Java</h1><p> 2023年11月13日 ~ 2024年01月31日	第14次开课	翁恺</p>
<h2 id="第1周类与对象"><a href="#第1周类与对象" class="headerlink" title="第1周	类与对象"></a>第1周	类与对象</h2><h3 id="1-1-用类制造对象"><a href="#1-1-用类制造对象" class="headerlink" title="1.1 用类制造对象"></a>1.1 用类制造对象</h3><p>（<code>类和对象的关系</code>与<code>封装</code>）</p>
<blockquote>
<p>[!NOTE]</p>
<p>之前我们学习了如何使用系统提供的类，比如String，来创建对象和使用对象。</p>
<p>尤其重要的是我们理解了对象变量和普通变量的不同，对象变量是对象的管理者而非所有者，所以涉及到赋值、函数参数传递和比较都与普通变量有所不同。</p>
<p>现在，我们要来尝试自己定义类，然后用自己定义的类来创建对象。</p>
<p>我们从一个已有的程序开始，看看如何用这个程序中定义好了的类来创建多个对象。这个程序是一个图形用户界面的程序，会显示一个图形窗口，在其中画图。图上的每一个形状，都是一个对象。</p>
<p>我们希望通过对这个程序的尝试，让你充分理解类和对象的关系：类定义了对象长什么样，对象则是按照类的定义所制造出来的实体，一个类可以创建很多对象，每个对象有自己的数据。</p>
<p>注意右下角的下载按钮！</p>
</blockquote>
<p>🍎我们这门课一方面可以看作是Java的进阶课程，但是另外一方面，我们也可以把它看作是面向对象程序设计在Java当中的具体体现。或者说我们用Java语言来学习面向对象程序设计。</p>
<p>查看eclipse的工作目录：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103192020476.png" alt="image-20250103192020476"></p>
<p>🍎就目前的行业情况来说，Java已经不再是做GUI [ˌdʒi ju ˈaɪ] 的主要手段了，因为桌面软件本来就已经不是最主要的软件的形态了。</p>
<p>我们主要是希望通过这个程序，能够帮助大家建立类和对象之间关系的那种概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shapes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPic</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//之前提到，对象是怎么使用的时候：要用new运算符创建一个对象出来。创建picture的时候，告诉他说我们要一个420x250的窗口。</span></span><br><span class="line">		<span class="type">Picture</span> <span class="variable">pic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="number">420</span>,<span class="number">250</span>);	<span class="comment">//我们的整个窗口：Pictrue</span></span><br><span class="line">		<span class="comment">//窗口中做了四个对象</span></span><br><span class="line">		<span class="type">Circle</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">320</span>,<span class="number">40</span>,<span class="number">40</span>);	<span class="comment">//用Circle这个类创建了一个Circle的对象：c1。Circle(横轴上的位置,y轴上的位置,直径)</span></span><br><span class="line">		<span class="type">Rectangle</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);  <span class="comment">//用Rectangle这个类创建了一个Rectangle的对象：r1。</span></span><br><span class="line">		<span class="type">Triangle</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">50</span>);  </span><br><span class="line">		<span class="type">Line</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Line</span>(<span class="number">0</span>,<span class="number">205</span>,<span class="number">400</span>,<span class="number">205</span>);</span><br><span class="line"><span class="comment">//		Circle c2 = new Circle(200,200,50);</span></span><br><span class="line">		<span class="comment">//把这些对象都加到pic里头去</span></span><br><span class="line">		pic.add(c1);</span><br><span class="line">		pic.add(r1);</span><br><span class="line">		pic.add(t1);</span><br><span class="line">		pic.add(l1);</span><br><span class="line"><span class="comment">//		pic.add(c2);</span></span><br><span class="line">		<span class="comment">//要求pic去draw</span></span><br><span class="line">		pic.draw();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103193834759.png" alt="image-20250103193834759"></p>
<p>这张图上每一个图形都是一个对象，每一个对象都是由它所属的那个类画出来的：以circle类为例，设计了一个circle类出来，然后用它制造了两个circle对象。circle类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shapes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;	<span class="comment">//有一个叫做Circle的类</span></span><br><span class="line">	<span class="comment">//Circle类里有三个数据：x，y，radius</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> radius;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 一个把它画出来的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> radius)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.x = x;</span><br><span class="line">		<span class="built_in">this</span>.y = y;</span><br><span class="line">		<span class="built_in">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">		g.drawOval(x-radius, y-radius, radius*<span class="number">2</span>, radius*<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎对象与类：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103194309611.png" alt="image-20250103194309611"></p>
<p>对象与类的关系：</p>
<p>在程序里写Circle的时候，我们定义了一些东西：eg所有的circle都应该有x有y有radio，circle会draw——这是所有的circle所应该具有的一些属性和行为的定义。在此基础上，我们是用这个circle的定义去制造了许多个circle类的对象出来。、</p>
<p>每一个对象都有它自己不同的属性，然后它们能做相同的动作——它们都能被画出来。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103194822045.png" alt="image-20250103194822045"></p>
<p>类：所有可以用来概括性的表达每一只具体的猫的那个概念。</p>
<p>类定义了对象，对于每一个对象来说都是那个类的一个实体。</p>
<p>🍎对于每一个对象来说，它都具有两种东西：一种是它的属性，一种是它的服务。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103195007105.png" alt="image-20250103195007105"></p>
<p>操作：怎么利用这些数据是它自己的事情，别人不需要知道它内部的数据是什么。eg：circle的draw：用x，y，radius把自己给画出来。</p>
<p>我关心的是我这里有一个圆，那里有一个圆，你们俩把自己给画出来。而对于这个画面来说，具体是怎么样画出来的我并不关心。</p>
<p>就像这个蛋图一样，里面是蛋黄外面是蛋白，蛋黄总是被蛋白紧紧的包围在里面，没有任何蛋黄是直接漏在外面。🍎对象也应该是这个样子，它内部的数据是被外部的操作所紧密包围的，人们只能通过外面的操作去要求这个对象为大家做点事情提供一点服务，蛋内部的数据是由这个对象本身自己所紧密保护着的。——&gt;封装。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103195737102.png" alt="image-20250103195737102"></p>
<p>封装：把数据和对这些数据的所有操作放在一个地方，然后由这些操作保护内部的数据，数据是不对外公开的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103195914930.png" alt="image-20250103195914930"></p>
<h3 id="1-2-定义类-Class"><a href="#1-2-定义类-Class" class="headerlink" title="1.2 定义类 Class"></a>1.2 定义类 Class</h3><blockquote>
<p>[!NOTE]</p>
<p>这个课时我们来学习如何自己定义类。一个类由两种东西组成：表示对象有什么的成员变量和表示对象能做什么的成员函数。</p>
<p>一旦定义了类，我们就可以创建这个类的多个对象，这些对象都会做那个类所定义的动作（函数），但是各自具有不同的数据。</p>
<p>就定义类的语法而言没什么的，大家自己看看书，或者就是看看视频中的例子就明白了。</p>
</blockquote>
<p>🍎面向对象的思维方式：</p>
<p>如果要写一个程序去仿真自动售货机的行为，需要怎么做？</p>
<p>从面向对象的角度，我们看到的是什么？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103200219621.png" alt="image-20250103200219621"></p>
<p>这些数据是这部自动售货机和那部不同的，也是这部自动售货机在工作时所需要的。而它能做一些动作：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103200335186.png" alt="image-20250103200335186"></p>
<p>它有些什么样的东西（由哪些东西来组成这个场景当中所有的东西），这个场景中的每一个东西能够做些什么样的动作&#x2F;能够为我们提供什么样的服务。——面向对象的眼光&#x2F;方式</p>
<p>🍎类的设计和对象的创建：</p>
<p>以此可以试图画出它的一张图：</p>
<table>
<thead>
<tr>
<th align="center">自动售货机VedingMachine</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表达这一部自动售货机有一些什么样属性的变量：price、balance、total</td>
</tr>
<tr>
<td align="center">这部自动售货机可以做的事情：shoePrompt、insertMoney、getFood</td>
</tr>
</tbody></table>
<p>——可以设计这样的一个类（自动售货机VedingMachine）：这个类具有这些属性（price、balance、tota）和这些动作（shoePrompt、insertMoney、getFood）。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> VedingMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VedingMachine</span> &#123;</span><br><span class="line">	<span class="comment">//VedingMachine的三个属性/变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">	<span class="type">int</span> balance;</span><br><span class="line">	<span class="type">int</span> total;</span><br><span class="line">	<span class="comment">//VedingMachine的四个动作</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">showPrompt</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">insertMoney</span><span class="params">(<span class="type">int</span> amount)</span></span><br><span class="line">	&#123;</span><br><span class="line">		balance = balance + amount;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">showBalance</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(balance);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">getFood</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( balance &gt;= price) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Here you are.&quot;</span>);</span><br><span class="line">			balance = balance - price;</span><br><span class="line">			total = total + price;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">VedingMachine</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>();<span class="comment">//用之前学的怎么制造变量的方式去制造了我们自己写的VedingMachine的对象</span></span><br><span class="line">		<span class="comment">//接下来我们可以做一些动作：</span></span><br><span class="line">		vm.showPrompt();</span><br><span class="line">		vm.showBalance();</span><br><span class="line">		vm.insertMoney(<span class="number">100</span>);</span><br><span class="line">		vm.getFood();</span><br><span class="line">		vm.showBalance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>——我们设计了一个类，叫做VedingMachine，然后我们用这个类去制造了一个对象vm，然后让这个vm为我们做了一些事情。这就是在这里所发生的事情。</p>
<p>🍎对象的管理者和所有者：</p>
<p>创建对象：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103202204595.png" alt="image-20250103202204595"></p>
<p>我们原来在程序里面说，在定义变量的时候，变量的名字前面应该是一个类型的名字，eg int、double，现在当我们自己设计了一个类之后，我们自己的这个类的名字就可以用来做类型的名字了，就可以用来定义变量了。这就是我们的新的类型系统。</p>
<p>与前面一致的，对象变量是对象的管理者而非所有者。</p>
<p>让对象做事：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103202519448.png" alt="image-20250103202519448"></p>
<p>【 . 】（period）运算符：变量的名字+【 . 】+我们让这个对象能够做的动作&#x2F;提供的服务。</p>
<p>🍎对象的唯一性和属性的独立性：</p>
<p>证明vm1和vm是VedingMachine类的两个不同的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> VedingMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VedingMachine</span> &#123;</span><br><span class="line">	<span class="comment">//VedingMachine的三个属性/变量</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">	<span class="type">int</span> balance;</span><br><span class="line">	<span class="type">int</span> total;</span><br><span class="line">	<span class="comment">//VedingMachine的四个动作</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">showPrompt</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">insertMoney</span><span class="params">(<span class="type">int</span> amount)</span></span><br><span class="line">	&#123;</span><br><span class="line">		balance = balance + amount;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">showBalance</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(balance);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">getFood</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( balance &gt;= price) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Here you are.&quot;</span>);</span><br><span class="line">			balance = balance - price;</span><br><span class="line">			total = total + price;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">VedingMachine</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>();<span class="comment">//用之前学的怎么制造变量的方式去制造了我们自己写的VedingMachine的对象</span></span><br><span class="line">		<span class="comment">//接下来我们可以做一些动作：</span></span><br><span class="line">		vm.showPrompt();</span><br><span class="line">		vm.showBalance();</span><br><span class="line">		vm.insertMoney(<span class="number">100</span>);</span><br><span class="line">		vm.getFood();</span><br><span class="line">		vm.showBalance();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">		<span class="type">VedingMachine</span> <span class="variable">vm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>();</span><br><span class="line">		vm1.insertMoney(<span class="number">200</span>);</span><br><span class="line">		vm.showBalance();</span><br><span class="line">		vm1.showBalance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后输出20和200——证明它们所管理的是两个不同的对象，因为它们内部有不同的值。</p>
<p>当然还可以用debug的手段来证明这件事情。</p>
<p>注：debug中的id是指在内部去表达每一个对象的编号，id不同就表明它们表达的是不同的对象。</p>
<p>🍎类和对象的关系：</p>
<p>我们在代码里头说每一个VedingMachine的对象有一个叫做balance的对象，balance的变量是属于VedingMachine的每一个对象的。</p>
<p>——类是定义了这个类的所有对象长什么样，而对象是这个类的一个个的具体的实例。</p>
<p>在类里面所定义的变量在每一个对象当中存在，并且在每一个对象当中都是不一样的。</p>
<h3 id="1-3-成员变量和成员函数"><a href="#1-3-成员变量和成员函数" class="headerlink" title="1.3 成员变量和成员函数"></a>1.3 成员变量和成员函数</h3><blockquote>
<p>[!NOTE]</p>
<p>这里的关键是理解类的定义和对象的关系，理解对象中的成员变量是怎么来的，怎么就能让成员函数明白自己在和哪个对象打交道。</p>
<p>这件事情，很多初学者是不明白的，而且是根本不去想这里有这么个事儿的。但是一旦想进去了而又没想明白，会很可怕的。</p>
<p>在没有引入类之前，变量是跟着代码走的。代码写到哪儿，变量写在哪里，那么运行的时候变量就在那儿。现在，写在类里的成员变量，只是一个声明，变量并不在那里，变量不在类里，变量在每一个对象里。</p>
<p>建议你一定要跟着视频中的方法自己用调试的方法看几遍成员函数的执行，做各种尝试，一定要正确而且充分地理解这里的关系。</p>
</blockquote>
<p>🍎成员变量和成员函数</p>
<p>我们已经知道，我们在些类的时候可以定义一些变量，这些变量表达了属于这个类的每一个对象所应该具有的一些属性。所以在将来new出来的时候，每一个对象都具有这些变量，和具有和其他对象所不同的值。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103204749993.png" alt="image-20250103204749993"></p>
<p>在上例中，showBalance的时候，是怎么知道是要show vm的还是vm1的？</p>
<p>在上例可以看到，因为不能直接做 showBalace(); 的动作。<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103205050315.png" alt="image-20250103205050315"></p>
<p>——在这样做的时候它不知道它的Balance，应该和vm还是vm1的Balance去联系在一起。</p>
<p>实际上在通过 vm.showBalance() 去调用showBalance函数的时候，它建立了一个联系：它知道它show的Balance是vm的showBalance。</p>
<p>🍎this关键字的作用</p>
<p>也就是说有一种机制可以在一个类的成员函数和当时调用这个函数的那个对象之间去建立联系：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103205936563.png" alt="image-20250103205936563"></p>
<p>this——一个VedingMachine对象的变量&#x2F;VedingMachine对象的管理者。更重要的是id是20号。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103210351291.png" alt="image-20250103210351291"></p>
<p>这一次调用建立了一个临时的这个函数和这个对象之间的联系，而这个联系其实是通过this这个我们看不见的东西所进行的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103210632599.png" alt="image-20250103210632599"></p>
<p>——我们把this成为成员函数的一个固有的本地变量，它表示这一次调用这个函数的那个变量。在这个函数的内部我们也可以之间使用this的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">showBalance</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">//System.out.println(balance);</span></span><br><span class="line">		System.out.println(<span class="built_in">this</span>.balance);<span class="comment">//show this的balance和balance是一模一样的，在任何一个成员函数里，你总是可以用this来表达这一次调用这个函数的那个对象。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>🍎成员函数内部调用成员函数</p>
<p>有时候会有些特殊的用处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VedingMachine</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">80</span>;  <span class="comment">//有一个之间的price</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">int</span> price)</span></span><br><span class="line">	&#123;</span><br><span class="line">    	price = price; <span class="comment">//这是没有任何意义的</span></span><br><span class="line">        <span class="comment">//函数setPrice里有一个自己的price。同时因为setPrice是VedingMachine的一个成员，它也能同时访问到VedingMachine的price（第二行的）。这两个price一定是两个不同的price，但它们所处的位置不一样。</span></span><br><span class="line">        <span class="comment">//对于setPrice来说，int price这个参数是离它最近的price。所以在setPrice的大括号里任何地方使用price，指的就是参数price。它不会再帮你指到成员变量price（第二行的）。怎么访问成员变量price呢：</span></span><br><span class="line">        <span class="built_in">this</span>.price = price; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//还有一个会偷懒用到this的地方：打一个【this.】，它会把这个类里的所有东西都列给我们看。如果我们像少打点字，虽然有点时候没有必要把【this.】加上去，但我们可以看到代码里会看到这样的东西。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103211951628.png" alt="image-20250103211951628"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103212154442.png" alt="image-20250103212154442"></p>
<p>如果在一个成员函数内部要调用另外一个成员函数的时候，就不需要用 . 了，这个时候我们不需要具体指出我们要通过哪个变量去调用那个函数，因为我们其实就在一个成员函数的内部。对于上例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">insertMoney</span><span class="params">(<span class="type">int</span> amount)</span></span><br><span class="line">	&#123;</span><br><span class="line">		balance = balance + amount;</span><br><span class="line">    	<span class="comment">//如果我们希望在insertMoney里show以下balance：</span></span><br><span class="line">    	ShowBalance(); <span class="comment">//这样即可。当然this.ShowBalance(); 也正确，但不需要。</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>而在成员函数的外部，则必须要通过对象的名字去调那个成员函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.showBalance();</span><br></pre></td></tr></table></figure>

<p>🍎成员变量的生存期和作用域</p>
<p>对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">insertMoney</span><span class="params">(<span class="type">int</span> amount)</span></span><br><span class="line">	&#123;</span><br><span class="line">		balance = balance + amount;</span><br><span class="line">    	ShowBalance(); </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>的ShowBalance()，insertMoney的this是会被传进去的。</p>
<p>——在一个成员函数的内部调另一个成员函数时，它的this（这里this的值是VedingMachine和它的id）是会被传进去的</p>
<p>🍎本地变量和成员变量的区别</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103213401724.png" alt="image-20250103213401724"></p>
<p>之前我们讲的定义在函数内部的变量，那个叫做本地变量，现在我们接触的是定义在函数外面的变量——叫做成员变量。</p>
<p>它们有很多一样的地方：都是变量，都能保存一些数据，表达一些值</p>
<p>但它们有很多重要的不一样的地方：本地变量的作用域和生存期是统一的，都是函数内部。</p>
<p>成员变量的生存期是new出一个对象来以后，这些成员变量才开始存在；对于Java来说，程序员不需要关心什么时候消失，Java有“自动垃圾回收机制”，当它发现没有人在关心这个变量&#x2F;对象了，他会主动自动的帮你把这个变量清除掉。（本地变量离开函数就不存在了）</p>
<p>成员变量的作用域是在这个类的内部。——这个类里的成员函数可以用到这个成员变量，成员变量初始化的时候也可以用到成员变量</p>
<h3 id="1-4-对象初始化"><a href="#1-4-对象初始化" class="headerlink" title="1.4 对象初始化"></a>1.4 对象初始化</h3><blockquote>
<p>[!NOTE]</p>
<p>变量的初始化是程序安全很重要的一环。一旦创建了一个对象，有什么手段可以保证其中的每一个成员变量都有确定的初始值呢？</p>
<p>Java提供了多种手段来保障对象创建时的初始化，包括给每个成员变量默认的“0”值、定义初始化和构造函数。</p>
<p>本课时还涉及了函数重载和用this()来调用其他构造函数的方式。</p>
</blockquote>
<p>🍎对象初始化的重要性</p>
<p>每次我们去new去创建一个新的对象出来的时候，有一个很重要的事情是我们知道类会定义说这个对象有一些什么样的数据成员（成员变量）。那么这些成员变量在这个对象刚被创建出来的时候有一些怎么样的初始值呢？</p>
<p>对于一个程序的安全来说，初始值非常重要。</p>
<p>对于本地变量：在Java中没有初始值这个变量是无法被使用的，编译是不会通过的。</p>
<p>而对于成员变量来说：我们先给它一个初始值0，如果没有赋给它任何值，那它就是0。eg：在VedingMachine中，price有一个初始值80，但balance和total没有值。如果它是本地变量，没有给值接下来想直接去用这些变量肯定都会有问题的。但对于成员变量，这没问题，没问题是因为每一次我们在后面去new这个VedingMachine对象出来的时候，java会自动给它一个零值。</p>
<p>Java会做这样的事情：给成员变量默认的零值。但零值代表什么取决于你的类型是什么：boolean-&gt;false、对象变量-&gt;null</p>
<p>🍎成员变量的初始值和构造函数</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104071108662.png" alt="image-20250104071108662"></p>
<p>成员变量在定义的时候甚至可以让它去调用一个函数，如果这个函数的执行不牵涉到其他东西的话。eg：int balance &#x3D; f();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VedingMachine</span> &#123;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">        </span><br><span class="line">    VedingMachine()  <span class="comment">//构造函数————在构造的时候会被自动调用的那个函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 	<span class="type">VedingMachine</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行顺序：new一个VedingMachine后（第10行），就自动的主动的去调用了构造函数（第4行）。进入构造行数以后做的第一件事情是先去外面的定义初始化（第2行），在做完了所有的定义的东西之后，回到了构造函数（第6行）。构造函数中的事情昨晚，才回到第10行把构造出来的对象交给vm去管理。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104072219743.png" alt="image-20250104072219743"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104072254482.png" alt="image-20250104072254482"></p>
<p>🍎构造函数的重载和使用this关键字</p>
<p>上例中的构造函数是没有参数的，还有另一种方式去构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VedingMachine</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="comment">//第一个构造函数    </span></span><br><span class="line">    VedingMachine()  <span class="comment">//构造函数————在构造的时候会被自动调用的那个函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个构造函数（这个类里有两个构造函数，名字是一样的。但他们的参数表是不一样的：一个是没有任何参数的，一个是有一个int作为参数。）</span></span><br><span class="line">    VedingMachine(<span class="type">int</span> price)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 	<span class="type">VedingMachine</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>();   </span><br><span class="line">    <span class="type">VedingMachine</span> <span class="variable">vm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>(<span class="number">100</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>——vm进了没有参数的构造，vm1进入了第2个构造函数。 调用函数VedingMachine的时候会根据所给参数的值的方式（有多少个，是什么类型）来决定应该调用函数中的哪一个——重载</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104072944610.png" alt="image-20250104072944610"></p>
<p>🍎构造函数中使用this的限制</p>
<p>对于构造函数来说，可以用this的特殊用法来调用另一个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VedingMachine</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="comment">//第一个构造函数    </span></span><br><span class="line">    VedingMachine()  </span><br><span class="line">    &#123;</span><br><span class="line">        total = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二个构造函数</span></span><br><span class="line">    VedingMachine(<span class="type">int</span> price)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>(); <span class="comment">//这样就可以去调用那个没有参数的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> 	<span class="type">VedingMachine</span> <span class="variable">vm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>();   </span><br><span class="line">    <span class="type">VedingMachine</span> <span class="variable">vm1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VedingMachine</span>(<span class="number">100</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以去调用那个没有参数的构造函数。但这样的this只能在构造函数里出现，并且是这个构造函数的第一句，而且也只能使用一次。</p>
<blockquote>
<p>[!NOTE]</p>
<h3 id="函数重载与类型自动转换"><a href="#函数重载与类型自动转换" class="headerlink" title="函数重载与类型自动转换"></a>函数重载与类型自动转换</h3><p>在零基础学Java中曾经提到过一个类型自动转换的事情。就是如果一个地方，比如函数的参数需要的是比较宽的类型的数据，比如double就比int来得宽，那么如果调用函数的时候给出了int值，是会被自动转换成double去调用函数的。</p>
<p>现在，如果有两个函数重载，一个是double，一个是int，还会发生类型自动转换吗？</p>
<p>写一个测试程序来试一下，告诉大家结果吧。</p>
</blockquote>
<h2 id="第2周对象交互"><a href="#第2周对象交互" class="headerlink" title="第2周	对象交互"></a>第2周	对象交互</h2><h3 id="2-1-对象交互"><a href="#2-1-对象交互" class="headerlink" title="2.1 对象交互"></a>2.1 对象交互</h3><blockquote>
<p>[!NOTE]</p>
<p>面向对象程序设计的第一步，就是在问题领域中识别出有效的对象，然后从识别出的对象中抽象出类来。面对纷繁复杂的现实问题，往往存在多种对象划分的方式，而不同的划分会带来类的设计以至于程序结构的各种不同。对象划分有一些理论，但是不是这门面向对象的入门课程能覆盖的。而且目前的理论也还不是放诸四海皆准的简单操作指南。我们举了一个数字钟的例子，希望通过这个例子表明对象划分的重要性，给你一个感性认识。在今后面对实际的问题领域时，可以试试用这里提到的概念来做对象的划分和类的设计。但是这只是一个例子，遇到具体情况一定是具体分析，按照问题领域的实际情况来做。</p>
<p>一个对象当然可以由其他类的对象来组成，就像一个人体里面有心脏、肠胃一样。对象是由其他对象组成的，而类定义了这样的组合关系。</p>
<p>那么下一个问题，就是当一个对象里有多个对象的时候，那些对象之间是如何交互的，对象和对象之间的联系是如何建立的，对象如何和其他对象交流。对象和对象之间的联系紧密程度叫做耦合。对象和对象的耦合程度越紧，表现在源代码上，就是它们的代码是互相依赖、互相牵制的。我们理想的模型，是对象和对象之间的耦合要尽可能的松，平行的对象要尽量减少直接联系，让更高层次的对象来提供通信服务。这些就是在我们这个非常简单的数字钟的例子中所体现的。</p>
<p>要实现一个数字钟非常简单，如果只是实现功能，入门课程里的一个循环就可以了。这里所体现的，是更深层次的面向对象设计的理念。</p>
<p>本周我们还只是初步接触这些理念，后面还有机会更深入地认识和理解它们。</p>
</blockquote>
<h4 id="2-1-1-对象的识别"><a href="#2-1-1-对象的识别" class="headerlink" title="2.1.1 对象的识别"></a>2.1.1 对象的识别</h4><p>🍎对象交互的思维方式</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114191957343.png" alt="image-20250114191957343"></p>
<p>如果有这样一个数字时钟，桌面上就显示小时、分钟四个数字。我们怎么写程序来表达这样一个事情？我们怎么样能写一个程序出来，它也有这么一个显示四位数字的那么一个时钟？</p>
<p>我们的程序很多时候，就是对我们在日常生活当中，在自然当中所看到的事物的一些描述。把问题领域在计算机的领域去描述出来，从而去解决它。</p>
<p>这样一个时钟我们该这么去解决它呢？有这样几种解决方案：</p>
<p>如果不是面向对象，那么这就是一个循环就完了。我就写一个循环，每隔一分钟怎么怎么样……</p>
<p>如果是面向对象呢？</p>
<p>面向对象的思维方式核心就在于我们要去看到在这个地方有些什么样的东西？每个东西有一些什么样的属性？然后这些东西之间它们是怎么交互的？</p>
<p>那么在这个钟里头有什么东西呢？你要说“我就看见了一只钟啊？这是一个东西”，那我们就讲不下去了。</p>
<p>🍎对象的识别和划分</p>
<p>我们希望的是说：我们看到的在这个场景里面是有一些东西的。这一只钟这四个数字应该是由一些东西去组成的，所以我们要去做的事情是我们怎么去识别出我们问题领域当中的对象。怎么样的一种识别&#x2F;划分是合理的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114194851318.png" alt="image-20250114194851318"></p>
<p>eg：整只钟是一个对象，这是一种划分方法；每一位的数字都是一个对象，这又是一种划分方法。</p>
<p>我们可以说，我们在这个钟里头，有四个对象，每个对象是一个数字，然后每个数字会从0跳到9，变成0的瞬间它会让旁边的那个数字+1。</p>
<p>但更合理的是：把它看作两个两位数字的显示器。——因为对于小时和分钟来说，它们有很多相似的地方。eg：它们都应该有一个数字来表达现在它们的值是多少，它们应该都能够做一个动作&#x2F;去提供一个服务（+1），嘀嗒一下。它在+1的过程中会有那么一个有趣的反应是：就是当他加到了某一个上限的时候。小时和分钟的上限是不一样的（分钟是59后再加1它要变成零，小时是23后再加1它要变成零）。</p>
<p>所以它们有很多相似的东西，它们也有一些不同的东西。</p>
<p>🍎面向对象的设计思路</p>
<p>如果我们把它划分成我们有一个表达分钟的两位数的显示器&#x2F;计数器，另外还有一个表达小时的两位数的显示器&#x2F;计数器。我们就可以用&#x2F;设计 一个 类来表达这种两位数计时器。然后用这一个类去构造出两个对象来，一个表达小时，一个表达分钟，再把它们组合起来。</p>
<p>这两个对象之间他们又有一种交互，最后来形成我们整个的那个作用。</p>
<p>所以我们可以先试试看我们画出这样的一个表达两位的这么一个计数器，它应该是怎么 样子的呢？</p>
<table>
<thead>
<tr>
<th align="center">对象&#x2F;类（我们需要一个这样的东西）：Display（显示 两位数字）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">变量（display里的东西）：value（现在的值）、limit（upper limit上限）</td>
</tr>
<tr>
<td align="center">方法&#x2F;函数（能够做的动作）：Increase（能够被嘀嗒一下&#x2F;递增一个值）、getValue（想要得到value，一个可以获得它value的方法）</td>
</tr>
</tbody></table>
<p>所以我们的一个display大概是这个样子的，当我们识别出这么一个display的对象之后呢，我们可以先从display这个对象本身的角度去考虑说：我们希望这样一个display具有这样的一些东西，然后我们可以先试着去实现这个display，实现了display之后我们再回过头来看，我们作为整个钟对这个display又是什么样的要求、我们现在这个display的设计是不是合理&#x2F;完备的。</p>
<p>🍎设计display类</p>
<p>所以我们先把这个display给它实现出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们这个display只是表达整个钟当中的那么一个小部件，但是我们依然可以为它做一个main出来。我们后面可以看到这非常有用，因为我们做了这一个display我们其实就希望对这个display单独的能够有一个测试。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="comment">//Display有两个成员：一个是value、一个是limit</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//之前我们提到过Java的所有的对象在构造它的时候，每一个成员变量都会得到默认的零值，所以不写这个0没关系，但这是一种好习惯，对自己的一种强化强调的习惯。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Display需要一个构造函数：需要在构造这个Display的时候给它一个limit，每一个Display会有自己不同的limit，表达分钟的那个是60，表达小时的那个是24</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Display</span><span class="params">(<span class="type">int</span> limit)</span> &#123;<span class="comment">//接收limit的构造函数</span></span><br><span class="line">		<span class="built_in">this</span>.limit = limit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;<span class="comment">//让钟跳一步</span></span><br><span class="line">		value++;</span><br><span class="line">		<span class="keyword">if</span> ( value == limit ) &#123;</span><br><span class="line">			value = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value;<span class="comment">//返回现在的value值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Display</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">24</span>);</span><br><span class="line">		<span class="keyword">for</span> ( ;; ) &#123; <span class="comment">//做一个无限循环</span></span><br><span class="line">			d.increase();</span><br><span class="line">			System.out.println(d.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎测试display类</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114201522068.png" alt="image-20250114201522068"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114201534158.png" alt="image-20250114201534158"></p>
<h4 id="2-1-2-对象的交互"><a href="#2-1-2-对象的交互" class="headerlink" title="2.1.2 对象的交互"></a>2.1.2 对象的交互</h4><p>🍎对象交互</p>
<p>我们现在实现的是什么？我们实现了这样一个display，这个display能够给我们实现一个两位数字从00加到23或者从00加到59。显然我们的程序中需要两个这样的display，一个表达小时，一个表达分钟，把这两个东西组合起来它应该是另外一个对象：eg叫做clock。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114211227596.png" alt="image-20250114211227596"></p>
<p>程序由两个类来组成：</p>
<table>
<thead>
<tr>
<th align="center">类&#x2F;对象（我们需要一个这样的东西）：Clock（时钟）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">变量（Clock里的东西）：hour（代表小时的Display成员）、minute（代表分钟的Display成员）</td>
</tr>
<tr>
<td align="center">方法&#x2F;函数（能够做的动作）：</td>
</tr>
</tbody></table>
<p>（我们用一个类的两个对象去构建出了&#x2F;建立起了另外的一个类。在另外一个类里头，有两个别的类的对象。）</p>
<p>对象就是这样一种系统：对象组合成了新的对象。而关于这些事情的描述，在那个（Clock）类里头：每一个Clock类的对象里面有一个Display会有一个Display，一个表达hour另一个表达minute。</p>
<p>接下来的问题是，这两个display的对象他们是怎么互动的？——当表达minute的Display加到59再+1后，它应该要通知旁边的那个东西（表达hour的Display）说你要increase了。这个互动怎么做？</p>
<p>这个互动有几种做法去做：</p>
<p>1）在表达minute的Display里实现一个代码，它能够自己去调用旁边那个hour的那个increase函数。如果是这么做的话，就意味着minute和hour的代码是不一样的的——hour的代码不需要通知别人，minute的代码需要通知别人。那么它们就不可能是同一个Display，或者是我得在Display写点东西，要判断if这个display是minute那么我们做这个、否则我们不做。<strong>总之这个代码会很混乱，<strong>我们希望我们的类的设计、我们的对象将来的结构有这样一个好的局面</strong>：是说每一个类每一个对象都尽可能的独立</strong>——表达minute的Display和表达hour的Display，我们希望能够用一个类来表达这两个对象，我们希望它们俩之间没有直接联系。没有直接联系的好处就是它们各自独立——当我在写表达minute的类的时候，我不用考虑hour怎么办，反之亦然。</p>
<p>那么它们之间的联系就必然要通过第三只手&#x2F;第三方——它们的老大Clock。Clock是凌驾于这两个对象之上的，它知道minute在这里hour在那里，它知道minute在某一个时刻翻转为0了，在那个时候，它可以让hour去+1。</p>
<p>🍎类的设计</p>
<p>是不是可以做出这样一个效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clock</span> &#123;</span><br><span class="line"><span class="comment">//	private Display hour;</span></span><br><span class="line"><span class="comment">//	private Display minute;</span></span><br><span class="line">	<span class="comment">//注意：要特别小心的是，当我们把代码写成上面这个样子，hour是一个成员变量、Display是它的类型。这个时候Display这个对象是没有的。——对象变量是对象的管理者而非所有者。</span></span><br><span class="line">	<span class="comment">//所以我们需要在这里new一个display：</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">Display</span> <span class="variable">hour</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">24</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Display</span> <span class="variable">minute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">60</span>);</span><br><span class="line">	<span class="comment">//这样才是真正说：我们一旦制造出一个Clock的对象来，我们就会去制造出两个Display的对象。</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;<span class="comment">//一旦start起来这个钟就要去走了。</span></span><br><span class="line">		<span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">			minute.increase();</span><br><span class="line">			<span class="keyword">if</span> (minute.getValue() == <span class="number">0</span> ) &#123;</span><br><span class="line">				hour.increase();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">&quot;%02d:%02d\n&quot;</span>, hour.getValue(), minute.getValue()); </span><br><span class="line">			<span class="comment">//printf表示说带格式的输出。&quot;%02d:%02d\n&quot;中的【:】是它固定要输出的内容；【%02d】表示这个位置要输出一个整数，这个整数是一定占据两个字符的位置的，如果它只有个位数，要用这个0来填充。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这是我们整个程序真正的那个main函数。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Clock</span> <span class="variable">clock</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Clock</span>();</span><br><span class="line">		clock.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们这个display只是表达整个钟当中的那么一个小部件，但是我们依然可以为它做一个main出来。我们后面可以看到这非常有用，因为我们做了这一个display我们其实就希望对这个display单独的能够有一个测试。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="comment">//Display有两个成员：一个是value、一个是limit</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//之前我们提到过Java的所有的对象在构造它的时候，每一个成员变量都会得到默认的零值，所以不写这个0没关系，但这是一种好习惯，对自己的一种强化强调的习惯。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Display需要一个构造函数：需要在构造这个Display的时候给它一个limit，每一个Display会有自己不同的limit，表达分钟的那个是60，表达小时的那个是24</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Display</span><span class="params">(<span class="type">int</span> limit)</span> &#123;<span class="comment">//接收limit的构造函数</span></span><br><span class="line">		<span class="built_in">this</span>.limit = limit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;<span class="comment">//让钟跳一步</span></span><br><span class="line">		value++;</span><br><span class="line">		<span class="keyword">if</span> ( value == limit ) &#123;</span><br><span class="line">			value = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value;<span class="comment">//返回现在的value值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Display</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">24</span>);</span><br><span class="line">		<span class="keyword">for</span> ( ;; ) &#123; <span class="comment">//做一个无限循环</span></span><br><span class="line">			d.increase();</span><br><span class="line">			System.out.println(d.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎成员变量和对象组合</p>
<p>现在在我们的这个工程里头，我们是有两个类的，一个是Display，一个是Clock。在Display里头有自己的main函数，在Clock里头也有自己的main函数，没关系，我们能够同时去使用这些东西。我们打开Clock.java的时候去运行它，它就会运行的是Clock里头的main函数。于是我们的钟就走起来了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114212833822.png" alt="image-20250114212833822"></p>
<p>16 : 59之后变成17 : 00。看上去很不错的结局。</p>
<p>🍎对象的独立性</p>
<p>在这个程序当中，我们重点想要表达什么呢？一个类里面，它的成员变量可以是其他类的对象。那么最终的结局就是一个对象里面其实是有其他的对象组成的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114213150431.png" alt="image-20250114213150431"></p>
<p>——一个Clock的对象里面是由两个display的对象所组成的。在内存里：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250114213426206.png" alt="image-20250114213426206"></p>
<p>——一个Clock里有两个Display，这两个Display有各自的value和limit。然后Clock里面有个start函数，用来让这两个Display对象之间发生一个互动：它会让一个Display去increase，而increase的结果用来让另一个Display去做increase的动作。</p>
<p>所以从这两个Display的角度来说，它们是完全独立的。——互相不知道对方的存在，它的代码完全和另外一个Display没有任何关系。Display只做好自己的事情，然后由外面的Clock去把它们联系起来。</p>
<blockquote>
<p><strong>increase返回boolean来表示翻转好不好？</strong><br>Q：如果Display的increase函数，在发现翻转之后，就返回true表示这次increase翻转了，是不是一个好的设计？</p>
<p>A：我觉得这样设计挺好的啊，直接上代码</p>
<p>void tick(){<br>   if(c.tick()) {  &#x2F;&#x2F;每次执行会秒钟tick一下，如果清零了，c1就会tick一下<br>     if (c1.tick()) {  &#x2F;&#x2F;如果c1 tick一下清零了，c2就会tick一下<br>       c2.tick();<br>     }<br>   }<br>}</p>
<p>以上是Clock中钟走动的方法，我定义了时，分，秒三个display对象，这样设计不用直接访问分钟的value，很符合面向对象封装性的特点，代码也更简洁了。</p>
<p>eg：display和clock都有tick方法，display的tick在执行完后会判断这次tick是否翻转了</p>
</blockquote>
<blockquote>
<h3 id="如何做直接交互？"><a href="#如何做直接交互？" class="headerlink" title="如何做直接交互？"></a>如何做直接交互？</h3><p>Q：视频中的代码，表示分钟的对象和表示小时的对象没有直接交互。如果想要做直接交互，让表示分钟的对象在翻转的时候直接调用表示小时的对象的那个increase函数，代码需要怎样修改？</p>
<p>A：如果你想要在表示分钟的对象在翻转时直接调用表示小时的对象的 <code>increase</code> 函数，你可以在 <code>Display</code> 类中添加一个引用，将表示小时的 <code>Display</code> 对象传递给表示分钟的 <code>Display</code> 对象。然后，你可以在表示分钟的 <code>increase</code> 方法中调用表示小时的对象的 <code>increase</code> 方法。</p>
<p>以下是修改后的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">private</span> <span class="type">Display</span> <span class="variable">nextDisplay</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 新增属性，用于保存下一个 Display 对象的引用</span></span><br><span class="line">   </span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Display</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// 新增方法，用于设置下一个 Display 对象的引用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextDisplay</span><span class="params">(Display nextDisplay)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextDisplay = nextDisplay;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        value++;</span><br><span class="line">        <span class="keyword">if</span> (value == limit) &#123;</span><br><span class="line">            value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (nextDisplay != <span class="literal">null</span>) &#123;</span><br><span class="line">                nextDisplay.increase(); <span class="comment">// 在翻转时调用下一个 Display 对象的 increase 方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Display</span> <span class="variable">hour</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">24</span>);</span><br><span class="line">        <span class="type">Display</span> <span class="variable">minute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">60</span>);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 设置分钟的下一个 Display 对象为小时</span></span><br><span class="line">        minute.setNextDisplay(hour);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// ... 其他代码 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 方法中，我们创建了一个表示小时的 <code>Display</code> 对象和一个表示分钟的 <code>Display</code> 对象，并通过调用 <code>setNextDisplay</code> 方法将分钟的下一个 <code>Display</code> 对象设置为小时。这样，在分钟翻转时，会调用小时的 <code>increase</code> 方法。</p>
<p>请注意，这种设计依赖于每个 <code>Display</code> 对象的下一个对象，因此你需要小心确保在设置下一个对象时不会形成循环引用。</p>
</blockquote>
<h3 id="2-2-访问属性"><a href="#2-2-访问属性" class="headerlink" title="2.2 访问属性"></a>2.2 访问属性</h3><blockquote>
<p>[!NOTE]</p>
<p><strong>封装是面向对象的基本概念</strong></p>
<p>封装，就是把数据和对这些数据的操作放在一起，并且用这些操作把数据掩盖起来，是面向对象的基本概念之一，也是最核心的概念。</p>
<p>我们有一个非常直截了当的手段来保证在类的设计的时候做到封装：</p>
<p>1.所有的成员变量必须是private的，这样就避免别人任意使用你的内部数据；</p>
<p>2.所有public的函数，只是用来实现这个类的对象或类自己要提供的服务的，而不是用来直接访问数据的。除非对数据的访问就是这个类及对象的服务。简单地说，给每个成员变量提供一对用于读写的get&#x2F;set函数也是不合适的设计。</p>
</blockquote>
<h4 id="2-2-1-封闭的访问属性"><a href="#2-2-1-封闭的访问属性" class="headerlink" title="2.2.1 封闭的访问属性"></a>2.2.1 封闭的访问属性</h4><p>🍎封装</p>
<p>我们在介绍到对象和类的关系的时候，曾经提到说对象呢，是这样一种东西：我们总是可以把它想象成一个剖开一半的鸡蛋（1.1-类和对象的关系-图例），里面是表达这个对象属性的数据，外面包围起来的是针对对象（这些数据）的操作，作为这个对象对外提供的一些服务。外面的这层蛋白把蛋黄紧紧的包裹在一起，我们叫做<code>封装</code>。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250103195737102.png" alt="image-20250103195737102"></p>
<p>所谓封装，就是把数据和对这些数据的操作放在一个地方，通过这些操作把这些数据保护起来，别人呢不能直接接触到这些数据。</p>
<p>那么从具体的语言的实现上面来说呢，Java做这件事情主要采用的手段就是所有的成员都可以去设定它的访问属性，eg时钟的程序，在Display里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>我们说：value、limit这是两个成员变量，这两个成员变量的前面我们有private这样的关键字。<code>private</code>（私有的）用来表明说这两个成员变量是私有的。我们不能把这两个成员变量放在，比如说我们有一个成员函数里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> i;	<span class="comment">//是不行的</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>private</code>关键字只能用于成员变量以及成员函数。但我们现在这里所有的成员函数是public，我们一会再说public是怎么回事，我们先说private的问题。</p>
<p><code>private</code>的意思是说：这个东西他如果在成员变量的前面，就说这个成员变量；它如果在一个成员函数的前面，就说这个成员函数。<strong>是说这个成员是这个类所私有的。</strong></p>
<p><code>私有</code>的意思是说：只有在这个类的内部才能去访问它。</p>
<p>🍎私有成员变量的访问</p>
<p>那么对于成员变量来说，我们对它其实只有<strong>两个</strong>地方可以做访问：一个地方就是在成员函数里头（可能是构造函数…）；第二个就是在定义初始化的地方（可以去使用别的、已经定义的成员变量）。</p>
<p>eg1，在成员函数里头访问private的成员变量。increase中做value的++：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;<span class="comment">//让钟跳一步</span></span><br><span class="line">            value++;</span><br><span class="line">            <span class="keyword">if</span> ( value == limit ) &#123;</span><br><span class="line">                value = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>increase是一个成员函数。所谓<code>成员函数</code>就是在这个类（Display）的里头的。最简单的看法是这个类（Display）会有一个大括号，在这一对大括号里面的所有东西都是在这个类里头。这里面的成员函数都可以自由地去使用private的变量。</p>
<p>eg2，定义初始化的地方访问private的成员变量value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🍎私有成员变量的可见性</p>
<p>假如我们试着在外面去使用它，eg在Clock里头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Clock</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Display</span> <span class="variable">hour</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">24</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Display</span> <span class="variable">minute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">60</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        hour.value ++;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//。。。其他代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，第4行说：hour是Clock内部的成员变量，这个成员变量的类型是Display并不是Clock。</p>
<p>所以现在如果在Clock的一个成员函数里（eg：start函数），我们想说：我们想让这个hour的那个value（我们知道它里头有个叫做value），让它++（第8行）。我们想做这件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250115095225474.png" alt="image-20250115095225474"></p>
<p>——错误提示会说：the field Display的那个value，这个东西是看不见的&#x2F;不可见的（not visible）。</p>
<p>🍎私有成员变量的访问范围</p>
<p>也就是说，作为一个私有（private）的成员变量，在它所在的类的外面，这个成员变量它就看不见了。它在不在呢？肯定还是在的，我们知道hour一定是有value的，但是呢，我们不能直接去使用它。</p>
<p>因为它是<code>private</code>的。</p>
<p>🍎私有成员变量的访问规则</p>
<p>回过来说，在main里面，能不能用？eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Display</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.limit = limit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">		value++;</span><br><span class="line">		<span class="keyword">if</span> ( value == limit ) &#123;</span><br><span class="line">			value = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Display</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">24</span>);</span><br><span class="line">         d.value ++;</span><br><span class="line">		<span class="keyword">for</span> ( ;; ) &#123; </span><br><span class="line">			d.increase();</span><br><span class="line">			System.out.println(d.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在main函数里面，我们说d的value去++（第24行）行吗？可以，因为这个main也是写在Display这个类里头的，它是这个类的一个成员（当然，它有它的特殊性，eg：它前面有static，这件事情我们后面再来说）。</p>
<p>所以private的意思是说：只有自己能访问。</p>
<p>不过我们之前做过的那一个编程题fraction（那个分数），我们曾经要求做这样一件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250115100412059.png" alt="image-20250115100412059"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250115100433099.png" alt="image-20250115100433099"></p>
<p>我们的fraction类里头，有两个函数，一个是plus（27行），一个是multiply（34行）。plus要做的事情是说，我要把两个fraction给加起来，这个函数的参数是另外一个fraction的对象。</p>
<p>我们当然在设计的时候，需要把我们的成员变量做出给你private（3、4行）。</p>
<p>可以说我们有一个非常非常基本的原则：就是所有的成员变量（除非你有非常合理的理由），这些成员变量它们应该是私有的。只有让成员变量是私有的，才能保护这些变量不被外界随意的使用，才能够让这些变量只按照这个类的设计者自己的意图去发生改变&#x2F;去被使用 。</p>
<p>所以成员变量应该是私有的。因此我们看到我们的fraction里面的这两个成员变量也应该是私有的。</p>
<p>可是，接下来的问题是：当我们在plus()里要做加法的时候，我们拿到了另外一个fraction的对象，我们在这个函数（plus）的内部，我们能不能访问另外的那个fraction里面的那个私有的b呢？因为这个b不是私有的吗？所以关键在下面这句话：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250115101322859.png" alt="image-20250115101322859"></p>
<p>——private这个私有，是针对类来说的。或者说，从这个语言的角度来说，我们去看你有没有突破这个私有的边界，你有没有去访问不该访问的东西，都是从<strong>代码</strong>的层面上来看的。而不是从运行的层面上来看的。</p>
<p>从代码的层面上来看：只要你对它的所有的私有的访问是在这个类的内部发生的，它就是合理的，它就是合乎规定的。</p>
<p>换句话说：一个类（同一个类）的所有的不同的对象之间可以互相访问别人的私有的成员 。私有是针对类而不是针对对象的。</p>
<p>这一点是一个很小的细节，但是值得注意。</p>
<h4 id="2-2-2-开放的访问属性"><a href="#2-2-2-开放的访问属性" class="headerlink" title="2.2.2 开放的访问属性"></a>2.2.2 开放的访问属性</h4><p>🍎访问属性</p>
<p>除了私有，我们更常见的是public。我们很多的成员函数都是public。public的意思就是任何人都可以访问。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120213507921.png" alt="image-20250120213507921"></p>
<p><strong>构造函数本身也是public。</strong></p>
<p>public就意味着，在很多地方可以用它，eg：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120213941870.png" alt="image-20250120213941870"></p>
<p>Clock是另外一个类，在Clock这个类里面，你可以自由的去使用Display这个类里面所有的public的东西：</p>
<p>构造器（eg，第4行：因为你需要去new它，在这个时候就会调用到Display的构造函数，这是public的构造函数。）、increase()（第9行。没问题，因为increase()是public的。）、getValue()（第10行。没问题，因为getValue()是public的。）</p>
<p>——public就意味着其他人可以自由的使用它。</p>
<p>🍎friendly访问权限</p>
<p>还会有一种：</p>
<p>如果我们没有在一个成员前面加上<code>public</code>或者<code>private</code>的关键字来限定它，那么意味着我们把它叫做<code>friendly</code>。意思是说：和它位于同一个包的类可以访问。</p>
<p>（现在虽然我们还没有说包是什么，我们可以从eclipse的这边看，我们发现说：这两个类Clock和Display处于同一个&#x2F;层的目录clock里头，我们认为它们属于同一个包。那么所有不带public、private的关键字的东西，它们是可以访问的。）</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120214939967.png" alt="image-20250120214939967"></p>
<p>这是叫做<code>friendly</code>。我们还会有另外一个限定词叫做<code>protected</code>。这件事情呢，我们到学继承的时候我们再来看protected是什么意思。</p>
<p>另外我们看到，除了类的成员（成员变量和成员方法）有public的关键字之外，可能我们也注意到在class（类）的前面我们也会加上这个public的关键字。</p>
<p>一个类前面如果加上public&#x2F;一个类是public的，表明：任何人都可以用这个类的定义来定义变量。</p>
<p>🍎public类的定义</p>
<p>那么如果你的这个类是public，就会有一个要求：<strong>它必须处在一个源代码文件里头，这个源代码文件的文件名必须和这个类的名字相同。</strong></p>
<p>如果不是这样会怎么样？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120220207279.png" alt="image-20250120220207279"></p>
<p>这个public的类型（我们讲过，class就是类）Clocks（因为改名字了）必须定义在它自己的文件里面。——为什么不是它自己的文件，因为我们现在的文件名叫做Clock，不叫作Clocks。它给出的解决方案是：重新命名<code>编译单元</code>为‘Clocks.java’。</p>
<p>刚刚出现了另外一个新的术语叫做编译单元。一个 .java文件（源代码文件）是一个编译单元。<code>编译单元</code>的意思是：编译的时候一次对这一个编译单元去做编译的动作。</p>
<p>在一个编译单元里，可以有很多Java类，但只要<strong>一个</strong>类可以是public。（eg我们在fraction的作业里头大家就是这么做的。我们给了一个mean，然后你要自己做个fraction，然后我们需要把它放在一个编译单元里头。）</p>
<p>否则：会提醒另外的这个public类需要定义在它自己的文件里。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120220846406.png" alt="image-20250120220846406"></p>
<p>但如果它不是public是可以的。——如果这个类前头没有public，意味着这个类只能在这个包里面起作用。</p>
<p>也就是说，如果你想让这个类成为一个在任何地方都可以用的类，那么它必须public。而它如果是public，它就必须在它自己的文件里面。文件名和类的名字必须相同。</p>
<blockquote>
<p><strong>为什么说private是对类的不是对对象的</strong><br>Q：这话到底是什么意思？private的访问属性到底限制的是什么？</p>
<p>A：这句话的含义是指<code>private</code>是针对类而不是对象的。在面向对象编程中，类是对象的模板，而对象是类的实例。<code>private</code>是一种访问修饰符，用于限制对类的成员的访问权限。</p>
<p>当在类中使用<code>private</code>修饰成员（如字段、方法等）时，这些成员就只能在该类的内部访问，而无法被类的外部代码直接访问。这包括类的对象。</p>
<p>举例来说，考虑一个类<code>Car</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String model;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String model)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.model = model;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startEngine</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Engine started&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>model</code>字段和<code>startEngine</code>方法都被声明为<code>private</code>。这意味着只有<code>Car</code>类内部的方法才能访问<code>model</code>字段和调用<code>startEngine</code>方法。即使创建了<code>Car</code>的对象，外部代码也不能直接访问<code>model</code>或调用<code>startEngine</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;Toyota&quot;</span>);    </span><br><span class="line">    <span class="comment">// 下面的代码将会导致编译错误，因为model是private的</span></span><br><span class="line">    <span class="comment">// myCar.model; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码也会导致编译错误，因为startEngine是private的</span></span><br><span class="line">    <span class="comment">// myCar.startEngine(); </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<code>private</code>关键字限制的是对类的成员的直接访问，而不是限制对类的实例（对象）的访问。私有成员只能在定义它们的类的内部使用，这有助于实现封装和隐藏实现细节的原则，提高代码的安全性和可维护性</p>
</blockquote>
<h3 id="2-3-包-Package"><a href="#2-3-包-Package" class="headerlink" title="2.3 包 Package"></a>2.3 包 Package</h3><blockquote>
<p>[!NOTE]</p>
<p><strong>包是Java的类库管理机制</strong></p>
<p>当你的程序越来越大的时候，你就会需要有一个机制帮助你管理一个工程中众多的类了。包就是Java的类库管理机制，它借助文件系统的目录来管理类库，一个包就是一个目录，一个包内的所有的类必须放在一个目录下，那个目录的名字必须是包的名字。</p>
<p>作为初学者，你可以忽略不看包，反正一切靠Eclipse。但是作为一个Java程序员，你不能不懂包。要不然，在使用别人的类库和部署你的程序的时候，会遇到不少莫名其妙的麻烦。</p>
<p>因为，包治百病啊！</p>
</blockquote>
<p>🍎包的概念和作用</p>
<p>我们已经多次的提到了<code>包</code> (<code>Package</code>)。到底这个包是什么？</p>
<p>eg：我在eclipse里有一个叫clock的项目， 在这个clock里头我说我要有一个class，它就会自动问我Package要不要叫clock。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120223109566.png" alt="image-20250120223109566"></p>
<p>然后我这么做了一个类以后，我们就看见说在clock项目文件夹和两个类之间还要一个src，还有一个clock，这些是什么？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120223257012.png" alt="image-20250120223257012"></p>
<p>而且在这两个类的源代码文件的第一行，都有一行叫做package clock;，这一行又在干什么？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120223437586.png" alt="image-20250120223437586"></p>
<p>我们首先记住我们的包叫做clock，然后我们到外面去看一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120223623813.png" alt="image-20250120223623813"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120223702888.png" alt="image-20250120223702888"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120223654529.png" alt="image-20250120223654529"></p>
<p>所以你看我们的文件夹&#x2F;目录的这个结构是：src下面有clock，clock下面有Clock.java和Display.java。而在eclipse里，工程下面有src，src下面有clock，而这个clock是一个Package。</p>
<p>🍎包的命名和文件结构</p>
<p>那这个包又是什么呢？</p>
<p>那我们来做这样的事情，如果我们在clock的工程里头new一个名字叫做display的package，我们再回到目录里去看看是怎么回事。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120224052096.png" alt="image-20250120224052096"></p>
<p>src下面除了clock以外还有一个display。</p>
<p>🍎包的导入和访问权限</p>
<p>将Diaplay类移到display包中后，Clock类会出错：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120224324958.png" alt="image-20250120224324958"></p>
<p>——display的getValue()不可见了，为什么呢？因为我们刚才做了一点小改动：把public给拿走了。没了public我们说它的意思是friendly，意思说在一个包的内部是可以访问的，而现在，Display和Clock在两个包里了，它就不能访问了，这是一件事情。</p>
<p>第二件事情，如果再仔细回到Clock来看，我们多了一行这个：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120225941551.png" alt="image-20250120225941551"></p>
<p>import display里面的Display。我们之前做scanner的时候我们用过那个：我们知道我们敲了scan然后敲了快捷键它会帮我们自动补全并且帮我们加上了那句import java.util.scanner。那是系统的，现在是我们自己的，我们自己的也有这样的东西。</p>
<p>它说，你要用另一个包里的那个类了，那么我就要帮你import，把那个包里面的那个类的定义给你拿过来，我才能够明白你下面对这个display的使用是不是正确的。import就是干这事。只要你用到的那个类跟你不在一个包里，你就import它。</p>
<p>所以import后面的写法就是：包的名字.包里面那个类的名字</p>
<p>而如果你有了一个包，那么这个包里所有的源代码文件的第一行一定都是那个包的名字。这就表明说，我们用文件夹来管理包。</p>
<p>——Java的包并没有一个更加复杂的系统或者一个什么软件去管理它，我们就是用目录：在一个目录底下的所有的源代码文件（编译单元）都属于同一个包，那个包的名字就是那个目录的名字。这就是它的类的管理的方式。</p>
<p>🍎包的全名和导入方式</p>
<p>用这种方式呢，还形成了另外一种东西：</p>
<p>我们前面在import后面说：这叫做display.Display，这就形成了这个类的一个全名（forname）。那如果说我们不做这样的import，我们也可以在下面说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120231214828.png" alt="image-20250120231214828"></p>
<p>——如果你不去import，你可以以这种方式在当要用到类的名字的时候，给出类的全名，而不是只给出它的那个givenname（家族名）。</p>
<p>但import还有另外一种写法是这样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> display.*;</span><br></pre></td></tr></table></figure>

<p>要import display包里的所有东西，用一个星座通配符。</p>
<p>这种做法可以用，但我们有的时候会觉得它会有一点点不太好的：万一你有一些重名的东西，你把这个包里的所有东西都引进来了，如果和别人有冲突怎么办？</p>
<p>所以呢，比较推荐的仍然是在import的地方，给出它的全名。</p>
<p>🍎包的管理机制和类的放置</p>
<p>还有一个细节是这样：我们需要有一种特殊的display形式，它是一种display但是我们给它放在一个display里面更深的一个包的里面（display下面有一个led）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120231808863.png" alt="image-20250120231808863"></p>
<p>我们出去看看是什么情况：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120232004165.png" alt="image-20250120232004165"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120232018262.png" alt="image-20250120232018262"></p>
<p>src下并没有一个叫做display.led的东西，但是display下面有了一个led。</p>
<p>所以如果我们把现在这个display再进一步拖到那个displayled里面去：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120232154227.png" alt="image-20250120232154227"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250120232147361.png" alt="image-20250120232147361"></p>
<p>你看着是不是有点像import java.util.Scanner;</p>
<p>包的名字可以带有【 . 】，这个点实际上表达的就是我们在文件系统里面的文件夹的层次，每一个点就代表一层文件夹的层次。Java通过这样的手段来管理所有的类，把这些类给它起上全名，然后分门别类的放到各种包里面，形成一个有效的类的<code>管理机制</code>，这个管理机制叫做<code>包</code>。</p>
<p>所以基本上来说，我们要把一个类放在一个包里面，那么就要为它建一个目录，然后在前头要说它package 什么什么。然后要去使用别的包里面的类，那么我们就要import那些东西，这就是Java的包的管理机制。</p>
<h3 id="2-4-类变量"><a href="#2-4-类变量" class="headerlink" title="2.4 类变量"></a>2.4 类变量</h3><blockquote>
<p>[!NOTE]</p>
<p><strong>类变量和类函数</strong></p>
<p>类是描述，对象是实体。在类里所描述的成员变量，是位于这个类的每一个对象中的。</p>
<p>而如果某个成员有static关键字做修饰，它就不再属于每一个对象，而是属于整个类的了。</p>
<p>通过每个对象都可以访问到这些类变量和类函数，但是也可以通过类的名字来访问它们。类函数由于不属于任何对象，因此也没有办法建立与调用它们的对象的关系，就不能访问任何非static的成员变量和成员函数了。</p>
</blockquote>
<h4 id="2-4-1-类变量"><a href="#2-4-1-类变量" class="headerlink" title="2.4.1 类变量"></a>2.4.1 类变量</h4><p>🍎类变量</p>
<p>我们从一开始学Java，我们就遇到过这个叫做static的东西，我们的那个main函数。当然我们一开始说你打上那个勾让eclipse帮你建起来就有那个main了，你就别管它是什么了。然后我们在讲到函数的时候，说你还没学那么多嘛，你所有的函数都得是static了，要不然你从那里头调用不了。然后我们开始说我们要自己设计一个类，自己建立定义一个类的时候，我们又发现说：为什么那些类的所谓的成员函数都不带static。那这个<code>static</code>到底是什么意思？</p>
<p>🍎对象的成员变量</p>
<p>我们先来试一个之间没做过的事情，假如我有一个成员变量，我在前面也加了static，它会怎么样呢？（<code>static</code>中文我们也可以直接说<code>静态</code>。但有的时候我们不太想用静态这个词来表达在这儿的static的意思，因为它不是一般意义上静态和动态的那个静态。）</p>
<p>所以我们来看这么昨晚以后有什么特别的地方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Display</span><span class="params">(<span class="type">int</span> limit)</span> &#123;<span class="comment">//接收limit的构造函数</span></span><br><span class="line">		<span class="built_in">this</span>.limit = limit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;<span class="comment">//让钟跳一步</span></span><br><span class="line">		value++;</span><br><span class="line">		<span class="keyword">if</span> ( value == limit ) &#123;</span><br><span class="line">			value = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value;<span class="comment">//返回现在的value值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Display</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="type">Display</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">20</span>);</span><br><span class="line">		d1.increase();</span><br><span class="line">		System.out.println(d1.getValue());</span><br><span class="line">		System.out.println(d2.getValue());</span><br><span class="line">		System.out.println(d1.step);</span><br><span class="line">		System.out.println(d2.step);</span><br><span class="line">		d1.step = <span class="number">2</span>;</span><br><span class="line">		System.out.println(d1.step);</span><br><span class="line">		System.out.println(d2.step);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121210720686.png" alt="image-20250121210720686"></p>
<p>第一个 1，是d1的Value，因为我们对它做了increase它被加1了。</p>
<p>第二个 0，是d2的Value，它保持不变。</p>
<p>第三四个 1，表明在此刻d1和d2的step都是1。</p>
<p>第五六个 1，表明在此刻d1和d2的step都是2。</p>
<p>🍎通过类名访问静态变量</p>
<p>——那个静态的（static）变量 step ，它的表现是说：你通过一个对象去修改那个step，别的对象里面的那个step也改了。</p>
<p>那么我们可以去揣摩说是不是有这样一种机制：有一个对象的值被改过了，它会去通知别的对象，让它们也改一改？——还是有另外一种做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上例的输出后继续：</span></span><br><span class="line">Display.step = <span class="number">3</span>; <span class="comment">//Display类也有一个叫做step的东西</span></span><br><span class="line">System.out.println(d1.step);</span><br><span class="line">System.out.println(d2.step);</span><br><span class="line"><span class="comment">//输出会是两个3</span></span><br></pre></td></tr></table></figure>

<p>🍎类变量与成员变量的区别</p>
<p>Display是一个类，d1是一个对象，对象里面才有变量。对吧？我们之前讲成员变量讲的很明白：类是规范，类是定义，类决定了所有这个类的对象长这个样子、有这样的一些成员变量、有这样的一些成员函数。</p>
<p>成员变量是在对象里头的，不在那里头。</p>
<p>而现在我们看到了什么？我们看到了可以用  类的名字 +【 . 】+ static的变量的名字  来访问那个变量。eg，当用Display.value &#x3D; 3; 访问value时：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121211826637.png" alt="image-20250121211826637"></p>
<p>会报错显示不能访问这个value。</p>
<p>所以只有static的成员变量可以通过这个方式去访问。通过 类的名字 +【 . 】+ static的变量的名字  来访问。</p>
<p>所以static的成员变量到底是什么呢？</p>
<p>我们把它叫做<code>类变量</code>。它不是成员变量，它是这个类的变量，它不属于这个类的任何一个对象，它属于这个类。所以任何一个对象都拥有这个变量，但只有那一份。</p>
<p>🍎对象访问类变量的两种方式</p>
<p>也就是说，我们有一个类，叫做Display，它自己带了一个变量step。我们又做了两个对象d1和d2，他们有自己的value和limit，但是这两个对象里面没有那个step，可是我们要想访问这个step两种方案都可以：1）Display.step （Display的step）2）d1.step</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121212439447.png" alt="image-20250121212439447"></p>
<p>其中d1.step并不意味着d1中有step变量，而是d1知道自己属于Display类，d2也知道，他们俩都有办法访问到他们所属类里面的step变量。</p>
<h4 id="2-4-2-类函数"><a href="#2-4-2-类函数" class="headerlink" title="2.4.2 类函数"></a>2.4.2 类函数</h4><p>🍎类函数和类变量</p>
<p>我们的main函数前面有static，我们之前学函数的时候让大家写的所有的函数都是static。我们知道如果你在这个main函数里面不是像我们现在这样：</p>
<p>我们现在是在这个main函数里构造了两个display对象d1、d2，然后用d1、d2去调用increase()、getValue()这样的函数。</p>
<p>如果你想在这里直接调用，比如说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121213039360.png" alt="image-20250121213039360"></p>
<p>当然是不行的，它会说我不知道去increase谁，为什么？</p>
<p>跟前面变量一样，因为函数前面的static表明它不属于这个对象，它属于这个类。这个函数和对象没关系，这个函数是属于类的。</p>
<p>换句话说，如果increase不是static，我们可以用d1.increase();</p>
<p>🍎static函数和static变量的访问规则</p>
<p>而：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121213352061.png" alt="image-20250121213352061"></p>
<p>假如有一个新的static函数，就可以像32行一样调用，因为大家都是static。</p>
<p>在static函数里头你可以去调用别的static函数，然后你也可以d1.f();（通过一个对象去调用），但是这个时候在f里头你不能去访问任何非static的值：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121213704229.png" alt="image-20250121213704229"></p>
<p>它会说你在一个static里头不能去访问一个non-static的value。</p>
<p>所以你看，如果这个value++是可行的，我们在32行直接做f的时候，它去加谁的value？</p>
<p>所以表面上，规则非常简单：static的函数只能去访问static的成员变量。static的函数和static的权限变量都可以通过类的名字去访问，但是也可以通过某个对象的名字去访问，只是通过对象名字去访问的时候，它并不能获得那个对象的具体的信息。</p>
<p>这叫做<code>类变量</code>和<code>类函数</code>。这些static的变量是属于这个类的，这些static的函数是属于这个类的，它们不属于任何具体的对象。</p>
<p>🍎static成员变量的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>那么如果我们在类的前面对这个step做了一次初始化，可以想见这种初始化只会做一次。——虽然后面做了两个对象d1和d2，但是对于step的初始化只做了一次。</p>
<p>我们有很多办法去检验这件事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> clock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们这个display只是表达整个钟当中的那么一个小部件，但是我们依然可以为它做一个main出来。我们后面可以看到这非常有用，因为我们做了这一个display我们其实就希望对这个display单独的能够有一个测试。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Display</span> &#123;</span><br><span class="line">	<span class="comment">//Display有两个成员：一个是value、一个是limit</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//之前我们提到过Java的所有的对象在构造它的时候，每一个成员变量都会得到默认的零值，所以不写这个0没关系，但这是一种好习惯，对自己的一种强化强调的习惯。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Display需要一个构造函数：需要在构造这个Display的时候给它一个limit，每一个Display会有自己不同的limit，表达分钟的那个是60，表达小时的那个是24</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Display</span><span class="params">(<span class="type">int</span> limit)</span> &#123;<span class="comment">//接收limit的构造函数</span></span><br><span class="line">		<span class="built_in">this</span>.limit = limit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;<span class="comment">//让钟跳一步</span></span><br><span class="line">		value++;</span><br><span class="line">		<span class="keyword">if</span> ( value == limit ) &#123;</span><br><span class="line">			value = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> value;<span class="comment">//返回现在的value值</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line"><span class="comment">//		Display d = new Display(24);</span></span><br><span class="line"><span class="comment">//		for ( ;; ) &#123; //做一个无限循环</span></span><br><span class="line"><span class="comment">//			d.increase();</span></span><br><span class="line"><span class="comment">//			System.out.println(d.getValue());</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Display</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">10</span>);</span><br><span class="line">		d1.step = <span class="number">2</span>;</span><br><span class="line">		System.out.println(d1.step);</span><br><span class="line">		<span class="type">Display</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Display</span>(<span class="number">20</span>);</span><br><span class="line">		System.out.println(d2.step);</span><br><span class="line">		d1.increase();</span><br><span class="line"><span class="comment">//		increase(); //不行</span></span><br><span class="line">		f();</span><br><span class="line">		d1.f();</span><br><span class="line">		System.out.println(d1.getValue());</span><br><span class="line">		System.out.println(d2.getValue());</span><br><span class="line">		System.out.println(d1.step);</span><br><span class="line">		System.out.println(d2.step);</span><br><span class="line">		d1.step = <span class="number">2</span>;</span><br><span class="line">		System.out.println(d1.step);</span><br><span class="line">		System.out.println(d2.step);</span><br><span class="line">		Display.step = <span class="number">3</span>;</span><br><span class="line">		System.out.println(d1.step);</span><br><span class="line">		System.out.println(d2.step);	</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在做了d1之后，我们就说d1的step&#x3D;2，然后我们就可以让它输出一下，应该是2。然后再去new了一个d2出来，这个时候我们让它把d2的step给输出，应该还是2。</p>
<p>也就是说，static的这些变量，只会在<code>类的装载</code>（指类进入到程序里头去的时候）的时候被初始化，在后面不会被初始化。也就是说，这些static的成员，它们的初始化和对象的创建是<strong>没有关系的</strong>。</p>
<blockquote>
<h3 id="在类函数中有this吗？"><a href="#在类函数中有this吗？" class="headerlink" title="在类函数中有this吗？"></a>在类函数中有this吗？</h3><p>Q：在类函数中有this吗？为什么？</p>
<p>A：类函数中没有this，因为类函数不属于任何对象，所以类函数中也就没有当前对象的引用</p>
</blockquote>
<h2 id="第3周对象容器"><a href="#第3周对象容器" class="headerlink" title="第3周	对象容器"></a>第3周	对象容器</h2><h3 id="3-1-顺序容器"><a href="#3-1-顺序容器" class="headerlink" title="3.1 顺序容器"></a>3.1 顺序容器</h3><blockquote>
<p>[!NOTE]</p>
<p><strong>容器</strong></p>
<p>容器是现代程序设计非常基础而重要的手段。</p>
<p>所谓容器，就是“放东西的东西”。数组可以看作是一种容器，但是数组的元素个数一旦确定就无法改变，这在实际使用中是很大的不足。一般意义上的容器，是指具有自动增长容量能力的存放数据的一种数据结构。在面向对象语言中，这种数据结构本身表达为一个对象。所以才有“放东西的东西”的说法。</p>
<p>Java具有丰富的容器，Java的容器具有丰富的功能和良好的性能。熟悉并能充分有效地利用好容器，是现代程序设计的基本能力。</p>
<p>我们首先学习的是顺序容器，即放进容器中的对象是按照指定的顺序（放的顺序）排列起来的，而且允许具有相同值的多个对象存在。</p>
<p><strong><em>在一些书中，将容器（英文为collection或container）翻译为“集合”，由于数学中的集合（Set）也是一种特定的容器类型，我们认为将collection翻译为集合是不恰当的。所以我们只会使用容器一词。</em></strong></p>
</blockquote>
<h4 id="3-1-1-记事本的例子"><a href="#3-1-1-记事本的例子" class="headerlink" title="3.1.1 记事本的例子"></a>3.1.1 记事本的例子</h4><p>🍎记事本需求</p>
<p>想要做一些记事本。所谓记事本就是它可以记一些条目嘛。</p>
<p>如果想做一个程序来实现这样一个记事本，我们需要实现一些怎么样的功能呢？&#x2F;我们对这个记事本的需求是什么？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107202748075.png" alt="image-20250107202748075"></p>
<p>在确定了这个需求之后，我们接下来可以去做的事情就是 界定 它的接口设计：如果我有一个类，这个类要用来表达这么一个notebook，那么这个类应该实现一些怎么样的接口。</p>
<p>🍎初学者程序倾向</p>
<p>我们在思考这些程序的时候一定要避免一个初学者的倾向：因为我们初学程序的时候，所有的程序是所有的功能部分都在一起的。从某个角度来说，我们认为这样的程序，你的人机交互部分和你的业务逻辑部分是完全捆绑在一起的。</p>
<p>人机交互：输入的地方，输出的地方。</p>
<p>业务逻辑：对输入数据进行计算的部分。</p>
<p>初学的时候，为了表达的方便，我们写的所有的程序都是这样子的：输进来-计算-输出。</p>
<p>但真正的软件没有这么干的，真正的软件一定要实现：你的界面 &#x2F; UI和你的业务逻辑要分离。</p>
<p>让专门做UI的人去做UI，让专门做业务逻辑的人去做业务逻辑。</p>
<p>对于这个记事本应该具有的接口：考虑的是我们的业务逻辑（作为这个业务逻辑来说它应该具备怎么样的接口）。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107203621885.png" alt="image-20250107203621885"></p>
<p>以add()为例，他应该是拿到了一个字符串，然后把这个字符串作为这一条记事的东西把它记进去了。至于说这个字符串是怎么得到的，我们不需要在现在来关心，因为将来使用我们这个记事本的时候，这个字符串可能是通过很多不同的途径去得到的。</p>
<p>eg：对于命令行程序：可能是scanner通过nextln去得到的；对于图形界面程序，很可能是我们有一个对话框，输入完了后按一个ok按钮，对话框里面的这个字符串就被传递给我们的表达业务逻辑的notebook里了；甚至有可能前端是一个网页，在网页里有一个提交按钮，按一下传到服务器那里，接受完以后再交给notebook。所以在此刻不要去考虑它是怎么来的。</p>
<p>🍎记事本接口设计</p>
<p>一个好习惯：每一个类里都给它做一个main，这样我们可以方便去做调试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先来定义接口</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeNote</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//boolean表示到底有没有把它删成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] list() &#123;<span class="comment">//把所有的note列出来的东西。这里有两种设计：1.不返回值，直接在这里System.out输出。2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎返回数据方式选择</p>
<p>关于接口list()，这里有两种设计：</p>
<p>1.不返回值，直接在这里System.out输出。</p>
<p>2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</p>
<p>这里第二种实现更好一些：把数据作为String[]返回回去，而不要直接去做System.out的输出</p>
<h4 id="3-1-2-泛型容器类"><a href="#3-1-2-泛型容器类" class="headerlink" title="3.1.2 泛型容器类"></a>3.1.2 泛型容器类</h4><p>🍎泛型容器类</p>
<p>在3.1.1中，我们有了这一系列的接口，接下去我们还不知道该怎么办呢。</p>
<p>每次add进来一条String我怎么把它存起来？要存放很多东西，我们在入门课程中学到一个叫做数组的。但是用在这数组也是不行的，因为有一个需求是：不断的add不能满了，只要计算机还有空间就要不断的放下去——这就是我们今天要学习的东西，要用容器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">//现在引入了一个类，这个类属于java.util这个包，这个包里这个类的名字叫做ArrayList。所以这个类的名字就是ArrayList。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//容器需要:有一个成员变量，名字叫做notes。它的类型叫什么呢？ArrayList</span></span><br><span class="line">	<span class="comment">// 上面的ArrayList&lt;String&gt;：ArrayList of String，用来存放String的一个ArrayList————泛型类，是一种容器。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先来定义接</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeNote</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//boolean表示到底有没有把它删成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] list() &#123;<span class="comment">//把所有的note列出来的东西。这里有两种设计：1.不返回值，直接在这里System.out输出。2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🍎容器类的定义和特点</p>
<p>这里容器需要:有一个成员变量，名字叫做notes。它的类型叫什么呢？ArrayList</p>
<p>可以这样来证明：第3行引入了一个类，这个类属于java.util这个包，这个包里这个类的名字叫做ArrayList。所以这个类的名字就是ArrayList。</p>
<p>而ArrayList<String>：ArrayList of String，用来存放String的一个ArrayList————泛型类，是一种容器。</p>
<p>note本身是一个对象的管理者，所以要用new的方式把ArrayList<String>做出来。</p>
<p>🍎容器类的使用和操作</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107210432255.png" alt="image-20250107210432255"></p>
<p>容器类就是这样一种东西：它用来存放对象，在里头可以存放任意数量的对象。</p>
<p>而容器类的变量在定义的时候，需要给它两个类型：第一个，ArrayList——容器类型（我们还有其他类型的容器）；第二个，尖括号里的String——元素的类型（将来要在这个容器里放什么东西）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">//现在引入了一个类，这个类属于java.util这个包，这个包里这个类的名字叫做ArrayList。所以这个类的名字就是ArrayList。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//容器需要:有一个成员变量，名字叫做notes。它的类型叫什么呢？ArrayList</span></span><br><span class="line">	<span class="comment">// 上面的ArrayList&lt;String&gt;：ArrayList of String，用来存放String的一个ArrayList————泛型类，是一种容器。</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先来定义接</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		notes.add(s); <span class="comment">//ArrayList有一个函数叫做add，给它一个String它就add进去了。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.size(); <span class="comment">//容器本身有一个函数叫做size，它自己会知道它里头放了多少东西进去。所以定义成员变量size，然后add的时候size++，这里再return size是一个蠢办法。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeNote</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//boolean表示到底有没有把它删成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] list() &#123;<span class="comment">//把所有的note列出来的东西。这里有两种设计：1.不返回值，直接在这里System.out输出。2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试里面有多少东西</span></span><br><span class="line">		<span class="type">Notebook</span> <span class="variable">nb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notebook</span>();</span><br><span class="line">		nb.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">		System.out.println(nb.getSize());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p>如果给add不合法的对象，eg：notes.add(10);</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107210910391.png" alt="image-20250107210910391"></p>
<p>ArrayList<String> 只接受String，不接受int。</p>
</blockquote>
<p>🍎容器类与数组的比较</p>
<p>🍎容器类的内部实现和属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="string">&quot;first&quot;</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">    </span><br><span class="line">		<span class="type">Notebook</span> <span class="variable">nb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notebook</span>();</span><br><span class="line">		nb.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">		System.out.println(nb.getSize());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107211723063.png" alt="image-20250107211723063"></p>
<p>nb.add(“first”); 后：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107211817718.png" alt="image-20250107211817718"></p>
<p>nb.add(“second”); 后：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107211913377.png" alt="image-20250107211913377"></p>
<h4 id="3-1-3-ArrayList的操作"><a href="#3-1-3-ArrayList的操作" class="headerlink" title="3.1.3 ArrayList的操作"></a>3.1.3 <code>ArrayList</code>的操作</h4><p>🍎<code>ArrayList</code>的操作</p>
<p><code>ArrayList</code>是系统类库中的一个类，它当中能够记录我们的元素，也能够自动的保持它已经加进去的那些元素的数量。这里的add是一个很土的add，它只是不断的往后加东西。在<code>ArrayList</code>里，数据是有顺序的，这个顺序是你加入数据进去的顺序，形成它下标的索引。</p>
<p>🍎顺序容器的顺序和索引</p>
<p>这个下标的索引与数组的下标索引类似，数组是从0开始，<code>ArrayList</code>也是从0开始。这个下标就可以为我们做 【获取其中的一个元素】。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">//现在引入了一个类，这个类属于java.util这个包，这个包里这个类的名字叫做ArrayList。所以这个类的名字就是ArrayList。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//容器需要:有一个成员变量，名字叫做notes。它的类型叫什么呢？ArrayList</span></span><br><span class="line">	<span class="comment">// 上面的ArrayList&lt;String&gt;：ArrayList of String，用来存放String的一个ArrayList————泛型类，是一种容器。</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先来定义接</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		notes.add(s); <span class="comment">//ArrayList有一个函数叫做add，给它一个String它就add进去了。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.size(); <span class="comment">//容器本身有一个函数叫做size，它自己会知道它里头放了多少东西进去。所以定义成员变量size，然后add的时候size++，这里再return size是一个蠢办法。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.get(index); <span class="comment">//返回容器里下标是index里头的东西</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeNote</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//boolean表示到底有没有把它删成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] list() &#123;<span class="comment">//把所有的note列出来的东西。这里有两种设计：1.不返回值，直接在这里System.out输出。2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//add,getSize的输出测试</span></span><br><span class="line">		String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="string">&quot;first&quot;</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">		<span class="type">Notebook</span> <span class="variable">nb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notebook</span>();</span><br><span class="line">		nb.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">		System.out.println(nb.getSize());</span><br><span class="line">		<span class="comment">//getNote的输出测试</span></span><br><span class="line">		System.out.println(nb.getNote(<span class="number">0</span>));</span><br><span class="line">		System.out.println(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//		System.out.println(nb.getNote(10)); //会报错</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p>就像数组一样，如果获取越界，会抛出异常：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107214001173-1736257201649-1.png" alt="image-20250107214001173"></p>
<p>IndexOutOfBounds下标越界</p>
</blockquote>
<p>🍎ArrayList的add方法和插入元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">//现在引入了一个类，这个类属于java.util这个包，这个包里这个类的名字叫做ArrayList。所以这个类的名字就是ArrayList。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//容器需要:有一个成员变量，名字叫做notes。它的类型叫什么呢？ArrayList</span></span><br><span class="line">	<span class="comment">// 上面的ArrayList&lt;String&gt;：ArrayList of String，用来存放String的一个ArrayList————泛型类，是一种容器。</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先来定义接</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		notes.add(s); <span class="comment">//ArrayList有一个函数叫做add，给它一个String它就add进去了。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s, <span class="type">int</span> location)</span> &#123; <span class="comment">//插入元素。第二种add，把String加到某个位置/现有元素的前面去</span></span><br><span class="line">		notes.add(location, s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.size(); <span class="comment">//容器本身有一个函数叫做size，它自己会知道它里头放了多少东西进去。所以定义成员变量size，然后add的时候size++，这里再return size是一个蠢办法。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.get(index); <span class="comment">//返回容器里下标是index里头的东西</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeNote</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//boolean表示到底有没有把它删成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] list() &#123;<span class="comment">//把所有的note列出来的东西。这里有两种设计：1.不返回值，直接在这里System.out输出。2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//add,getSize的输出测试</span></span><br><span class="line">		String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="string">&quot;first&quot;</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">		<span class="type">Notebook</span> <span class="variable">nb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notebook</span>();</span><br><span class="line">		nb.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;third&quot;</span>, <span class="number">1</span>);</span><br><span class="line">		System.out.println(nb.getSize());</span><br><span class="line">		<span class="comment">//getNote的输出测试</span></span><br><span class="line">		System.out.println(nb.getNote(<span class="number">0</span>));</span><br><span class="line">		System.out.println(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//		System.out.println(nb.getNote(10)); //会报错</span></span><br><span class="line">		<span class="comment">//add(String s, int location)输出测试 nb.add(&quot;third&quot;, 1);</span></span><br><span class="line">		System.out.println(nb.getNote(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入效果：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107214416718.png" alt="image-20250107214416718"></p>
<p>🍎ArrayList的remove方法和异常处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">//现在引入了一个类，这个类属于java.util这个包，这个包里这个类的名字叫做ArrayList。所以这个类的名字就是ArrayList。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//容器需要:有一个成员变量，名字叫做notes。它的类型叫什么呢？ArrayList</span></span><br><span class="line">	<span class="comment">// 上面的ArrayList&lt;String&gt;：ArrayList of String，用来存放String的一个ArrayList————泛型类，是一种容器。</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先来定义接</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		notes.add(s); <span class="comment">//ArrayList有一个函数叫做add，给它一个String它就add进去了。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s, <span class="type">int</span> location)</span> &#123; <span class="comment">//插入元素。第二种add，把String加到某个位置/现有元素的前面去</span></span><br><span class="line">		notes.add(location, s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.size(); <span class="comment">//容器本身有一个函数叫做size，它自己会知道它里头放了多少东西进去。所以定义成员变量size，然后add的时候size++，这里再return size是一个蠢办法。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.get(index); <span class="comment">//返回容器里下标是index里头的东西</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeNote</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//boolean表示到底有没有把它删成功</span></span><br><span class="line">		notes.remove(index); <span class="comment">//表面看上去return notes.remove(index);即可，但这不是一个需要return的东西。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] list() &#123;<span class="comment">//把所有的note列出来的东西。这里有两种设计：1.不返回值，直接在这里System.out输出。2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//add,getSize的输出测试</span></span><br><span class="line">		String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="string">&quot;first&quot;</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">		<span class="type">Notebook</span> <span class="variable">nb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notebook</span>();</span><br><span class="line">		nb.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;third&quot;</span>, <span class="number">1</span>);</span><br><span class="line">		System.out.println(nb.getSize());</span><br><span class="line">		<span class="comment">//getNote的输出测试</span></span><br><span class="line">		System.out.println(nb.getNote(<span class="number">0</span>));</span><br><span class="line">		System.out.println(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//		System.out.println(nb.getNote(10)); //会报错</span></span><br><span class="line">		<span class="comment">//add(String s, int location)输出测试 nb.add(&quot;third&quot;, 1);</span></span><br><span class="line">		System.out.println(nb.getNote(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE]</p>
<p>对于removeNote()表面看上去return notes.remove(index);即可，但这不是一个需要return的东西。因为：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107214526726.png" alt="image-20250107214526726"></p>
<p>返回的类型是String而非boolean，eg：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250107214651644.png" alt="image-20250107214651644"></p>
<p>remove会把指定位置上的东西给删掉，它会返回在这个list里return出来的东西。（刚刚删掉的东西会返回回来）</p>
<p>但如果给的int index是越界的话，会抛出异常的。</p>
</blockquote>
<p>🍎使用ArrayList的toArray方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList; <span class="comment">//现在引入了一个类，这个类属于java.util这个包，这个包里这个类的名字叫做ArrayList。所以这个类的名字就是ArrayList。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; notes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//容器需要:有一个成员变量，名字叫做notes。它的类型叫什么呢？ArrayList</span></span><br><span class="line">	<span class="comment">// 上面的ArrayList&lt;String&gt;：ArrayList of String，用来存放String的一个ArrayList————泛型类，是一种容器。</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 先来定义接</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		notes.add(s); <span class="comment">//ArrayList有一个函数叫做add，给它一个String它就add进去了。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s, <span class="type">int</span> location)</span> &#123; <span class="comment">//插入元素。第二种add，把String加到某个位置/现有元素的前面去</span></span><br><span class="line">		notes.add(location, s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.size(); <span class="comment">//容器本身有一个函数叫做size，它自己会知道它里头放了多少东西进去。所以定义成员变量size，然后add的时候size++，这里再return size是一个蠢办法。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getNote</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> notes.get(index); <span class="comment">//返回容器里下标是index里头的东西</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNote</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">//boolean表示到底有没有把它删成功</span></span><br><span class="line">		notes.remove(index); <span class="comment">//表面看上去return notes.remove(index);即可，但这不是一个需要return的东西。</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] list() &#123;<span class="comment">//把所有的note列出来的东西。这里有两种设计：1.不返回值，直接在这里System.out输出。2.返回一个String的数组，把所有的数据放在一个String数组里返回回去。String[]怎么用让上一层程序决定，本层只关心数据本身。</span></span><br><span class="line">		String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[notes.size()]; <span class="comment">//首先要有一个String[]，notes.size会告诉我们需要多大。</span></span><br><span class="line"><span class="comment">//		for ( int i=0; i&lt;notes.size(); i++ ) &#123;</span></span><br><span class="line"><span class="comment">//			a[i] = notes.get(i);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		notes.toArray(a); <span class="comment">//可以替换调上面的for循环：把a给toArray，它会帮我们把a填起来</span></span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//add,getSize的输出测试</span></span><br><span class="line">		String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="string">&quot;first&quot;</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="string">&quot;second&quot;</span>;</span><br><span class="line">		<span class="type">Notebook</span> <span class="variable">nb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Notebook</span>();</span><br><span class="line">		nb.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">		nb.add(<span class="string">&quot;third&quot;</span>, <span class="number">1</span>);</span><br><span class="line">		System.out.println(nb.getSize());</span><br><span class="line">		<span class="comment">//getNote的输出测试</span></span><br><span class="line">		System.out.println(nb.getNote(<span class="number">0</span>));</span><br><span class="line">		System.out.println(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//		System.out.println(nb.getNote(10)); //会报错</span></span><br><span class="line">		<span class="comment">//add(String s, int location)输出测试 nb.add(&quot;third&quot;, 1);</span></span><br><span class="line">		System.out.println(nb.getNote(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">//removeNote()测试</span></span><br><span class="line">		nb.removeNote(<span class="number">1</span>);</span><br><span class="line">		String[] aa = nb.list();</span><br><span class="line">		<span class="keyword">for</span> ( String s : aa) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><em>所以在用这些系统类库的类的时候，你是不是充分的理解这个系统类库的类？你是不是知道它里面有这样那样的函数来帮你做各种各样的事情？</em></strong></p>
<p>这很重要。eg：你不知道这个toArray，你自己写个循环——这又费事又可能出错。</p>
<p>你知道toArray用就好了，他做的一定比你效率更高，一定比你性能更好。</p>
<blockquote>
<p>[!NOTE]</p>
<p>究竟把什么放进容器里去了？<br>当我们用add函数把对象放进容器中去的时候，究竟是把什么放进了容器？放进去的是对象本身吗？放进去以后，那个对象还在外面吗？如果修改了放进去的那个对象，容器中的对象会变化吗？写点代码来验证自己的猜测吧。</p>
<p>对象的管理者（别的类的对象，跟这个Notebook无关所以不会影响NoteBook的类）</p>
</blockquote>
<h3 id="3-2-对象数组"><a href="#3-2-对象数组" class="headerlink" title="3.2 对象数组"></a>3.2 对象数组</h3><blockquote>
<p>[!NOTE]</p>
<p>当数组的元素的类型是类的时候，数组的每一个元素其实只是对象的管理者而不是对象本身。因此，仅仅创建数组并没有创建其中的每一个对象！</p>
</blockquote>
<h4 id="3-2-1-对象数组"><a href="#3-2-1-对象数组" class="headerlink" title="3.2.1 对象数组"></a>3.2.1 对象数组</h4><p>🍎对象数组的概念</p>
<p>在3.1的list()中，有这样一行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[notes.size()];</span><br><span class="line"><span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>String的数组a，这个数组到底是什么？我们知道如果我们有一个int的数组，我们很明确在这个数组里头放的是int，那么在这个String的数组a里头，到底放的是什么东西呢？</p>
<p>我们可以先有一个简单的程序来测试一下啊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">	<span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	System.out.println(ia[<span class="number">0</span>]);</span><br><span class="line">	System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121231505195.png" alt="image-20250121231505195"></p>
<p>没有报错，但是给了我们一个null。这个符号它的意思是说：现在呢这个东西其实还不存在。eg，如果这是一个整数，我们让它+2我们应该会得到0+2的那个值；如果这个字符串是存在的，那么我让它和一个a连接一下，它应该给我看到和a连接的结果：</p>
<p>🍎数组元素的类型和内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">	<span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	System.out.println(ia[<span class="number">0</span>]+<span class="number">2</span>);</span><br><span class="line">	System.out.println(a[<span class="number">0</span>]+<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121231811772.png" alt="image-20250121231811772"></p>
<p>换句话说，我现在啥都没有，难道这个a里面现在是个null的东西？如果是这样子的话我们再来试这个事情：我们知道这是一个stream嘛，我们可以得到它的length，null好像长度是4是吧，是不是这样子呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">	<span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	System.out.println(ia[<span class="number">0</span>]+<span class="number">2</span>);</span><br><span class="line">	System.out.println(a[<span class="number">0</span>].length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121232139450.png" alt="image-20250121232139450"></p>
<p>异常就来了，这是一个NullPointerException，啥意思？我们做一个类似的事情可以得到类似的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">	<span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">	System.out.println(ia[<span class="number">0</span>]+<span class="number">2</span>);</span><br><span class="line"><span class="comment">//	System.out.println(a[0].length());</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们打下null，它会变成紫色的，表明这是java的一个关键字。然后如果我们去输出s的length()，我们一样得到NullPointerException，什么意思？意思就是，当我们做了一个String的数组出来以后，在这个String数组里的每一个元素到底是什么东西呢？</p>
<p>🍎对象数组中元素的含义</p>
<p>我们可以不妨这么看：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121233224837.png" alt="image-20250121233224837"></p>
<p>int i 的变量里头会放整数本身；而String  s ，我们在基础课程中学过，变量s里头并不会真的去放任何字符串，它是一个管理者，它会管理着外面在某处的比如说“Hello”那个字符串</p>
<p>现在我们在int的基础上再加一个方括号，标明说我们要拿很多个这样的 i 这个样子东西把它们垒起来，作为一个数组。当然里面每一个放的都是一个整数。</p>
<p>而如果我们现在说我们有一个String类型的数组，一样啊，int的数组是把原来放int的那些变量垒起来，那么String类型的数组就是把原来那些String类型的变量垒起来。这些每一个里面放到是什么呢？每一个不是放的字符串，每一个都是指向别的字符串的管理者而已。</p>
<p>🍎对象数组中元素的管理者</p>
<p>于是问题就来了，现在当我们在这说<code>String[] a = new String[10];</code>的时候，我们做了什么？我们做了十个格子，每个格子里面都是String类的管理者。它们管谁了？没有管任何人，所以叫做<code>null</code>。null是什么意思？没有，没东西。</p>
<p>因此，这么给它赋值？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">	<span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	String[] a = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</span><br><span class="line">		a[i] = <span class="string">&quot;&quot;</span>+i;</span><br><span class="line">    &#125;</span><br><span class="line">	System.out.println(ia[<span class="number">0</span>]+<span class="number">2</span>);</span><br><span class="line">	System.out.println(a[<span class="number">0</span>].length());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就有了，是1，因为a[0]里头放的就是0那个字符串。</p>
<p>也就是说非常核心的一个观点：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250121233809920.png" alt="image-20250121233809920"></p>
<p>🍎对象数组与基础类型数组的区别</p>
<p>在对象数组里面（如果这个数组的基础&#x2F;元素类型是类的话），每一个单元并不是那个类的对象，而是那个类的一个对象的管理者。</p>
<p>换句话说，当年创建了一个数组之后，那些对象还没有呢，你还要想办法再去把每一个对象创建出来，然后那里头的东西才有用。</p>
<p>这是<code>对象数组</code>和普通的，我们叫做<code>基础类型</code>的数组是不一样的。</p>
<h4 id="3-2-2-对象数组的for-each循环"><a href="#3-2-2-对象数组的for-each循环" class="headerlink" title="3.2.2 对象数组的for-each循环"></a>3.2.2 对象数组的for-each循环</h4><p>🍎对象数组的for-each循环</p>
<p>我们知道，在数组上面呢，我们可以用for-each循环，你看，是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">    <span class="type">int</span>[] ia = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;ia.length; i++) &#123;</span><br><span class="line">		ia[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//for-each循环</span></span><br><span class="line">	<span class="keyword">for</span> ( <span class="type">int</span> k : ia ) &#123; </span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🍎对象数组的for-each循环的限制</p>
<p>然后我们在入门课程中讲到for-each循环的时候我们曾经提到过说：假如你做了这样一个for-each循环，你试图在这个for-each循环里面做k++：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> k : ia ) &#123; </span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>它是不会起到任何作用的。这是因为在循环的每一轮拿出来的每一个k是对这个元素的复制品。</p>
<p>可是现在，对于对象数组来说，情况会有所不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">this</span>.i = i; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> (<span class="keyword">return</span> i;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         Value[] a = <span class="keyword">new</span> <span class="title class_">Value</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;a.length; i++ ) &#123; <span class="comment">//初始化</span></span><br><span class="line">			a[i] = <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">			a[i].set(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ( Value v : a ) &#123;</span><br><span class="line">			System.out.println(v.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会得到0~9</p>
<p>🍎对象数组的for-each循环的特点</p>
<p>任何我们想，我们在输出之后去设v的值为0，做完这个之后，我们再来对数组进行一次遍历（for-each循环）这时候输出的是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">this</span>.i = i; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> (<span class="keyword">return</span> i;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         Value[] a = <span class="keyword">new</span> <span class="title class_">Value</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;a.length; i++ ) &#123; <span class="comment">//初始化</span></span><br><span class="line">			a[i] = <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">			a[i].set(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ( Value v : a ) &#123;</span><br><span class="line">			System.out.println(v.get());</span><br><span class="line">             v.set(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span> ( Value v : a ) &#123;</span><br><span class="line">			System.out.println(v.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二遍 输出为0了，为什么会这样？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250122114654946.png" alt="image-20250122114654946"></p>
<p>在数组a里头，每一个单元，其实都指向了外面的v（它里面有1234……）。然后我们做了一个for-each循环，for-each循环的意思是说，循环的每一轮，我的v就等于对应的a：eg 第一轮v&#x3D;a[0] ——这对于对象变量来说是什么意思呢？v这个变量它指向了a[0]所指向的对象，跟它共同管理。</p>
<p>而v.set(0) 会让v指向的对象变为0。随着for-each循环的进行，所有指向的值都变成0。</p>
<p>所以for-each循环对于对象数组是不一样的，因为每一轮循环它可以拿到那个数组元素所管理的那个对象，然后对那个对象就可以做操作了。</p>
<p>🍎容器类的for-each循环</p>
<p>那么for-each循环对于对象数组是这样的，那么它对于那个容器呢？比如<code>Arraylist&lt;String&gt;</code>，它能不能行像for-each循环一样的来使用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">		ArrayList&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">		a.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">		a.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> ( String s : a ) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以对于容器类来说，for-each循环也是可以用的。</p>
<blockquote>
<p><strong>如何设计能传递任意数量参数的函数？</strong><br>Q：另外，除了用对象数组之外，也可以搜搜看Java是否本身就支持任意数量参数的函数。</p>
<p>A：传递不定长参数的方式func(Object…args);</p>
</blockquote>
<h3 id="3-3-集合容器（Set）"><a href="#3-3-集合容器（Set）" class="headerlink" title="3.3 集合容器（Set）"></a>3.3 集合容器（Set）</h3><blockquote>
<p>[!NOTE]</p>
<p>集合就是数学中的集合的概念：所有的元素都具有唯一的值，元素在其中没有顺序。</p>
</blockquote>
<p>🍎集合容器（Set）</p>
<p>Array list是一种典型的容器，我们知道在这种容器里头呢，你可以不断的加东西进去。</p>
<p>🍎<code>HashSet</code>的特点</p>
<p>你加进去它就会有它加进去的时候的那个顺序，越后面家的就会在越后面。如果你插到某个地方去，那么你插到哪个位置上，它就在哪个位置上。这是<code>ArrayList</code>，我们并不是只有<code>ArrayList</code>一种容器，我们还有另外一些有趣的容器，比如说：set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">	ArrayList&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	a.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	a.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">	a.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> ( String s : a ) &#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">	HashSet&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">	s.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	s.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">	s.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> ( String k : s ) &#123;</span><br><span class="line">		System.out.println(k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250122163211822.png" alt="image-20250122163211822"></p>
<p>对于HashSet来说，我们放了3个东西进去，但最后只得到了两个东西。为什么？</p>
<p>因为这个set就是数学当中的<code>set</code>——<code>集合</code>。集合的一个核心概念就是：其中是没有重复的元素的。我们放了两次first进去，对这个集合来说，只有最后那一次。</p>
<p>🍎使用system.out.println输出容器内容</p>
<p>还有一件事情，我们其实不需要这么复杂的写一个循环来看这个set里的内容的。对于上一段程序，我们可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main &#123;</span><br><span class="line">	ArrayList&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	a.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	a.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">	a.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	System.out.println(a);</span><br><span class="line">	System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">	HashSet&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">	s.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	s.add(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">	s.add(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250122163619449.png" alt="image-20250122163619449"></p>
<p>这两个容器都可以直接输出，输出的结果里面带着方括号，表示说这是一个容器，然后把这个容器里面的值展示给你看。</p>
<p>事实上从这里我们还能看到set这个集合它的另外一个特点是：它里面的东西不排序，你丢进去它就随随便便了，跟你先丢后丢什么时候加进去没有任何关系。因为数学当中的集合也是没有排序这种概念的。</p>
<p>🍎重写toString方法</p>
<p>这里头也许你会有一个疑问就是，为什么我能够System.out.println直接去输出呢？事实上你刚刚还记不记得这件事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">this</span>.i = i; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> (<span class="keyword">return</span> i;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Value</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">         v.set(<span class="number">10</span>);</span><br><span class="line">         System.out.println(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们做了一个Value的对象v，我们想要输出这个v，在这里（13行）直接去输出v是不行的，他会给我们说出一些奇怪的东西：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250122170034374.png" alt="image-20250122170034374"></p>
<p>没有任何意义，可我们现在可以这样做一个toString的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> notebook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">this</span>.i = i; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> (<span class="keyword">return</span> i;)</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>+i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notebook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Value</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Value</span>();</span><br><span class="line">         v.set(<span class="number">10</span>);</span><br><span class="line">         System.out.println(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他都不用改，结果就是10：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250122170245310.png" alt="image-20250122170245310"></p>
<p>toString这件事情就是，任何一个Java的类，你只要去实现了这么一个public String toString() （只要长成这个样子，必须一模一样），有了怎么一个函数以后，你就可以让println去直接帮你输出这个对象。他会主动的去调用我们的这个toString函数，用toString函数产生的String来把它输出。</p>
<p>所以你可以想见，我们的ArrayList也好，我们的HashSet也好，都实现了toString函数，因此我们才能够在下面调用toString来输出这两个容器的内容。</p>
<blockquote>
<h3 id="集合能用get-函数来获得某个位置上的元素吗？"><a href="#集合能用get-函数来获得某个位置上的元素吗？" class="headerlink" title="集合能用get()函数来获得某个位置上的元素吗？"></a>集合能用get()函数来获得某个位置上的元素吗？</h3><p>Q：如果不能，说说你的理由。不要说试过了，就是不能的。要说说你认为为什么集合不能做这个操作。</p>
<p>A：不能通过Index来获取容器里的值，因为是无序的，但是在内存中是什么存放形式，如何实现这种无序，目前还不知道</p>
</blockquote>
<h3 id="3-4散列表（Hash）"><a href="#3-4散列表（Hash）" class="headerlink" title="3.4散列表（Hash）"></a>3.4散列表（Hash）</h3><blockquote>
<p>[!NOTE]</p>
<p>传统意义上的Hash表，是能以int做值，将数据存放起来的数据结构。Java的Hash表可以以任何实现了hash()函数的类的对象做值来存放对象。</p>
<p>Hash表是非常有用的数据结构，熟悉它，充分使用它，往往能起到事半功倍的效果。</p>
</blockquote>
<p>🍎搜索需求</p>
<p>我们有的时候还可能会遇到这样的一种搜索的需求，eg美元中硬币是有对应的名字的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250122172518283.png" alt="image-20250122172518283"></p>
<p>有一个数字，对应一个英文单词，如果我们要写一个程序来做搜索 ，那这样一个查找硬币名称的程序该怎么做？</p>
<p>老规矩，先定义接口，再考虑实现技术。</p>
<p>如果我们有一个Coin类，它需要有什么样的接口给人家？getName()</p>
<p>🍎接口定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> coins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (amount) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">return</span> <span class="string">&quot;dime&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而这个接口该如何实现太难看啦。当然，能实现对吧。但这不够优雅，我们希望gracefully。</p>
<p>怎么能够让它做的优雅一些呢？我们希望体现在代码当中，硬编码的东西越少越好。</p>
<p>本来不过是些数据嘛，一些数字对应一些字符串，这是数据。我们能不能实现一些比较聪明的代码？这些代码和具体的数据是无关的。我今天有这样的一些数据，我明天换成别的呢？</p>
<p>不要硬编码。</p>
<p>数组行不行？也不是很漂亮对吧？</p>
<p>我们需要引入新的数据结构。</p>
<blockquote>
<p><strong>为什么key的类型不能是int呢？</strong></p>
<p>这是一个面向对象的世界，在这些容器（Hash表也是一种容器）里面所有的类型都必须是对象，而不能是基本的元素。int不行，Integer可以，String可以。我们在入门课程中提过，Integer是int的包裹类型，是int对应的那个类型。</p>
</blockquote>
<p>🍎Hash表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> coins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Integer, String&gt; coinnames = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">	<span class="comment">// 这是一个hash表，是一种数据结构，这里面所有的东西是以一对值放进去的，一个叫做key就是它的键，一个叫做value就是它的值。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造器。用来初始化数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Coin</span><span class="params">()</span> &#123;</span><br><span class="line">		coinnames.put(<span class="number">1</span>, <span class="string">&quot;penny&quot;</span>);</span><br><span class="line">		<span class="comment">// 1不必带有引号&quot;&quot;，因为一个包裹类型的变量可以直接接收它所对应的基础类型的变量。</span></span><br><span class="line">		coinnames.put(<span class="number">10</span>, <span class="string">&quot;dime&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">25</span>, <span class="string">&quot;quarter&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">50</span>, <span class="string">&quot;half-dolar&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line"><span class="comment">//		switch (amount) &#123;</span></span><br><span class="line"><span class="comment">//		case 10: return &quot;dime&quot;;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">return</span> coinnames.get(amount);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">		<span class="type">Coin</span> <span class="variable">coin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coin</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> coin.getName(amount);</span><br><span class="line">		System.out.println(name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎Hash表的特性</p>
<p>我们需要查找的时候知道它在不在里面，这样我们就需要用到它的一些其他东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> coins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Integer, String&gt; coinnames = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">	<span class="comment">// 这是一个hash表，是一种数据结构，这里面所有的东西是以一对值放进去的，一个叫做key就是它的键，一个叫做value就是它的值。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造器。用来初始化数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Coin</span><span class="params">()</span> &#123;</span><br><span class="line">		coinnames.put(<span class="number">1</span>, <span class="string">&quot;penny&quot;</span>);</span><br><span class="line">		<span class="comment">// 1不必带有引号&quot;&quot;，因为一个包裹类型的变量可以直接接收它所对应的基础类型的变量。</span></span><br><span class="line">		coinnames.put(<span class="number">10</span>, <span class="string">&quot;dime&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">25</span>, <span class="string">&quot;quarter&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">50</span>, <span class="string">&quot;half-dolar&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">50</span>, <span class="string">&quot;五毛&quot;</span>);</span><br><span class="line">		System.out.println(coinnames.keySet().size()); <span class="comment">//结果会是4</span></span><br><span class="line">		System.out.println(coinnames); <span class="comment">//我们前面的容器都是可以直接输出的，这个也是一样。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line"><span class="comment">//		switch (amount) &#123;</span></span><br><span class="line"><span class="comment">//		case 10: return &quot;dime&quot;;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">if</span> ( coinnames.containsKey(amount) ) &#123;</span><br><span class="line">			<span class="keyword">return</span> coinnames.get(amount);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;NOT FOUND&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">		<span class="type">Coin</span> <span class="variable">coin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coin</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> coin.getName(amount);</span><br><span class="line">		System.out.println(name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250122181209864.png" alt="image-20250122181209864"></p>
<p>确实只有4个，原来的哪个50&#x3D;half-dolar没了。因为对于hash表来说，键一定是唯一的。只要是同一个键放进了很多次，不管它的值相不相同，那么留下了的只有最后一次。这是hash表的一个很重要的特性。</p>
<p>还有就是像上面所演示的，hash表也有toString，它可以被输出。</p>
<p>🍎遍历Hash表</p>
<p>可我不是想要toString这么简单，我就想遍历整个hash表里面所有的键和值，该怎么做呢？</p>
<p>没有非常简单的方法，不行ArrayList或者HashSet我直接一个for-each循环就可以遍历的，对于一个hash表来说，要遍历你需要这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> coins;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Integer, String&gt; coinnames = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">	<span class="comment">// 这是一个hash表，是一种数据结构，这里面所有的东西是以一对值放进去的，一个叫做key就是它的键，一个叫做value就是它的值。</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 构造器。用来初始化数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Coin</span><span class="params">()</span> &#123;</span><br><span class="line">		coinnames.put(<span class="number">1</span>, <span class="string">&quot;penny&quot;</span>);</span><br><span class="line">		<span class="comment">// 1不必带有引号&quot;&quot;，因为一个包裹类型的变量可以直接接收它所对应的基础类型的变量。</span></span><br><span class="line">		coinnames.put(<span class="number">10</span>, <span class="string">&quot;dime&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">25</span>, <span class="string">&quot;quarter&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">50</span>, <span class="string">&quot;half-dolar&quot;</span>);</span><br><span class="line">		coinnames.put(<span class="number">50</span>, <span class="string">&quot;五毛&quot;</span>);</span><br><span class="line">		System.out.println(coinnames.keySet().size()); <span class="comment">//结果会是4</span></span><br><span class="line">		System.out.println(coinnames); <span class="comment">//我们前面的容器都是可以直接输出的，这个也是一样。</span></span><br><span class="line">		<span class="comment">// 遍历hash表</span></span><br><span class="line">		<span class="keyword">for</span> ( Integer k : coinnames.keySet() ) &#123; <span class="comment">//让它自己列出所有的key，然后我遍历所有的key</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> coinnames.get(k); <span class="comment">//把每一个key让hash表拿出它的value</span></span><br><span class="line">			System.out.println(s);	<span class="comment">//输出</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">(<span class="type">int</span> amount)</span> &#123;</span><br><span class="line"><span class="comment">//		switch (amount) &#123;</span></span><br><span class="line"><span class="comment">//		case 10: return &quot;dime&quot;;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">if</span> ( coinnames.containsKey(amount) ) &#123;</span><br><span class="line">			<span class="keyword">return</span> coinnames.get(amount);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;NOT FOUND&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">amount</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">		<span class="type">Coin</span> <span class="variable">coin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Coin</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> coin.getName(amount);</span><br><span class="line">		System.out.println(name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>学生成绩的数据结构</strong><br>Q：如果要写程序表达一个班级的很多个学生的很多门课的成绩，应该如何表达这些数据？</p>
<p>如果我们希望通过学生的姓名，可以找到他的所有的成绩，而每一门课的成绩，是由课程名称和分数构成的。</p>
<p>而如果我们还希望这个程序能找出某一门课的全部学生的成绩应该怎样做呢？</p>
<p>注意，并非所有的学生都参加了所有的课程。</p>
<p>A：用HashMap表示学生成绩：1. 班级数据结构： 使用一个<code>HashMap</code>表示整个班级的学生成绩，其中键是学生姓名，值是该学生的成绩数据结构（如下所述）。2. 学生成绩数据结构： 对于每个学生，使用另一个<code>HashMap</code>来表示他们的成绩。在这个内部的<code>HashMap</code>中，键是课程名称，而值是该学生在该课程中的分数。这样，通过学生的姓名可以直接获取到该学生的成绩信息，而通过学生的成绩信息也可以轻松地找到某一门课的全部学生成绩。这种嵌套的<code>HashMap</code>结构提供了灵活性，因为每个学生可能参与不同的课程，而且可以轻松地扩展和添加新的信息。</p>
</blockquote>
<h2 id="第4周继承与多态"><a href="#第4周继承与多态" class="headerlink" title="第4周	继承与多态"></a>第4周	继承与多态</h2><h3 id="4-1-继承"><a href="#4-1-继承" class="headerlink" title="4.1 继承"></a>4.1 继承</h3><blockquote>
<p>[!NOTE]</p>
<p><strong>继承-1</strong></p>
<p>面向对象程序设计语言有三大特性：封装、继承和多态性。继承是面向对象语言的重要特征之一，没有继承的语言只能被称作“使用对象的语言”。继承是非常简单而强大的设计思想，它提供了我们代码重用和程序组织的有力工具。</p>
<p>类是规则，用来制造对象的规则。我们不断地定义类，用定义的类制造一些对象。类定义了对象的属性和行为，就像图纸决定了房子要盖成什么样子。</p>
<p>一张图纸可以盖很多房子，它们都是相同的房子，但是坐落在不同的地方，会有不同的人住在里面。假如现在我们想盖一座新房子，和以前盖的房子很相似，但是稍微有点不同。任何一个建筑师都会拿以前盖的房子的图纸来，稍加修改，成为一张新图纸，然后盖这座新房子。所以一旦我们有了一张设计良好的图纸，我们就可以基于这张图纸设计出很多相似但不完全相同的房子的图纸来。</p>
<p>基于已有的设计创造新的设计，就是面向对象程序设计中的继承。在继承中，新的类不是凭空产生的，而是基于一个已经存在的类而定义出来的。通过继承，新的类自动获得了基础类中所有的成员，包括成员变量和方法，包括各种访问属性的成员，无论是public还是private。当然，在这之后，程序员还可以加入自己的新的成员，包括变量和方法。显然，通过继承来定义新的类，远比从头开始写一个新的类要简单快捷和方便。继承是支持代码重用的重要手段之一。</p>
<p>类这个词有分类的意思，具有相似特性的东西可以归为一类。比如所有的鸟都有一些共同的特性：有翅膀、下蛋等等。鸟的一个子类，比如鸡，具有鸟的所有的特性，同时又有它自己的特性，比如飞不太高等等；而另外一种鸟类，比如鸵鸟，同样也具有鸟类的全部特性，但是又有它自己的明显不同于鸡的特性。</p>
<p>如果我们用程序设计的语言来描述这个鸡和鸵鸟的关系问题，首先有一个类叫做“鸟”，它具有一些成员变量和方法，从而阐述了鸟所应该具有的特征和行为。然后一个“鸡”类可以从这个“鸟”类派生出来，它同样也具有“鸟”类所有的成员变量和方法，然后再加上自己特有的成员变量和方法。无论是从“鸟”那里继承来的变量和方法，还是它自己加上的，都是它的变量和方法。</p>
<p>本周的学习，建议按照视频中的操作，自己把媒体资料库从头到尾实现一遍，重点在于弄清楚子类和父类的关系，理解子类从父类继承得到了什么。</p>
</blockquote>
<h4 id="4-1-1-媒体资料库的设计"><a href="#4-1-1-媒体资料库的设计" class="headerlink" title="4.1.1 媒体资料库的设计"></a>4.1.1 媒体资料库的设计</h4><p>🍎容器的设计</p>
<p>在前面容器的地方，我们做了一个记事本。记事本比较简单，它只能记一段东西也就是一段文字。那么今天我们想做一个资料库，让这个资料库能够帮助我们保存一些CD的资料。基本跟记事本很像：需要一个容器（对于记事本来说放的是字符串，对于CD来说，就要自己设计一个类，用这个类来表达CD，把这个类放在容器里面）。对于一个CD来说需要有这样一些东西：类的示意图：</p>
<table>
<thead>
<tr>
<th align="center">class：CD</th>
</tr>
</thead>
<tbody><tr>
<td align="center">title（标题）、artist（艺术家）、#tracks（有多少首歌）、playing time、got it（标志，是否被借出去了）、comment（描述性的文字）</td>
</tr>
</tbody></table>
<p>还应该有一个资料库的类，这个类中有一个容器用来放CD。</p>
<p>🍎类的设计与构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库/资料库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Database</span> &#123; </span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;CD&gt; listCD = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CD&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(CD cd)</span> &#123; 	<span class="comment">//add函数</span></span><br><span class="line">		listCD.add(cd); <span class="comment">//把给的cd add进去</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;<span class="comment">//列出所有的CD</span></span><br><span class="line">		<span class="keyword">for</span> ( CD cd : listCD ) &#123;</span><br><span class="line">			cd.print(); <span class="comment">//我们并不太在乎你要怎么输出、你要把哪些东西输出，我只关心你是一个CD，你知道print，你就把自己给输出了吧</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Database</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Database</span>();  <span class="comment">//首先要有一个database </span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>,<span class="number">4</span>,<span class="number">60</span>, <span class="string">&quot;...&quot;</span>)); <span class="comment">//然后就可以往里面add东西了</span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;def&quot;</span>, <span class="string">&quot;def&quot;</span>,<span class="number">4</span>,<span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.list();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line"><span class="comment">//		super();</span></span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line">		System.out.println(title+<span class="string">&quot;:&quot;</span>+artist);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>[!NOTE]</p>
<p>有了这样一个CD怎么样把这些东西给它都初始化起来？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104231334985.png" alt="image-20250104231334985"></p>
<p>这是一个比较费力气的事情，我们有一个简单的方案：先把这些成员变量都做好以后，Source（重构）-Generate Constructor using Fields…（使用字段生成构造函数）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104231506858.png" alt="image-20250104231506858">’</p>
<p>把所有的字段都打上勾，然后ok。然后它就帮我们做了一个构造器&#x2F;构造函数出来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104231848597.png" alt="image-20250104231848597"></p>
<p>这个构造函数需要一些参数，然后就帮我们把所有的成员变量都初始化好了。</p>
<p>至于super是什么一会我们再来说。今天在这个地方这个super();可以没有，也可以有它。他目前来说起不到什么作用。</p>
</blockquote>
<p>🍎函数的重载与继承</p>
<p>这和我们的记事本其实没有多大区别，唯一的区别就是记事本那里头放的东西是一个字符串是一个string。这里我们放的是我们自己定义的一个类，是一个CD。接下来，我们想扩充一下这个database，我们想往里面放一种叫做DVD的：（CD是一种听音乐的，DVD是另外一种看电影的——我们要有另外的一个类，然后我们把DVD的也放进资料库里面去，让这个资料库也能管理整个DVD。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库/资料库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Database</span> &#123; </span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;CD&gt; listCD = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;CD&gt;();</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;DVD&gt; listDVD = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;DVD&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(CD cd)</span> &#123; 	<span class="comment">//add函数</span></span><br><span class="line">		listCD.add(cd); <span class="comment">//把给的cd add进去</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(DVD dvd)</span> &#123;  <span class="comment">//这叫做函数的重载——我有两个函数它们的名称是一样的，但是它们的参数表是不一样的。</span></span><br><span class="line">		listDVD.add(dvd);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;<span class="comment">//列出所有的CD</span></span><br><span class="line">		<span class="keyword">for</span> ( CD cd : listCD ) &#123;</span><br><span class="line">			cd.print(); <span class="comment">//我们并不太在乎你要怎么输出、你要把哪些东西输出，我只关心你是一个CD，你知道print，你就把自己给输出了吧</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ( DVD dvd : listDVD) &#123;</span><br><span class="line">			dvd.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Database</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Database</span>();  <span class="comment">//首先要有一个database </span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>)); <span class="comment">//然后就可以往里面add东西了</span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;def&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;AAA&quot;</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.list();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line"><span class="comment">//		super();</span></span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line">		System.out.println(<span class="string">&quot;CD:&quot;</span>+title+<span class="string">&quot;:&quot;</span>+artist);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVD</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String director;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DVD</span><span class="params">(String title, String director, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.director = director;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;DVD:&quot;</span>+title+<span class="string">&quot;:&quot;</span>+director);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎多态的应用</p>
<p>🍎代码结构与功能实现</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250104234528453.png" alt="image-20250104234528453"></p>
<p>现在的代码大概是这样的结构。这样的代码好吗？功能都是可以的，能够保存CD能够保存DVD。但是这个代码有什么问题？</p>
<h4 id="4-1-2-继承"><a href="#4-1-2-继承" class="headerlink" title="4.1.2 继承"></a>4.1.2 继承</h4><p>🍎代码复制问题</p>
<p>问题就在这，你看这是我们的CD，这是我们的DVD，如果把它们摆到一起：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109034241314.png" alt="image-20250109034241314"></p>
<p>——他们几乎一模一样：大家都有title，大家都有playingTime，大家都有gotIt，大家都有comment。这两个类非常相似，然后我们再去看Database：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109034436893.png" alt="image-20250109034436893"></p>
<p>Database有两个一模一样的ArrayList，一个是CD的一个是DVD的。我们也能看到有两个一模一样的add函数，一个是add CD的，一个是add DVD的。我们看到在list里有两端一模一样的循环，一段是关于CD的一段是关于DVD的。</p>
<p>我们可以看到有很多地方都一模一样，不一样的仅仅只是一个是CD一个是DVD，而CD和DVD本身又有很多相似的地方。</p>
<p>——我们看到在这里面出现了大量的代码复制。回想以下我们刚才把这些东西做出来的过程：我们就是拷贝黏贴的。</p>
<p>在代码中出现这样的代码复制是代码质量不良的一种表现。因为有了这样的代码复制之后，就意味着将来我们要去维护这样的代码是不容易的。eg：如果我们发现print做的不好，我们需要改一改print，那我们所有的print都要改</p>
<p>而且这样的代码不具有可扩展性。如果我们要增加一种新的类型，我们就要做一个新的类，在Database里要做新的ArrayList，要做新的add，要做新的循环……我们要做很多工作。</p>
<p>所以怎么来改进这件事情呢？</p>
<p>🍎继承与派生关系</p>
<p>我们看到在我们的代码里面CD和DVD很相似，我们能不能从这两个类里头提取一些东西，来做一个公共的东西。这个公共的东西可以表达CD或者DVD，然后我们让Database管哪个公共的东西，而不是CD和DVD。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库/资料库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Database</span> &#123; </span><br><span class="line"><span class="comment">//	private ArrayList&lt;CD&gt; listCD = new ArrayList&lt;CD&gt;();</span></span><br><span class="line"><span class="comment">//	private ArrayList&lt;DVD&gt; listDVD = new ArrayList&lt;DVD&gt;();</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Item&gt; listItem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Item&gt;();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void add(CD cd) &#123; 	</span></span><br><span class="line"><span class="comment">//		listCD.add(cd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void add(DVD dvd) &#123;  </span></span><br><span class="line"><span class="comment">//		listDVD.add(dvd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item item)</span> &#123;  </span><br><span class="line">		listItem.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;<span class="comment">//列出所有的CD</span></span><br><span class="line"><span class="comment">//		for ( CD cd : listCD ) &#123;</span></span><br><span class="line"><span class="comment">//			cd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		for ( DVD dvd : listDVD) &#123;</span></span><br><span class="line"><span class="comment">//			dvd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">for</span> ( Item item : listItem ) &#123;</span><br><span class="line">			item.print();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Database</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Database</span>();  <span class="comment">//首先要有一个database </span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>)); <span class="comment">//然后就可以往里面add东西了</span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;def&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;AAA&quot;</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.list();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123; <span class="comment">//extend；CD是一种特殊的Item</span></span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line"><span class="comment">//		super();</span></span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line">		System.out.println(<span class="string">&quot;CD:&quot;</span>+title+<span class="string">&quot;:&quot;</span>+artist);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String director;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DVD</span><span class="params">(String title, String director, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.director = director;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;DVD:&quot;</span>+title+<span class="string">&quot;:&quot;</span>+director);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到底发生什么了？我们做了一个新的类叫做Item，在这个类里面什么都没有，我们定义了一个空的print函数，然后什么都没有了。</p>
<p>CD和原来不一样的地方只要这样一个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;&#125; <span class="comment">//extend；扩展了。CD是一种特殊的Item：CD扩展了Item。加上s的原因是class CD extends Item是一个陈述句，初中英语学过，第三人称单数动词要加s。</span></span><br></pre></td></tr></table></figure>

<p>——这样之后CD就成为了Item的一个子类，这就叫做 继承 。</p>
<p>现在这四个类的关系是：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109040410624.png" alt="image-20250109040410624"></p>
<p>——Database没有直接和CD、DVD打交道，Database是管那个Item的。Database只认识Item，它里面有一个数据结构ArrayList，ArrayList里头是放Item的，它的list函数会去遍历那个Item，它的add函数会把东西往Item里面加。</p>
<p>🍎继承的作用和特点</p>
<p>接下来我们要来琢磨的事情是，我们现在说这叫继承对不对？是说CD继承自Item，DVD继承自Item。</p>
<p>CD是Item的子类后，在Database里头我们能够做一件事情：当我们要往里add东西的时候，Database的add函数说需要一个Item，可我们add给它的是一个刚刚new出来的CD，而且没有任何问题。为什么它没有问题？为什么它能够接收？</p>
<p>首先在CD里说，CD是Item的子类，可是光这么说不够，太牵强了。对于database来说，它对Item的全部的认识是什么？它对Item全部的认识是那个Item应该有一个print函数（因为for循环中使用了item.print();），因为这是唯一在这个database里用到Item的地方。</p>
<p>在database中，我们会在add函数中把一个Item add进去，但是我们并不会去用这个Item。</p>
<p>在database中使用了Item的print函数，Item中有一个空的print函数，在CD里也是有一个print函数的。所以Item的print函数和CD的print函数构成了这么一个关系是说：对于database这边要print的时候，只要你的item是有print的，我就认为你是一个Item，对于你具体是哪个print我并不关系，因为我要的就是你有那个print就可以了。</p>
<p>回过来说，加入今天我们在CD里头是没有print函数，我们把CD里的print给它注释掉以后，我们没有看到任何地方出现红叉叉了，为什么？因为Item里有print了。我们不妨让Item的print做点什么，我们好一会来跟踪这个事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们来运行这个程序，会发现原本应该输出 CD什么什么 的地方输出了两个 Item 。这发生的是什么？我们的CD从Item中得到继承了。</p>
<p>它通过extends表明继承的关系后，它得到了什么？所有Item中的东西它都得到了。包括print函数。如果CD没有自己的print函数，那么它也得到了Item的那个print函数。</p>
<p>🍎继承的语法和继承得到的内容</p>
<p>也就是说，我们在CD里做一个非常简单的new：CD cd &#x3D; new CD(“a”,”b”,2,2,”…”);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123; <span class="comment">//extend；CD是一种特殊的Item</span></span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line"><span class="comment">//		super();</span></span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">CD</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">         cd.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public void print() &#123;</span></span><br><span class="line"><span class="comment">//		// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;CD:&quot;+title+&quot;:&quot;+artist);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们让cd做print()，这个是能做的，但它做的是Item的print()。</p>
<p>——我们的父类定义了一个函数之后，在CD这个子类当中它天然就有这个函数。所以继承得到了什么？父类有什么它就得到了什么。</p>
<p>父类的所有东西在子类当中都是存在的，都是可能可以用的（之所以说可能是因为还涉及到访问权限的问题，一会我们再来仔细说这个事）。</p>
<p>作为继承，从语法上来说就是 某个类宣称自己extends另外一个类了。它就从那个父类得到继承了，这之后父类所有的东西它都有了，然后它还可以再加一些新的东西。</p>
<p>（子类从父类继承了父类的属性和方法）</p>
<p>当然，我们现在这个程序还不是完美的，我们还要做一些事情。</p>
<blockquote>
<p>[!NOTE]</p>
<p><strong>继承-2</strong></p>
<p>我们把用来做基础派生其它类的那个类叫做父类、超类或者基类，而派生出来的新类叫做子类。Java用关键字extends表示这种继承&#x2F;派生关系：</p>
<p>​	class ThisClass extends SuperClass {<br>​    		&#x2F;&#x2F;…<br>​	}</p>
<p>继承表达了一种is-a关系，就是说，子类的对象可以被看作是父类的对象。比如鸡是从鸟派生出来的，因此任何一只都可以被称作是一只鸟。但是反过来不行，有些鸟是鸡，但并不是所有的鸟都是鸡。如果你设计的继承关系，导致当你试图把一个子类的对象看作是父类的对象时显然很不合逻辑，比如你让鸡类从水果类得到继承，然后你试图说：这只本鸡是一种水果，所以这本鸡煲就像水果色拉。这显然不合逻辑，如果出现这样的问题，那就说明你的类的关系的设计是不正确的。Java的继承只允许单继承，即一个类只能有一个父类。</p>
</blockquote>
<h3 id="4-2-子类父类关系"><a href="#4-2-子类父类关系" class="headerlink" title="4.2 子类父类关系"></a>4.2 子类父类关系</h3><blockquote>
<p>[!NOTE]</p>
<p>对理解继承来说，最重要的事情是，知道哪些东西被继承了，或者说，子类从父类那里得到了什么。答案是：所有的东西，所有的父类的成员，包括变量和方法，都成为了子类的成员，除了构造方法。构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p>
<p>但是得到不等于可以随便使用。每个成员有不同的访问属性，子类继承得到了父类所有的成员，但是不同的访问属性使得子类在使用这些成员时有所不同：有些父类的成员直接成为子类的对外的界面，有些则被深深地隐藏起来，即使子类自己也不能直接访问。下表列出了不同访问属性的父类成员在子类中的访问属性：</p>
<table>
<thead>
<tr>
<th><strong>父类成员访问属性</strong></th>
<th><strong>在父类中的含义</strong></th>
<th><strong>在子类中的含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>对所有人开放</td>
<td>对所有人开放</td>
</tr>
<tr>
<td>protected</td>
<td>只有包内其它类、自己和子类可以访问</td>
<td>只有包内其它类、自己和子类可以访问</td>
</tr>
<tr>
<td>缺省</td>
<td>只有包内其它类可以访问</td>
<td>如果子类与父类在同一个包内：只有包内其它类可以访问否则：相当于private，不能访问</td>
</tr>
<tr>
<td>private</td>
<td>只有自己可以访问</td>
<td>不能访问</td>
</tr>
</tbody></table>
<p>public的成员直接成为子类的public的成员，protected的成员也直接成为子类的protected的成员。Java的protected的意思是包内和子类可访问，所以它比缺省的访问属性要宽一些。而对于父类的缺省的未定义访问属性的成员来说，他们是在父类所在的包内可见，如果子类不属于父类的包，那么在子类里面，这些缺省属性的成员和private的成员是一样的：不可见。父类的private的成员在子类里仍然是存在的，只是子类中不能直接访问。我们不可以在子类中重新定义继承得到的成员的访问属性。如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响。</p>
<p>在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用。在程序运行过程中，子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何传递参数就很重要了。</p>
</blockquote>
<h4 id="4-2-1-子类继承了什么？"><a href="#4-2-1-子类继承了什么？" class="headerlink" title="4.2.1 子类继承了什么？"></a>4.2.1 子类继承了什么？</h4><p>🍎子类继承父类的成员变量和方法</p>
<p>我们用了继承把它改造过了，从database的角度看，好像很不错。你看，现在我们的Database只有一个容器，只有一个add函数，只有list里面的一个for循环。</p>
<p>可是如果我们去看CD和DVD，我们看到：CD里面有title有playingTime有gotIt有comment，DVD里也有这些东西——还存在一些代码复制的情况。</p>
<p>我们要把所有的这些东西都消除掉，怎么做呢？相同的东西，在CD和DVD这两个子类里头，我们可以把它提取出来，放到它们的父类Item里头。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250206182855241.png" alt="image-20250206182855241"></p>
<p>剪切黏贴<code>private String title;</code>到Item中以后，对Item来说没问题，可是对CD来说<code>this.title = title;</code>会报错：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250206183215259.png" alt="image-20250206183215259"></p>
<p>这个字段Item的title is not visible。</p>
<p>这句话其实提供给我们两个有用的信息：1. Item的title。我们代码中写的是this的title，this是CD，可是呢，它已经给我们认出来是Item的title：因为CD继承自Item，Item里有title，CD没有自己的title。然后这个时候呢，他就会发现说，你说的这个title其实就你父类的title，它在CD里是存在的，但是：2.not visible。它是不可见的。</p>
<p>🍎private修饰符的访问权限</p>
<p>不可见的原因是：Item说这是private。父类中说是private的东西就真的只有父类自己才能够用，子类虽然是从你这继承得到了这个title，但是它不能直接用，因为你这是private。</p>
<p>解决这个问题两个方案：1. 把private改成另外一个修饰符 protected。protected的意思是自己可以访问，同一个包内的其他类可以访问，子类可以访问。当然这里我们的子类和父类处在同一个包里头，但是这不会永远是这个样子的。因为很多时候，父类是在别人的包里头，然后子类是在你的包里头，那个时候子类和父类就在同一个包里面了。所以protected可以让子类访问到父类标识为protected的那些成员，然后又保证和它们没关系的那些类是不能访问到这个title的。</p>
<p>🍎protected修饰符的访问权限</p>
<p>这是一个办法，还有一个办法。我们依然维持title为private。</p>
<p>其实我们现在的问题是，我们是不是真的需要在CD里面去用这个title。因为我们现在唯一在CD里面用到这个title的地方只有一个，就是<code>this.title = title;</code>在构造里头要去对这个title做赋值，可是既然title是Item的，不是应该让Item来对这个title做赋值来做初始化吗？</p>
<ol start="2">
<li>所以本来我们应该做的事情是为item做一个构造器：</li>
</ol>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/1.png" alt="1"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/2.png" alt="2"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String title)</span> &#123; <span class="comment">//我们为Item做了一个构造器，这个构造器需要一个String来对title做初始化————既然title是Item的，那么当然我们就应该由Item来对这个title做初始化，而不应该由它的子类来做。</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个构造器会去做这个title的初始化，然后在CD这里我们要做的事情是，在cd的构造器的第一句话把title传过去：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250206195925233.png" alt="image-20250206195925233"></p>
<p>这样就正常了。</p>
<p>上面：在子类里面呢，我们实际去构造CD的时候，我们得要给它一个title：我们要构造这么一个CD的对象，这个CD的对象有这么一个title在里头，所以我们CD的构造器得要拿到那个title（第10行参数表第一个参数）。完了以后它自己不去做任何对title的赋值，反正这个titlt是他的父类继承来的，</p>
<p>🍎通过super调用父类构造器</p>
<p>所以用<code>super(title);</code>的方式去调用Item的那个构造器，来把这个title传递给他。</p>
<p>调试一下程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库/资料库：依旧是4.1.2的版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Database</span> &#123; </span><br><span class="line"><span class="comment">//	private ArrayList&lt;CD&gt; listCD = new ArrayList&lt;CD&gt;();</span></span><br><span class="line"><span class="comment">//	private ArrayList&lt;DVD&gt; listDVD = new ArrayList&lt;DVD&gt;();</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Item&gt; listItem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Item&gt;();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void add(CD cd) &#123; 	</span></span><br><span class="line"><span class="comment">//		listCD.add(cd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void add(DVD dvd) &#123;  </span></span><br><span class="line"><span class="comment">//		listDVD.add(dvd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item item)</span> &#123;  </span><br><span class="line">		listItem.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;<span class="comment">//列出所有的CD</span></span><br><span class="line"><span class="comment">//		for ( CD cd : listCD ) &#123;</span></span><br><span class="line"><span class="comment">//			cd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		for ( DVD dvd : listDVD) &#123;</span></span><br><span class="line"><span class="comment">//			dvd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">for</span> ( Item item : listItem ) &#123;</span><br><span class="line">			item.print();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Database</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Database</span>();  <span class="comment">//首先要有一个database </span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>)); <span class="comment">//然后就可以往里面add东西了</span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;def&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;AAA&quot;</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.list();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"><span class="comment">// 父类Item：为子类提供了成员变量，并创建了构造器为这些成员变量初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String title)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"><span class="comment">// 子类CD：继承父类Item的成员变量title，并用super();调用父类的构造器为其初始化值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123; <span class="comment">//extend；CD是一种特殊的Item</span></span><br><span class="line"><span class="comment">//	private String title;</span></span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title);</span><br><span class="line"><span class="comment">//		this.title = title;</span></span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">CD</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">		cd.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public void print() &#123;</span></span><br><span class="line"><span class="comment">//		// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;CD:&quot;+title+&quot;:&quot;+artist);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行CD，首先是CD的第21行，构造了一个新的CD。step into跟进去后，就到了CD的构造器这（CD的第12行），下图的this就是我们要构造&#x2F;初始化的CD对象，打开看看它有什么：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207143012957.png" alt="image-20250207143012957"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207165505278.png" alt="image-20250207165505278"></p>
<p>我们很关心的就是这个title，我们看到它有title。尽管在CD的这个类自己的定义里头没有title，但是它的父类Item里是有title的。所以现在CD的对象里面确实是有title的&#x2F;这个成员它确实继承得到了，只不过它是private。</p>
<p>🍎子类构造器执行顺序</p>
<p>接下来我们跟进去看super()去哪了。到了他的父类Item的构造这边，并且它把这个title也传过来了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207165857317.png" alt="image-20250207165857317"></p>
<p>现在的这个this里头是这样一个 CD类的，里头有title的东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207165954996.png" alt="image-20250207165954996"></p>
<p>完了以后我们step over，这个super()去哪儿我们现在先不看。</p>
<p>然后我们做了一个title的赋值，所以title就是a了。</p>
<p>然后回来做了CD的定义初始化：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207170146898.png" alt="image-20250207170146898"></p>
<p>注意看我们这儿的顺序：我们CD的构造（CD第12行）进来以后，先去做了它父类的那个构造&#x2F;做了父类那部分东西的初始化（Item第7行），然后才来做自己的定义初始化（CD第4~8行），然后才进我们的构造函数去做剩下的事情（CD第14行）。</p>
<p>这是第一件事情，我们通过在CD的构造器第一行写了一个super，把title这个参数传给了Item，从而使得title在Item的构造器里初始化了<code>Item的成员变量title</code>，而这个title是将来会有其他地方去用的。</p>
<p>而DVD在报错：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207172849039.png" alt="image-20250207172849039"></p>
<p>DVD的抱怨是：刚才我们之前自动生成DVD的构造器的时候，它自动给我们加了这样一句<code>super();</code>，不带任何参数的。这句话的意思是它会调用父类的一个没有参数的构造器。可是现在我们的父类Item，它的构造器只有一个，是要参数的，所以出现问题了，因为找不到一个不要参数的构造器。</p>
<p>那么如果我们把这句话去掉行不行呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207181511682.png" alt="image-20250207181511682"></p>
<p>不行，因为如果你把它去掉了，这个错误提示告诉你说：它隐含的认为Item类是有一个不带参数的构造器的。</p>
<p>也就是说其实eclipse自动帮我们生成的这一句super是没有用的，为什么？</p>
<p>我们假如说这样子，我们为Item添加一个没有参数的构造器，它什么事也不干——这叫做重载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String title)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样DVD的抱怨就消失掉了，我们来跟一下它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"><span class="comment">// 相较于4.1.2注释掉了构造器中的super，新增了19-20行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> String director;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DVD</span><span class="params">(String title, String director, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line"><span class="comment">//		super();</span></span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.director = director;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">DVD</span> <span class="variable">dvd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">		dvd.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;DVD:&quot;</span>+title+<span class="string">&quot;:&quot;</span>+director);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行DVD，step into后我们到了DVD的构造器，再step into我们就到了Item的那个没有参数的构造器了——可我们在DVD中并没有写super那一行（第11行）。——不需要，在子类当中，如果你去构造一个子类的对象出来，在那个过程当中它会自动的先去调用父类的那个构造器。如果你没有通过super传递参数给父类的构造器，那么他会去寻找那个不带参数的构造器。</p>
<p>如果你给参数了（像CD里面），它会根据参数去父类中寻找相匹配的构造器。</p>
<p>所以我们的原则就是这样子：当我们去构造一个子类的对象的时候，它首先要确保它的父类所拥有的那些成员变量得到恰当的初始化。</p>
<p><code>恰当的初始化</code>指的是两件事情：定义初始化 和 构造器。</p>
<p>我们知道我们之前看到过，如果你又有定义初始化又有构造器，那么定义初始化会先做，然后做构造器。</p>
<p>如果你有子类有父类的时候，它一定会保证父类的那个部分的定义初始化、构造器会先做，做完之后才轮到子类自己的定义初始化和构造器——这样的一个执行顺序永远是存在的。不管你是不是主动的用super去传递参数&#x2F;去指定要调用哪一个父类的构造器，这个事情一定会做的。如果你没有super，那么他就去找那个没有参数的父类的构造器，如果有super就根据super的这个参数去寻找恰当的。</p>
<p>好，那下面我们花点时间把这个两个cd和dvd两个类所有共同东西都搬到item把事情给做完：</p>
<h4 id="4-2-2-子类和父类的关系"><a href="#4-2-2-子类和父类的关系" class="headerlink" title="4.2.2 子类和父类的关系"></a>4.2.2 子类和父类的关系</h4><p>🍎子类和父类关系</p>
<p>我们相同的东西还有playingTime和gotIt和comment，我们把它们都搬到Item里头去，并且都是私有的。所以它的构造器要的就比较多了。这里我们太懒了就直接删掉然后让eclipse帮我们直接生成：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250207190001737.png" alt="image-20250207190001737"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String title, <span class="type">int</span> playingTime, <span class="type">boolean</span> gotIt, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.gotIt = gotIt;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎子类继承父类的成员变量</p>
<p>CD中也要进行对应的修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123; <span class="comment">//extend；CD是一种特殊的Item</span></span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title, playingTime, <span class="literal">false</span>, comment);</span><br><span class="line"><span class="comment">//		this.title = title;</span></span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line"><span class="comment">//		this.playingTime = playingTime;</span></span><br><span class="line"><span class="comment">//		this.comment = comment;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">CD</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">		cd.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public void print() &#123;</span></span><br><span class="line"><span class="comment">//		// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;CD:&quot;+title+&quot;:&quot;+artist);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DVD也是一样需要修改的。</p>
<p>可是在DVD这我们还要一个奇怪的东西：我们在DVD里还有自己的title——我们知道它从Item里继承了一个title，这个title和Item继承的title有什么关系？</p>
<p>我们在DVD的构造器里说<code>this.title = title;</code>竟然是OK的，为什么？我们来跟踪一下：</p>
<p>从main函数中，</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210173452677.png" alt="image-20250210173452677"></p>
<p>进入到DVD的构造器，</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210173524427.png" alt="image-20250210173524427"></p>
<p>进来之后，关于this：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210173550936.png" alt="image-20250210173550936"></p>
<p>我们看到了两个title、两个playingTime、两个gotIt——因为我们还没有把这些出现在Item里的东西从DVD里面拿走</p>
<p>🍎子类和父类同名成员变量的隐藏</p>
<p>那在它这里就是有两个——一个是他自己的，一个是从Item继承来的。很正常，没问题。</p>
<p>当然，对于计算机来说我们有一个很基本很简单的原则：离我最近的是我的。所以对于DVD的构造器中的<code>this.title</code>来说，这个title一定指的是它自己的title。所以当接下来我们对<code>this.title</code>进行赋值，我们看到这里面只有一个title等于a，另外一个title仍然是null</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210174010050.png" alt="image-20250210174010050"></p>
<p>那个title是谁的？父类Item里的那个title，它没动。</p>
<p>所以这是子类和父类关系当中的另外一个关系，就是：如果子类当中有父类当中有过的完全相同名字的成员变量，那么在子类里面父类的那个就被隐藏起来了。在子类中当我们说那个变量的时候，我们说的是子类自己的，父类的那个看不见了；但是当你回到父类那边去对那个变量做操作的时候，它用的是谁呢？父类自己的。</p>
<p>🍎子类和父类同名成员变量的访问</p>
<p>我们可以试一下这件事情：</p>
<p>如果在父类Item中添加一个setTitle函数，在DVD的构造器初始化title后调用这个函数</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210180410384.png" alt="image-20250210180410384"></p>
<p>运行完之后，另外一个title变成了b：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210180509659.png" alt="image-20250210180509659"></p>
<p>🍎使用super调用父类方法</p>
<p>所以我们总结一下这里的关系：</p>
<p>父类的东西都继承给了子类，子类都得到了。</p>
<p>但是如果父类的那个东西是private的，子类不能碰，可是可以通过父类的函数去碰。</p>
<p>在谁的函数里头指的那个成员变量就是谁的。如果子类和父类当中出现同名的成员变量的时候，在子类的函数里头指的这个变量就是子类自己的，在父类那个函数里头指的就是父类自己的，它们之间没有任何联系。</p>
<p>现在把DVD的变量搬过去，搬过去之后，DVD的print出错了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210180958078.png" alt="image-20250210180958078"></p>
<p>因为DVD的print原来会去打印那个title，而title现在是private的，我不知道title，怎么办？</p>
<p>你不要说，“哎，我把那个title做成protected就好了。”——把父类的成员变量做成protected是一种没有办法的办法，如果我们有办法，尽量不要这么做。那这么做？</p>
<p>你看，Item自己不是有个print吗？那个print不是啥事都没干吗？我们能不能让Item的print去print那个title？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210181416571.png" alt="image-20250210181416571"></p>
<p>我们让它的print的是DVD和director，然后在这中间，我们希望它能用到Item的print去print出它的那个title。但如果你把它写成上图的样子，你认为这个print会调用哪个print？</p>
<p>我们现在又出现了这样的问题：在子类当中有一个叫做print的，在父类当中也有一个叫做print的，名字一模一样。</p>
<p>所以，如果你想说我要去调用父类的那个print，我们要用到老朋友super。super说在这里我们要调用父类的那个print。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210181737560.png" alt="image-20250210181737560"></p>
<p>跟踪一下就可以看到，构造出DVD后，进入了DVD里的print。print出来了【DVD：】后，就到了Item的那个print，这个print就能打印出那个title，然后回来再继续打印那个director，我们就达到了这样的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String title, <span class="type">int</span> playingTime, <span class="type">boolean</span> gotIt, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.gotIt = gotIt;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(title);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123; <span class="comment">//extend；CD是一种特殊的Item</span></span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title, playingTime, <span class="literal">false</span>, comment);</span><br><span class="line"><span class="comment">//		this.title = title;</span></span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line"><span class="comment">//		this.playingTime = playingTime;</span></span><br><span class="line"><span class="comment">//		this.comment = comment;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">CD</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">		cd.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public void print() &#123;</span></span><br><span class="line"><span class="comment">//		// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;CD:&quot;+title+&quot;:&quot;+artist);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String director;</span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DVD</span><span class="params">(String title, String director, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title, playingTime, <span class="literal">false</span>, comment);</span><br><span class="line">		setTitle(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.director = director;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">DVD</span> <span class="variable">dvd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">		dvd.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;DVD:&quot;</span>);</span><br><span class="line">		<span class="built_in">super</span>.print();</span><br><span class="line">		System.out.println(director);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库/资料库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Database</span> &#123; </span><br><span class="line"><span class="comment">//	private ArrayList&lt;CD&gt; listCD = new ArrayList&lt;CD&gt;();</span></span><br><span class="line"><span class="comment">//	private ArrayList&lt;DVD&gt; listDVD = new ArrayList&lt;DVD&gt;();</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Item&gt; listItem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Item&gt;();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void add(CD cd) &#123; 	</span></span><br><span class="line"><span class="comment">//		listCD.add(cd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void add(DVD dvd) &#123;  </span></span><br><span class="line"><span class="comment">//		listDVD.add(dvd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item item)</span> &#123;  </span><br><span class="line">		listItem.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;<span class="comment">//列出所有的CD</span></span><br><span class="line"><span class="comment">//		for ( CD cd : listCD ) &#123;</span></span><br><span class="line"><span class="comment">//			cd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		for ( DVD dvd : listDVD) &#123;</span></span><br><span class="line"><span class="comment">//			dvd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">for</span> ( Item item : listItem ) &#123;</span><br><span class="line">			item.print();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Database</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Database</span>();  <span class="comment">//首先要有一个database </span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>)); <span class="comment">//然后就可以往里面add东西了</span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;def&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;AAA&quot;</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.list();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q：<em>父类的私有的成员函数在子类中能使用吗？</em><br>设计一些测试的场景来证明你的观点</p>
<p>A：不能</p>
</blockquote>
<h3 id="4-3-多态变量和向上造型"><a href="#4-3-多态变量和向上造型" class="headerlink" title="4.3 多态变量和向上造型"></a>4.3 多态变量和向上造型</h3><h4 id="4-3-1-多态变量"><a href="#4-3-1-多态变量" class="headerlink" title="4.3.1 多态变量"></a>4.3.1 多态变量</h4><blockquote>
<p>[!NOTE]</p>
<p>类定义了类型,DVD类所创建的对象的类型就是DVD。类可以有子类,所以由那些类定义的类型可以有子类型。在DoME的例子中,DVD类型就是Item类型的子类型。</p>
<p>子类型类似于类的层次,类型也构成了类型层次。子类所定义的类型是其超类的类型的子类型。</p>
<p>当把一个对象赋值给一个变量时,对象的类型必须与变量的类型相匹配,如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(); </span><br></pre></td></tr></table></figure>

<p>是一个有效的赋值,因为Car类型的对象被赋值给声明为保存Car类型对象的变量。但是由于引入 了继承,这里的类型规则就得叙述得更完整些:</p>
<p><strong>一个变量可以保存其所声明的类型或该类型的任何子类型。</strong></p>
<p>对象变量可以保存其声明的类型的对象,或该类型的任何子类型的对象。</p>
<p>Java中保存对象类型的变量是多态变量。“多态”这个术语(字面意思是许多形态)是指一个变量可以保存不同类型(即其声明的类型或任何子类型)的对象。</p>
</blockquote>
<p>🍎多态变量和向上造型</p>
<p>我们对Database动手的时候，动手之前它是这个样子的，它里头有两个add函数，分别对CD和DVD做操作：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210182650288.png" alt="image-20250210182650288"></p>
<p>然后我们增加了一个父类Item后，就变成了只需要一个add函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210182744180.png" alt="image-20250210182744180"></p>
<p>这个函数要的是Item，可是我们在用它的时候，我们是做了一个CD的对象出来，交给了这个add函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210182852731.png" alt="image-20250210182852731"></p>
<p>add函数要的是Item，而我们给它的是CD和DVD——我们从来没有真的做一个Item出来给add函数，我们给它的都是Item的某个子类的对象。</p>
<p>准确的说，我们总是制造了Item的某个子类的对象，把它交给了这个add函数。而add函数的参数表说，我要的是一个Item。</p>
<p>这事一定是可行的，我们之前都已经做了，这就是可以这么做的。但，为什么？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210183122520.png" alt="image-20250210183122520"></p>
<p>在面向对象的世界里头，类（Class）它的本意其实就是类型（type）。所以我们定义了一个新的类出来，我们就是定义了一个新的类型。这个新的类型我们之前已经看到，可以用来定义变量、可以制造出这个类的一个对象出来放在这个变量里头，当然我们也知道这个对象的变量它是一种管理者。</p>
<p>所以，类（Class）就是类型（type）。</p>
<p>而子类呢？我们用来extends。我们说<code>CD extends Item</code>表示说CD是Item的一个子类。那么在这种关系中，我们就可以说CD是Item的一个子类，CD是Item的一个子类型。</p>
<p>就是子类和父类的关系，同样也表达为类型之间的子类型的关系。</p>
<p>🍎子类和父类的关系</p>
<p>所以子类的对象可以被当做父类的对象来使用。比如说子类的对象可以赋给父类的变量、子类的对象可以传递给需要父类对象的函数、子类的对象也可以放在用来存放父类对象的那种容器里头。</p>
<p>比如说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210183810423.png" alt="image-20250210183810423"></p>
<p>从父类Vehicle派生出了两种车辆：一种是car，一种是bicycle。它们都是交通工具，它们都是车辆。所以如果我们有一个Vehicle的变量，它可以获得的可以是Vehicle的对象、可以说Car的对象、也可以是Bicycle的对象——子类的对象总是可以安全的去交给那个父类。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210184115731.png" alt="image-20250210184115731"></p>
<p>然后如果在函数传递过程当中也是一样，就像我们在database当中一样。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210184211623.png" alt="image-20250210184211623"></p>
<p>最后在database里，我们的那个容器是Item的容器，这个容器里面可以放CD也可以放DVD。我们来看一下这个事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210184412275.png" alt="image-20250210184412275"></p>
<p>当我们在34行做了一个CD交给18行的这个add函数之后，add函数认为它拿到是一个Item，它并不关系这个Item究竟是Item呢、还是CD呢、还是DVD呢。任何Item及其子类都是可以由这个Item的变量来管理的。</p>
<p>🍎多态变量的意义和类型</p>
<p>然后就把它add进了（交给了）listItem里头（19行），到底放进去以后是什么呢？</p>
<p>跟踪可以看到，在database类里头有容器listItem。在listItem中，它的elementData 0、1、2三个东西都有了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210185011982.png" alt="image-20250210185011982"></p>
<p>对于第一个东西（0号单元）和第二个东西（1号单元），可以看到它有numofTracks，我们知道这是一个CD。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210185213839.png" alt="image-20250210185213839"></p>
<p>而第三个东西（2号单元），可以看到它有director，我们知道这是一个DVD。</p>
<p>所以在这个容器里头：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210185401527.png" alt="image-20250210185401527"></p>
<p>1号单元是一个CD，2号单元是一个DVD，但是它们放在同一个容器listItem里面。</p>
<p>也就是说在这个容器里面，由于它是用来放Item的，所以我们可以把子类的这些对象放在里面。在这个容器的每一个单元可能放的是不同的东西，但是只要他们都是Item的子类，它就能被放在这样一个容器里面。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210185634541.png" alt="image-20250210185634541"></p>
<p>🍎Java中的多态变量</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210185652070.png" alt="image-20250210185652070"></p>
<p>在Java的系统中，所有的对象变量都是多态的。多态是什么意思？就是多种形态嘛。</p>
<p>就是这个时候它可以放这种类型的变量，过一个时候它又可以放另外一个类型的变量。</p>
<p>我们认为这个多态变量有两个类型：一个是声明类型（静态类型）：字面上可以看出来的类型。一个是动态类型：当程序运行到这的时候，它里头管理的是一个什么类型的对象。</p>
<p>所以每一个Java变量都有两个类型，有的时候可能是一致的，有的时候可能不一致的。</p>
<p>🍎向上造型的概念</p>
<p>所以这就是变量的多态。</p>
<p>多态变量的意思就是，这个变量运行的时候，在具体某一个时刻它所管理的那个对象的类型是会变化的。</p>
<p>当我们把一个子类的对象赋给这么一个多态变量的时候，就发生了一件事情，叫做向上造型。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210190546736.png" alt="image-20250210190546736"></p>
<p>就像在database中，做了一个CD的变量出来，把它交给item这个多态变量。多态变量item的静态类型是Item，但我们实际做的是它子类的对象。在这个时候把子类的对象交给父类的一个变量（静态类型为父类的一个变量），这个时候发生的事情就叫做向上造型。</p>
<h4 id="4-3-2-向上造型"><a href="#4-3-2-向上造型" class="headerlink" title="4.3.2 向上造型"></a>4.3.2 向上造型</h4><p>🍎造型的意思及注意事项</p>
<p>我们把这个叫做造型。</p>
<p>造型的意思就是把一个类型的对象赋给另外一个类型的变量。这个过程叫做造型。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210215012724.png" alt="image-20250210215012724"></p>
<p>子类的对象是可以复制给父类的变量的。但是要特别注意的是，我们在入门课程中讲过，我们也放在进阶课程的预习的内容里头了，<strong>在Java当中，对象变量的赋值并不是拿一个对象去给另外一个对象赋值，而是让这两个对象的管理者去管理一个共同的对象</strong>。这一点，几乎所有的<strong>OOP</strong>（Object Oriented Programming 面向对象编程）<strong>语言</strong>都是这样的。但是不幸的是，如果你之前学过C++，C++不是这样，C++是一个改造的不够完全的<code>OOP语言</code>，所以它和其他的<code>OOP语言</code>都不太一样。在C++中你可以做两个对象的赋值，但是在Java做不到。</p>
<p>eg：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210215545264.png" alt="image-20250210215545264"></p>
<p>s &#x3D; “bye”; 是说：原本s这个管理者是管理hello的，后来s去管另外一个叫做buy的对象。</p>
<p>并不是说，我要用bye的的内容去替换原来hello的内容，不是的，Java不能做这样的事情。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210215744579.png" alt="image-20250210215744579"></p>
<p>🍎对象变量赋值和类型转换</p>
<p>我们可以跟踪也来证明一下这件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210215857712.png" alt="image-20250210215857712"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210215912763.png" alt="image-20250210215912763"></p>
<p>s原本是id为19的s，运行第二句后，s变成了bye并且id变成了23。这表明s已经指向另外一个对象了。</p>
<p>所以Java的变量类型就是这样起作用的，你不可能让一个对象去修改另外一个对象的值，如果采用赋值运算符的话。赋值运算符做的事情就是让这个变量去指向了另外一个对象，去管理了另外一个对象。</p>
<p>这是赋值，那么在这个过程中就可能发生造型。就是让静态类型为某个类型的变量去管理了动态类型和它的静态类型不符的那个对象。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210220550159.png" alt="image-20250210220550159"></p>
<p>如果把子类的对象交给父类的对象，这是可以做到的，我们之前试过。但是把一个父类的对象交给子类呢？我们可以试一下：如果我们做一个父类的对象item，再做一个子类的对象cd，让它去等于item：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210220449771.png" alt="image-20250210220449771"></p>
<p>立刻就不行了，它说类型不匹配，不能把Item转化成CD。子类的对象不能接受父类的变量。</p>
<p>🍎子类对象赋给父类变量是安全的</p>
<p>但反过来是安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>, <span class="literal">true</span>, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    <span class="type">CD</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    item = cd; <span class="comment">//这其实已经在做造型了</span></span><br><span class="line">    <span class="comment">//CD cc = item;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类的对象赋给父类的变量是安全的，但反过来那是不行的，编译会出错的。</p>
<p>可是如果现在item这个变量里面放的是一个cd了，那我再有一个CD的变量cc我能不能让它等于item呢？</p>
<p>如果cc &#x3D; cd那肯定是可以的，因为它们都是CD类型的变量。而对于cc &#x3D; item，我们知道现在其实item里放的是一个cd的对象，那应该它是可以被交给一个CD的变量的。</p>
<p>只是从编译器的角度来说，它看不明白那么多事，它没有那么高级的智能，它只会认为你这是一个Item类型的变量，你要想交给一个CD类型的变量，它不答应。</p>
<p>🍎父类对象赋给子类变量是不安全的</p>
<p>有一个绕过去的办法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CD</span> <span class="variable">cc</span> <span class="operator">=</span> (CD)item;</span><br></pre></td></tr></table></figure>

<p>加一个圆括号，表明说我们要强迫这个item成为一个CD，然后去交给cc。</p>
<p>于是编译就给你过了，运行也是能过的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210221312386.png" alt="image-20250210221312386"></p>
<p>接下来的问题的是，如果我没有做item &#x3D; cd ——item实际上是一个Item，而不是CD。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210221419870.png" alt="image-20250210221419870"></p>
<p>然后我们在36行编译器就认了。——你都这么说了我就要把这个item当作CD给你，它没办法只能认了。认了之后呢？运行一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210221554099.png" alt="image-20250210221554099"></p>
<p>异常：在36行出来一个叫做ClassCastException 类造型异常的错误。Item不能被cast成CD。</p>
<p>实际上item现在放的就是Item，这个东西不能被造型成一个CD。</p>
<p>所以你用这种造型的方式，用圆括号里面加上类型的名字去吧一个变量强制变成另外一种类型，这种事情并不总是安全的。取决于被造型的那个变量当时实际管理的类型究竟是什么。</p>
<p>🍎向上造型和类型转换的区别</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210221929630.png" alt="image-20250210221929630"></p>
<p>造型就是用括号围起来放在值的前面，但是我们要理解一件事情，对于这个面向对象的语言来说，对于这样一个对象系统来说，我们把它叫做造型。我们其实在入门的课程里头遇到过这样的事情，eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10.2</span>; <span class="comment">//类型转换</span></span><br></pre></td></tr></table></figure>

<p>那时我们说这个叫做类型转换。</p>
<p>类型转换和造型是不同的，因为类型转换做完以后10.2的值就不再是10.2了，这个值就真的换成了一个对应的int型的值，就是10，不带小数点的。</p>
<p>而造型是什么？造型做完以后，我是把你当做另外一个类型来看待，我并没有把你改造成另外一个类型。</p>
<p>我们可以这样跟踪一下看看在36行cd有没有被换掉：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210222619636.png" alt="image-20250210222619636"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210222540323.png" alt="image-20250210222540323"></p>
<p>36行进行后，item所管理的那个对象仍然是CD类型的。尽管我们在36行说我们要把这个cd造型成Item。那只是说，我们要把这个cd当作Item来看待，并不是要把这个cd转变成Item的对象。</p>
<p>所以我们把<code>cast</code>翻译成<code>造型</code>。尽管这个cast跟double变int那个cast在英文里是同一个单词，但是在中文中我们还是把它分成两个不同的术语。一个叫做<code>类型转换</code>，是对于int、double这种<code>基本类型</code>来说。一个叫做<code>造型</code>，对于<code>对象类型</code>来说。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210223008514.png" alt="image-20250210223008514"></p>
<p>那么所谓的向上造型，就是拿一个子类的对象当作父类的对象来用。为什么叫做向上呢？因为是这样的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250210223132322.png" alt="image-20250210223132322"></p>
<p>因为我们在画类的关系图的时候，总是这样画：上面是父类下面是子类。</p>
<p>当要把一个子类对象当作父类对象来看待时，叫它向上造型。</p>
<blockquote>
<p><strong>以下哪些赋值是合规则的？</strong><br>Q：假设现有4个类:Person、Teacher、Student和PhDStudent。Teacher 和Student都是Person的子类,PhDStudent是Student的子类。以下的赋值语句哪些是合法的,为什么?</p>
<p>A：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  <span class="comment">//合法，向上造型</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhDStudent</span>(); <span class="comment">//合法，向上造型</span></span><br><span class="line"><span class="type">PhDStudent</span> <span class="variable">phd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">//不合法</span></span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//不合法</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhDStudent</span>(); <span class="comment">//合法，向上造型</span></span><br><span class="line">s1 = p1; <span class="comment">//不合法，需强制向下造型</span></span><br><span class="line">s1 = p2; <span class="comment">//不合法，需强制向下造型</span></span><br><span class="line">P1 = s1; <span class="comment">//合法，向上造型</span></span><br><span class="line">t1 = s1;<span class="comment">//不合法</span></span><br><span class="line"> s1 = phd1; <span class="comment">//不合法</span></span><br><span class="line">Phd1 = s1;<span class="comment">//不合法，需强制向下造型</span></span><br></pre></td></tr></table></figure>

</blockquote>
<blockquote>
<h3 id="谁是谁的父类合适？"><a href="#谁是谁的父类合适？" class="headerlink" title="谁是谁的父类合适？"></a>谁是谁的父类合适？</h3><p>Q：有时候事物本身比其第一印象更复杂。考虑一下,矩形和正方形的继承关系是怎样的?</p>
<p>因为从数学上，正方形是一种特殊的矩形。但是，从程序实现上考虑，正方形只要一个边长，而矩形可以从正方形继承后再增加一个边长成员变量。另一方面来说，如果正方形从矩形继承，那么就会出现冗余的第二个边长变量。</p>
<p>你怎么看这个事情？</p>
<p>A：正方形继承矩形更合适，矩形更具有一般性，定义面积&#x2F;周长类函数，正方形可以直接继承使用，这样继承会更有效率。</p>
</blockquote>
<h3 id="4-4-多态"><a href="#4-4-多态" class="headerlink" title="4.4 多态"></a>4.4 多态</h3><blockquote>
<p>[!NOTE]</p>
<p>如果子类的方法覆盖了父类的方法，我们也说父类的那个方法在子类有了新的版本或者新的实现。覆盖的新版本具有与老版本相同的方法签名：相同的方法名称和参数表。因此，对于外界来说，子类并没有增加新的方法，仍然是在父类中定义过的那个方法。不同的是，这是一个新版本，所以通过子类的对象调用这个方法，执行的是子类自己的方法。</p>
<p>覆盖关系并不说明父类中的方法已经不存在了，而是当通过一个子类的对象调用这个方法时，子类中的方法取代了父类的方法，父类的这个方法被“覆盖”起来而看不见了。而当通过父类的对象调用这个方法时，实际上执行的仍然是父类中的这个方法。注意我们这里说的是对象而不是变量，因为一个类型为父类的变量有可能实际指向的是一个子类的对象。</p>
<p>当调用一个方法时，究竟应该调用哪个方法，这件事情叫做绑定。绑定表明了调用一个方法的时候，我们使用的是哪个方法。绑定有两种：一种是早绑定，又称静态绑定，这种绑定在编译的时候就确定了；另一种是晚绑定，即动态绑定。动态绑定在运行的时候根据变量当时实际所指的对象的类型动态决定调用的方法。Java缺省使用动态绑定。</p>
</blockquote>
<p>🍎多态</p>
<p>在前面继承的部分看了database后，有细心的同学发现当中有问题：他说，那个print是怎么回事：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211160011794.png" alt="image-20250211160011794"></p>
<p>在item里有print，在CD和DVD中也有print，然后我们在database的list函数里面，我们是有一个Item类型的变量让它去做了print的动作，结果，看起来CD或者DVD的print被调用了。</p>
<p>这个事情是怎么实现的？我们现在是这样的事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211160229527.png" alt="image-20250211160229527"></p>
<p>在这个list函数里面的for循环，每次拿到了listItem里面的一个item。然后我们去让这个item去做print，结果看起来并不是Item类的print被调用了。因为Item类的print就是输出了那个title：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211160349794.png" alt="image-20250211160349794"></p>
<p>而我们实际看到的东西不止title，看起来CD的DVD的videoGame的print函数都被调用了，我们可以来跟一下这件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211160544967.png" alt="image-20250211160544967"></p>
<p>进入循环后，第一个item是一个CD类型的item，我们就到了CD的print函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211160640732.png" alt="image-20250211160640732"></p>
<p>因为这个时候item所管理的是一个CD类型的对象，所以它的print就会到CD的print，然后做一些输出之后回来。</p>
<p>第二轮：还是一个CD的，然后又去了CD的print，再回来。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211160757330.png" alt="image-20250211160757330"></p>
<p>第三轮：item所管理的是一个DVD了（我们放进去的第三个东西是一个DVD）</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211160847416.png" alt="image-20250211160847416"></p>
<p>这个时候我们就去到了DVD的print函数里面，然后去做DVD的print该做的事情。</p>
<p>也就是说，在我们的这个for循环里面，循环的每一轮，它会拿到一个item，那个item根据我们放进去的可能是个CD可能是个DVD也可能是个videoGame。</p>
<p>我们知道item这个变量是一种多态变量，它有两个类型，一个是它的声明类型，一个是它的多态类型。它的声明类型永远是Item，而它的动态类型呢，这次循环拿到的是什么它就是声明。而当我们通过【 . 】运算符说，item你所管理的那个对象去做print动作的时候，它会让它所<strong>实际管理</strong>的那个对象的类型去做print的动作。</p>
<p>实际管理的是CD，做CD的print；实际管理的是DVD，做DVD的print——这件事情，叫做<strong>多态</strong>。</p>
<p>🍎绑定</p>
<p>这件事情的技术基础是什么呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211161408097.png" alt="image-20250211161408097"></p>
<p>当我们通过变量去调用函数的时候（eg：<code>item.print;</code>），选择哪一个函数来调用，这个事情叫做<strong>绑定</strong>。</p>
<p>绑定有两种，一种叫做<strong>静态绑定</strong>，一种叫做<strong>动态绑定</strong>。静态绑定就是：你这个变量的声明类型是什么，我就调用这个声明类型的函数；而动态绑定就是：你当时所（实际）管理的那个对象的类型是什么，我得调用那个类型的函数。因为静态的时候在编译的时候不知道。</p>
<p>对于编译器来说，<code>item.print;</code>这一行在编译的时候并不知道这个时候item管的是什么，所以只有运行的时候才知道。<strong>运行的时候才知道的东西，那就是动态的。</strong></p>
<p>对于Java这样的面向对象的程序语言来说，默认<strong>所有</strong>的绑定都是动态绑定。</p>
<p>那么我们在一个成员函数里面去调别的成员函数，因为它实际可以体现为<code>this.xxx;</code>所以它也是一种动态绑定。所以所有的成员函数的调用都应该被看作是一种动态绑定。</p>
<p>🍎覆盖</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211162112697.png" alt="image-20250211162112697"></p>
<p>如果在子类和父类当中，我们发现了存在着那么一对函数，它们的名称相同，参数表也相同，它们就构成了我们叫做<strong>覆盖关系</strong>。子类的这个函数把父类的那个函数覆盖掉了。eg：对于print来说，CD的print就覆盖了Item的print。我们通过一个Item的变量来调用print的时候，它会根据实际到底是哪一个类来决定到底调用哪一个类的print函数。</p>
<p>所以CD里的print和Item里的print它们之间的关系就叫做覆盖。</p>
<p>还记不记得我们在最开始的时候曾经看到过的那个shape的例子？我们来回顾一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211162534951.png" alt="image-20250211162534951"></p>
<p>在这个例子里面也是这样：shape只有一个函数，叫做draw，然后它的某一个子类（eg：Circle）也有一个draw：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211162622920.png" alt="image-20250211162622920"></p>
<p>这个draw，就覆盖了shape里的draw。因此，在我们画图的时候，在Picture里面，我们会从listofShape（这是<code>ArrayList&lt;Shape&gt;</code>）里拿出一个Shape来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211162725849.png" alt="image-20250211162725849"></p>
<p>这个时候拿到的s可能是Circle、可能是Rectangle、可能是Triangle，我们就让它去draw()了。这个draw的时候，其实我们的想法是这个样子的：我们认为这个s呢，一定是一个Shape——它可能是一个Shape类，也可能是Shape类的一个子类。</p>
<p>因为Shape的定义说：任何的Shape都有一个draw函数。所以在Picture的这里说：你是一个s，是一个Shape，所以你一定会draw，至于你是怎么draw的，我不关心。</p>
<p>我相信有Java这个语言有一个机制，能够找到正确的draw函数去draw。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211163354920.png" alt="image-20250211163354920"></p>
<p>🍎多态</p>
<p>所以既然你是一个Shape，那你就去draw吧。怎么draw？你自己掌握好draw的细节，这个就叫做<strong>多态</strong>。</p>
<p>所谓多态就是，通过一个变量去调用一个函数，我们只是写了那么一句话，我们并不去判断变量实际的类型是什么。不需要去写switch-case、不需要去写if-else，我们只要说<code>s.draw</code>，我们只要说<code>item.print</code>，对应的那个函数就会被调用出来，这件事情，就叫做<strong>多态</strong>。</p>
<p>你是一个Shape，你就会draw，那你自己去draw吧。</p>
<blockquote>
<h3 id="关于print"><a href="#关于print" class="headerlink" title="关于print"></a>关于print</h3><p> Q：Item的print函数有几种可能的实现方式：</p>
<ol>
<li>和视频中一样，Item的print输出Item的私有成员变量，然后CD等子类override这个print函数，实现完整的输出，并在其中通过super.调用Item的print；</li>
<li>Item的print会输出完整的内容，但是其中子类的部分，会调用一个protected的print_task函数来输出。子类则不去override print，而是override这个print_task函数，实现子类自己的成员变量的输出；</li>
<li>Item的print函数什么也不做。另外给一个format函数，输出格式化的私有成员变量的内容表达。子类利用这个format函数得到内容后输出。</li>
</ol>
<p>你觉得这些方案哪个更合适？为什么？如果你有更好的方案，也请提出来。</p>
<p>A：分开输出</p>
<p>方案3，理由是把格式化和输出这两个动作分开了，代码灵活性更高。</p>
</blockquote>
<h3 id="4-5-类型系统"><a href="#4-5-类型系统" class="headerlink" title="4.5 类型系统"></a>4.5 类型系统</h3><h4 id="4-5-1-Object类"><a href="#4-5-1-Object类" class="headerlink" title="4.5.1 Object类"></a>4.5.1 Object类</h4><p>🍎Java的单根结构</p>
<p>Java实现了一个<strong>单根结构</strong>。就是说，在Java中，所有的类，不管你愿意不愿意，不管你声明不声明，这些类一定都是一个叫做<code>Object</code>类的子类。这个Object就是Java的类型系统当中的那个<code>root</code>（根）。所以这个叫做单根结构。</p>
<p>几乎所有的<code>OOP语言</code>（<code>OOP</code>：Object Oriented Programming 面向对象编程）都实现了这样一个单根结构，除了C++。所以Java也是这样有单根结构的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211170505390.png" alt="image-20250211170505390"></p>
<p>所以在这个图中，String-这是系统类库中的类，Person、Vehicle-也当然是我们自己做的类，它们都是继承自Object的。</p>
<p>如果这个类是直接从Object得到继承的，你不需要写extends。你不声明默认它就是Object类的子类。</p>
<p>那么我们讲继承是说：你如果是从那个类继承，那么那个类的所以的public东西都是你的public的东西、那个类的所有东西都是你的东西。那么Object这个类给了我们一些什么东西呢？</p>
<p>🍎<code>Object</code>类的作用</p>
<p>其实我们之前就遇到过两个：一个就是那个<code>toString</code>。我们在那一周的作业里头出现了<code>toString</code>。一个是equals。                                           </p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211171037456.png" alt="image-20250211171037456">                                                                                                                                                                                                                                                          </p>
<p>我们怎么能够知道这个Object有些什么样的类&#x2F;有些什么样的函数是我们可以使用的？</p>
<p>在eclipse里，有两个方案可以做这个事情：</p>
<p>1.我们不妨说有一个Object的对象o，我们说【 o. 】，然后它就会列出所有Object的东西。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211214413564.png" alt="image-20250211214413564"></p>
<p>2.选中您要查找的接口名称，然后点击鼠标右键，选择【Open Type Hierarchy】打开类型层级。 此时在【Type Hierarchy】类型层级页面可以看到所有实现了此接口的<strong>类</strong>，下方显示了此接口中的方法。 点击选中某个实现<strong>类</strong>，下方会同步显示出此类中的方法。 双击某个实现<strong>类</strong>，可以进入这个实现<strong>类</strong>的代码。</p>
<p>notify和wait这些是和多进程多任务有关的事情我们后面再去说。</p>
<p>🍎重写<code>toString</code>方法</p>
<p>我们今天来研究下toString和equals这两个东西。</p>
<p>1）<code>toString</code>：会返回一个对象的字符串的表达形式（用一个字符串来表达那个对象）。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211214552276.png" alt="image-20250211214552276"></p>
<p>如果说我们自己的类没有<code>toString</code>，我们可以来试一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211214941293.png" alt="image-20250211214941293"></p>
<p>前面是这个类的名字。后面的部分你可以大致认为这是它在内存当中的一个地址&#x2F;编号——所以如果你没有去写它的<code>toString</code>它就会做这个事。</p>
<p>但是在前面的作业里我们知道，如果你需要一个字符串，这里你可以直接用这个对象（即<code>println(cd)</code>）不需要加上后面的<code>toString</code>，他会知道在这个地方需要调用你的<code>toString</code>去把它转成String。</p>
<p>类似的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211215253745.png" alt="image-20250211215253745"></p>
<p>这是能做的，因为编译器发现，这个加号的左边是一个字符串，右边是一个不是字符串的东西，它就会自动的去寻找一个方案，把那个不是字符串的东西来转变成字符串——而对于一个对象来说，那个方案就是<code>toString</code>。</p>
<p>如果我们想要这种手段能够给我们产生一个有意义的表达这个cd对象的那么一个字符串，我们就得自己写一个<code>toString</code>。可是怎么把这个<code>toString</code>做出来呢？</p>
<p>当然我们也可以自己用<code>public ...</code>自己敲一个出来，但我们有另外的办法——eclipse总是有很多东西来帮我们的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/%E6%9C%AA%E6%A0%87%E9%A2%98-1.png" alt="未标题-1"></p>
<p>然后它就会说，你这个<code>toString</code>要把哪一些字段<code>toString</code>过去啊？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/1231.png" alt="1231"></p>
<p>它列出了它自己的这些Fields，你还可以点开来看继承得到的——你要不要在这个<code>toString</code>里面包含一下其他的函数？实际上这里（Inherited methods）还会涉及到<code>toString</code>，指的是如果Item那个类（父类）有一个<code>toString</code>的话，它会帮我们去把Item的那个<code>toString</code>的结果也包含到我们现在这个cd（子类）的<code>toString</code>里头去。</p>
<p>它给我们产生了这样一个函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211220715159.png" alt="image-20250211220715159"></p>
<p>——public的返回一个String的<code>toString</code>。return就是把一串的东西给它加起来，这当中包括super的<code>toString</code>（也就是Item类的<code>toString</code>的结果）。如果我们把这个程序现在来运行一下，我们就会看到相对比较好看的结果了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211220925008.png" alt="image-20250211220925008"></p>
<p>但是它还会列出<code>dome.CD@22998b08</code>——这个是谁列出来的？Item的那个<code>toString</code>，因为我们没有去做Item的函数。</p>
<p>🍎重写<code>equals</code>方法</p>
<p>2）equals：</p>
<p>还有一个有用的东西，我们之前见过，是那个equals。就是我要去比较两个对象的<strong>内容是否相同</strong>（我们知道用【 &#x3D;&#x3D; 】是比较不了的，【 &#x3D;&#x3D; 】只能用来说比较这两个变量是不是管理着同一个对象）。</p>
<p>可是对于CD来说，如果我们这样做了一个一模一样的cd1：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211221421152.png" alt="image-20250211221421152"></p>
<p>它会说false。</p>
<p>他会说false的理由是：我们没有做自己的equals——我们现在在使用的是Object的那个equals。所以我们需要有一个自己的equals能够去判断它们两个的值是否真的相同。</p>
<p>——你想，对于Object这个公共父类来说，它没有任何可能去知道它的某一个子类到底长什么样子。那是在它那个代码写出来很多很多年以后写出来的东西，它怎么可能知道？</p>
<p>所以对于这里的equals来说，它其实做的事情就是去判断这两个管理者管理的是不是同一个对象。那我们要怎么做呢？我们要去写一个自己的CD类的equals，这么干：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/%E6%9C%AA%E6%A0%87%E9%A2%98-1-1739283812666-3.png" alt="未标题-1"></p>
<p>同样，Source，这里没有Generate equals了，可是我们可以用Override&#x2F;Implement Method。它做的事情是：列出父类有什么样的函数，然后问你你要重新改写哪个函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/134143.png" alt="134143"></p>
<p>然后可以看到Object里面有个equals，然后打个勾，OK：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211222440449.png" alt="image-20250211222440449"></p>
<p>它就给我们做了一个equals函数出来——这个equals函数返回一个boolean，会拿一个Object过来，它也会用super（也就是父类Item）的equals来判断这俩是否相同。</p>
<p>现在它是这个样子的，我们可以把它改一改，我们需要判断的事情是说：我们想要知道比如说如果两个artist是相同的，我们就认为它们是同一个。要注意的是，obj里头是没有artist的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211222751979.png" alt="image-20250211222751979"></p>
<p>因为equals函数的原型说它是以object作为参数来作为输入的。换句话说，当我们后面在main里面我们要说<code>cd.equals(cd1)</code>的时候，我们把这个cd1传给equals函数，在equals里头，cd1就不再是一个CD了，而是一个Object：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211222902934.png" alt="image-20250211222902934"></p>
<p>这下该怎么办？我们可以做一个CD的对象cc，让它等于obj——向下造型。cc表达的一个CD，我们就可以用它的artist来做判断，然后把这个值返回回去。这样了来运行，我们就能得到true了，因为它用了我们自己的equals：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211223221847.png" alt="image-20250211223221847"></p>
<p>🍎<code>@Override</code>注解的使用</p>
<p>在这里还有一个东西，就是这个<code>@Override</code>，这是干什么的？</p>
<p>——我们是用eclipse的功能去帮我们做了<code>@Override</code>，帮我们去产生了equals和<code>toString</code>函数，然后它在这两个函数前头都加了这个at Override。</p>
<p>这个东西的意思是，它告诉编译器，下面这一行的那个函数是一个覆盖了父类的函数。换句话说，它必须和父类的那个函数具有<strong>完全相同</strong>的函数签名&#x2F;函数原型——也就是函数的名字、参数表必须一样，并且都是public的。</p>
<p>如果有一个不相同，就会认为是错误的。eg1：如果去掉public（可见性的修饰符&#x2F;关键字不同）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211223700168.png" alt="image-20250211223700168"></p>
<p>——它会说这个东西，Object的equals函数是public的，你不能降低了它的visibility（能见度）。</p>
<p>eg2：如果改成CD类型的obj（参数表不同）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211224011810.png" alt="image-20250211224011810"></p>
<p>——它会说这个类型不能够改。</p>
<p>eg3：如果去掉<code>@Override</code>，修改equals的参数表，再来运行它：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211224136501.png" alt="image-20250211224136501"></p>
<p>——得到了false。得到了false的理由是当main函数在做equals时，根本就没有进到我们写的equals里去。因为这个equals是没有int的，所以它又回到了Object的equals那边去。</p>
<p>这是因为把<code>@Override</code>去掉了，这样编译器就不能替你检查了，其实你的equals函数就并不会去取代Object里头的那个equals函数了。</p>
<h4 id="4-5-2-DoME的新媒体类型"><a href="#4-5-2-DoME的新媒体类型" class="headerlink" title="4.5.2 DoME的新媒体类型"></a>4.5.2 DoME的新媒体类型</h4><p>🍎继承与多态</p>
<p>在我们现在这个媒体资料库的这个程序基础上，如果我们有一种新的媒体要加入进来，那会是非常容易的——因为你不需要对database这个类做什么改动。你也不需要对Item做什么改动，你要做的事情就是增加一个新的类，那个类从Item那里继承。</p>
<p>然后所有的事情都顺理成章了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211225212148.png" alt="image-20250211225212148"></p>
<p>🍎类的继承和构造器</p>
<p>我们只要右键新建一个类，比如说我们有一个叫做VideoGame的类。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/%E6%9C%AA%E6%A0%87%E9%A2%98-1-1739285836489-6.png" alt="未标题-1"></p>
<p>然后再Superclass里直接改，不需要到源代码里面去改。</p>
<p>说这个类就继承自Item，把Superclass改成Item即可：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211225848124.png" alt="image-20250211225848124"></p>
<p>我们就会得到VideoGame extends Item：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211225917579.png" alt="image-20250211225917579"></p>
<p>现在我们需要一个构造器，有两种方法：</p>
<p>1）一种是直接Source构造器</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/1.png" alt="1"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/2.png" alt="2"></p>
<p>2）另一种做法是，能不能需要一个构造器是从父类来的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/%E6%9C%AA%E6%A0%87%E9%A2%98-1-1739286851745-8.png" alt="未标题-1"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/%E6%9C%AA%E6%A0%87%E9%A2%98-2.png" alt="未标题-2"></p>
<p>于是它就帮我们做了一个构造器：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211231520379.png" alt="image-20250211231520379"></p>
<p>——这个构造器有父类要的title、playingTime……这些参数，通过super传给它，如果我们有了新的成员变量，我们可以直接修改这个构造器的参数表，加上即可。</p>
<p>🍎方法的重写</p>
<p>我们还需要为它做比如说print函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211231901496.png" alt="image-20250211231901496"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211231918601.png" alt="image-20250211231918601"></p>
<p>这样我们就做好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoGame</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numberOfPlayers;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">VideoGame</span><span class="params">(String title, <span class="type">int</span> playingTime, <span class="type">boolean</span> gotIt, String comment, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title, playingTime, gotIt, comment);</span><br><span class="line">		numberOfPlayers = number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;VideoGame&quot;</span>);</span><br><span class="line">		<span class="built_in">super</span>.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎可扩展性</p>
<p>那么对于database来说，要不要动呢？database的<code>ArrayList&lt;Item&gt;</code>是可以放CD和<code>DVD</code>的，既然现在VideoGame是Item，当然它也能放database的。data的add是要add一个Item的，既然VideoGame是一种Item，所有它也能够接受。</p>
<p>对于main来说，我们现在就可以放新的类型：</p>
<p>（完整代码放在最后）</p>
<p>跑一下就可以看到<code>VideoGame</code>也放进去了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211232634437.png" alt="image-20250211232634437"></p>
<p>🍎多层继承关系</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211232648658.png" alt="image-20250211232648658"></p>
<p>在现在这种database的架构底下，我们要增加一个新的媒体非常容易——增加一种新的媒体类型只要增加Item类的一个新的子类就可以了。对于database来说，add函数、那个<code>listofitem</code>、那个print函数是完全不需要动的，这种特性我们叫做<strong>可扩展性</strong>。</p>
<p>——你的代码不需要经过修改，就可以扩展去适应新的数据、新的内容。</p>
<p>如果你的代码需要经过修改，就可以扩展去适应新的数据、新的内容，那不叫做可扩展性，那叫做<strong>可维护性</strong>。这是两个不同的术语。</p>
<p>假如说我们现在在<code>VideoGame</code>的基础上又想增加一个新的类型，<code>eg</code>：我们想增加一种叫做棋类游戏的<code>boardgame</code>，它和电子游戏<code>VideoGame</code>有相似的地方，<code>eg</code>：都有<code>numberOfPlayers</code>，这个时候怎么做呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250211233123908.png" alt="image-20250211233123908"></p>
<p>我们可以进一步的用我们之前在继承那个环节当中所学到的技术，我们不见得要去做两个独立的<code>videogame</code>和<code>bordergame</code>，我们可以在他们的上面实现一个叫做game的那么一个类，这个game的类用来可以表达那个<code>numberofgames</code>，然后从它再派生出两个进一步的类，所以可以形成一个更深的继承关系来更加有效的表达我们所有的媒体类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库/资料库</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Database</span> &#123; </span><br><span class="line"><span class="comment">//	private ArrayList&lt;CD&gt; listCD = new ArrayList&lt;CD&gt;();</span></span><br><span class="line"><span class="comment">//	private ArrayList&lt;DVD&gt; listDVD = new ArrayList&lt;DVD&gt;();</span></span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Item&gt; listItem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Item&gt;();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void add(CD cd) &#123; 	</span></span><br><span class="line"><span class="comment">//		listCD.add(cd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	public void add(DVD dvd) &#123;  </span></span><br><span class="line"><span class="comment">//		listDVD.add(dvd);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item item)</span> &#123;  </span><br><span class="line">		listItem.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;<span class="comment">//列出所有的CD</span></span><br><span class="line"><span class="comment">//		for ( CD cd : listCD ) &#123;</span></span><br><span class="line"><span class="comment">//			cd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		for ( DVD dvd : listDVD) &#123;</span></span><br><span class="line"><span class="comment">//			dvd.print();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">for</span> ( Item item : listItem ) &#123;</span><br><span class="line">			item.print();</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//测试：</span></span><br><span class="line">		<span class="type">Database</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Database</span>();  <span class="comment">//首先要有一个database </span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>)); <span class="comment">//然后就可以往里面add东西了</span></span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;def&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="number">4</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;AAA&quot;</span>, <span class="number">60</span>, <span class="string">&quot;...&quot;</span>));</span><br><span class="line">		db.add(<span class="keyword">new</span> <span class="title class_">VideoGame</span>(<span class="string">&quot;ddd&quot;</span>, <span class="number">10</span>, <span class="literal">true</span>, <span class="string">&quot;...&quot;</span> , <span class="number">4</span>));</span><br><span class="line">		db.list();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> playingTime;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">gotIt</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//根据规则它会有默认的初始值，实际上这里给不给它手动初始化并不重要。</span></span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String title, <span class="type">int</span> playingTime, <span class="type">boolean</span> gotIt, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">		<span class="built_in">this</span>.playingTime = playingTime;</span><br><span class="line">		<span class="built_in">this</span>.gotIt = gotIt;</span><br><span class="line">		<span class="built_in">this</span>.comment = comment;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.print(title);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123; <span class="comment">//extend；CD是一种特殊的Item</span></span><br><span class="line">	<span class="keyword">private</span> String artist;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numofTracks;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CD</span><span class="params">(String title, String artist, <span class="type">int</span> numofTracks, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title, playingTime, <span class="literal">false</span>, comment);</span><br><span class="line"><span class="comment">//		this.title = title;</span></span><br><span class="line">		<span class="built_in">this</span>.artist = artist;</span><br><span class="line">		<span class="built_in">this</span>.numofTracks = numofTracks;</span><br><span class="line"><span class="comment">//		this.playingTime = playingTime;</span></span><br><span class="line"><span class="comment">//		this.comment = comment;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;CD [artist=&quot;</span> + artist + <span class="string">&quot;, numofTracks=&quot;</span> + numofTracks + <span class="string">&quot;, toString()=&quot;</span> + <span class="built_in">super</span>.toString() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="type">CD</span> <span class="variable">cc</span> <span class="operator">=</span> (CD)obj;</span><br><span class="line">		<span class="keyword">return</span> artist.equals(cc.artist);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">CD</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">		<span class="type">CD</span> <span class="variable">cd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CD</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">		cd.print();</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span> + cd;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">		System.out.println(cd.equals(cd1));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	public void print() &#123;</span></span><br><span class="line"><span class="comment">//		// 选择成员变量中一些有意义的东西输出</span></span><br><span class="line"><span class="comment">//		System.out.println(&quot;CD:&quot;+title+&quot;:&quot;+artist);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DVD</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String director;</span><br><span class="line">	<span class="keyword">private</span> String comment;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">DVD</span><span class="params">(String title, String director, <span class="type">int</span> playingTime, String comment)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title, playingTime, <span class="literal">false</span>, comment);</span><br><span class="line">		setTitle(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.director = director;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">DVD</span> <span class="variable">dvd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DVD</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>, <span class="string">&quot;..&quot;</span>);</span><br><span class="line">		dvd.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;DVD:&quot;</span>);</span><br><span class="line">		<span class="built_in">super</span>.print();</span><br><span class="line">		System.out.print(director);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoGame</span> <span class="keyword">extends</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> numberOfPlayers;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">VideoGame</span><span class="params">(String title, <span class="type">int</span> playingTime, <span class="type">boolean</span> gotIt, String comment, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(title, playingTime, gotIt, comment);</span><br><span class="line">		numberOfPlayers = number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;VideoGame&quot;</span>);</span><br><span class="line">		<span class="built_in">super</span>.print();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第5周设计原则"><a href="#第5周设计原则" class="headerlink" title="第5周	设计原则"></a>第5周	设计原则</h2><h3 id="5-1-城堡游戏"><a href="#5-1-城堡游戏" class="headerlink" title="5.1 城堡游戏"></a>5.1 城堡游戏</h3><blockquote>
<p>[!NOTE]</p>
<p>即使类的设计很糟糕，也还是有可能实现一个应用程序，使之运行并完成所需的工作。一个已完成的应用程序能够运行，但并不能表明程序内部的结构是否良好。 当维护程序员想要对一个已有的软件做修改的时候，问题才会浮现出来。比如，程序员试图纠正已有软件的缺陷，或者为其增加一些新的功能。显然，如果类的设计良好，这个任务就 可能很轻松；而如果类的设计很差，那就会变得很困难，要牵扯大量的工作。 在大的应用软件中，这样的情形在最初的实现中就会发生了。如果以不好的结构来实现软 件，那么后面的工作可能变得很复杂，整个程序可能根本无法完成，或者充满缺陷，或者花费 比实际需要多得多的时间才能完成。在现实中，一个公司通常要维护、扩展和销售一个软件很 多年，很可能今天在商店买到的软件，其最初的版本是在十多年前就开始了的。在这种情形下， 任何软件公司都不能忍受不良结构的代码。 既然很多不良设计的效果会在试图调整或扩展软件时明显地展现出来，那么就应该以调整或扩展软件来鉴别和发现这样的不良设计。本周将使用一个叫作城堡游戏的例子，这个例子很简单，基本实现了一个基于字符的探险游戏。起初这个游戏并不十分强大，因为还没全部 完成。不过，在本章结束的时候，你就可以运用你的想像力来设计和实现这个的游戏，让它更 有趣更好玩。</p>
<p>那么，首先，从下边这里下载<code>castle.zip</code>，从这个糟糕的代码开始吧！</p>
</blockquote>
<p>🍎文本游戏介绍</p>
<p>90年代我们读书的时候，那时候有一种计算机上的游戏，在Unix在互联网上玩的纯文字的界面，进去以后给你描述一段场景，然后呢，你可以输命令：往东走、往右走、举起一把铲子、背起一个包……然后文字告诉你现在有什么</p>
<p>我们用Java写了一个来玩玩看。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212114957312.png" alt="image-20250212114957312"></p>
<p>🍎游戏场景和命令</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212115051251.png" alt="image-20250212115051251"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212115133597.png" alt="image-20250212115133597"></p>
<p>🍎代码解析和房间对象</p>
<p>就这么简单一个游戏，我们来看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Room currentRoom;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Game</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        createRooms();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createRooms</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Room outside, lobby, pub, study, bedroom;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//	制造房间</span></span><br><span class="line">        outside = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;城堡外&quot;</span>);</span><br><span class="line">        lobby = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;大堂&quot;</span>);</span><br><span class="line">        pub = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;小酒吧&quot;</span>);</span><br><span class="line">        study = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;书房&quot;</span>);</span><br><span class="line">        bedroom = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;卧室&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//	初始化房间的出口</span></span><br><span class="line">        outside.setExits(<span class="literal">null</span>, lobby, study, pub);</span><br><span class="line">        lobby.setExits(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, outside);</span><br><span class="line">        pub.setExits(<span class="literal">null</span>, outside, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        study.setExits(outside, bedroom, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        bedroom.setExits(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, study);</span><br><span class="line"></span><br><span class="line">        currentRoom = outside;  <span class="comment">//	从城堡门外开始</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printWelcome</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎来到城堡！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个超级无聊的游戏。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如果需要帮助，请输入 &#x27;help&#x27; 。&quot;</span>);</span><br><span class="line">        System.out.println();	<span class="comment">//输出一开始看到的那些东西</span></span><br><span class="line">        System.out.println(<span class="string">&quot;现在你在&quot;</span> + currentRoom);	<span class="comment">//有一个当前房间currentRoom。这里输出了当前房间。（当然我们学过这里肯定用过toString了。）</span></span><br><span class="line">        System.out.print(<span class="string">&quot;出口有：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(currentRoom.northExit != <span class="literal">null</span>) <span class="comment">//如果当前房间的北出口有，就显示一个north（所以在不同的房间你会看到有的是north east，有的是north west……）</span></span><br><span class="line">            System.out.print(<span class="string">&quot;north &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(currentRoom.eastExit != <span class="literal">null</span>)</span><br><span class="line">            System.out.print(<span class="string">&quot;east &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(currentRoom.southExit != <span class="literal">null</span>)</span><br><span class="line">            System.out.print(<span class="string">&quot;south &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(currentRoom.westExit != <span class="literal">null</span>)</span><br><span class="line">            System.out.print(<span class="string">&quot;west &quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为用户命令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printHelp</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;迷路了吗？你可以做的命令有：go bye help&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如：\tgo east&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">goRoom</span><span class="params">(String direction)</span> <span class="comment">//拿第二个参数字符串</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">nextRoom</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(direction.equals(<span class="string">&quot;north&quot;</span>)) &#123;</span><br><span class="line">            nextRoom = currentRoom.northExit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(direction.equals(<span class="string">&quot;east&quot;</span>)) &#123;</span><br><span class="line">            nextRoom = currentRoom.eastExit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(direction.equals(<span class="string">&quot;south&quot;</span>)) &#123;	<span class="comment">//如果输入的字符串是go south</span></span><br><span class="line">            nextRoom = currentRoom.southExit; <span class="comment">//那么nextRoom就是当前Room的southExit——看到这个名字你都能猜出来它是干什么的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(direction.equals(<span class="string">&quot;west&quot;</span>)) &#123;</span><br><span class="line">            nextRoom = currentRoom.westExit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextRoom == <span class="literal">null</span>) &#123;	<span class="comment">//相关测试在【🍎循环和命令处理】的最后</span></span><br><span class="line">            System.out.println(<span class="string">&quot;那里没有门！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//如果有下一个房间</span></span><br><span class="line">            currentRoom = nextRoom;	<span class="comment">//当前房间=nextRoom</span></span><br><span class="line">            <span class="comment">//告诉你你在什么地方，出口有xxxx</span></span><br><span class="line">            System.out.println(<span class="string">&quot;你在&quot;</span> + currentRoom);</span><br><span class="line">            System.out.print(<span class="string">&quot;出口有: &quot;</span>);	</span><br><span class="line">            <span class="keyword">if</span>(currentRoom.northExit != <span class="literal">null</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;north &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currentRoom.eastExit != <span class="literal">null</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;east &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currentRoom.southExit != <span class="literal">null</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;south &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currentRoom.westExit != <span class="literal">null</span>)</span><br><span class="line">                System.out.print(<span class="string">&quot;west &quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//老朋友了</span></span><br><span class="line">		<span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Game</span>();	<span class="comment">//做了一个Game的对象</span></span><br><span class="line">		game.printWelcome();	<span class="comment">//让game来printWelcome</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123; <span class="comment">//一个死循环</span></span><br><span class="line">        		<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine(); <span class="comment">//每次读一句进来</span></span><br><span class="line">        		String[] words = line.split(<span class="string">&quot; &quot;</span>);	<span class="comment">//（入门课程中提到）对一个字符串做split————因为我们输进去的可能是eg【go south】，那么它要根据中间这个空格把它分成两个单词。</span></span><br><span class="line">        		<span class="keyword">if</span> ( words[<span class="number">0</span>].equals(<span class="string">&quot;help&quot;</span>) ) &#123; <span class="comment">//第一个单词如果是help就做这个</span></span><br><span class="line">        			game.printHelp();	<span class="comment">//输出help</span></span><br><span class="line">        		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[<span class="number">0</span>].equals(<span class="string">&quot;go&quot;</span>) ) &#123; <span class="comment">//第一个单词如果是go就做这个</span></span><br><span class="line">        			game.goRoom(words[<span class="number">1</span>]);	<span class="comment">//调用goRoom的函数</span></span><br><span class="line">        		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( words[<span class="number">0</span>].equals(<span class="string">&quot;bye&quot;</span>) ) &#123;	<span class="comment">//第一个单词如果是bye就做这个</span></span><br><span class="line">        			<span class="keyword">break</span>;	<span class="comment">//结束</span></span><br><span class="line">        		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;感谢您的光临。再见！&quot;</span>);</span><br><span class="line">        in.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String description;</span><br><span class="line">    <span class="keyword">public</span> Room northExit;</span><br><span class="line">    <span class="keyword">public</span> Room southExit;</span><br><span class="line">    <span class="keyword">public</span> Room eastExit;</span><br><span class="line">    <span class="keyword">public</span> Room westExit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">(String description)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExits</span><span class="params">(Room north, Room east, Room south, Room west)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(north != <span class="literal">null</span>)</span><br><span class="line">            northExit = north;</span><br><span class="line">        <span class="keyword">if</span>(east != <span class="literal">null</span>)</span><br><span class="line">            eastExit = east;</span><br><span class="line">        <span class="keyword">if</span>(south != <span class="literal">null</span>)</span><br><span class="line">            southExit = south;</span><br><span class="line">        <span class="keyword">if</span>(west != <span class="literal">null</span>)</span><br><span class="line">            westExit = west;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们要理解它的代码，从main开始。</p>
<p>game去做了一个<code>printWelcome</code>，不用那么费劲去找它，可以右键-Open Declaration（打开声明）就到这个函数来了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212115647848.png" alt="image-20250212115647848"></p>
<p><code>printWelcome</code>有一个<code>currentRoom</code>，鼠标停留在上面会提示我们这是一个room对象，也可以右键Open Declaration，于是就跳转到这里，说<code>currentRoom</code>是一个Room：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212115912503.png" alt="image-20250212115912503"></p>
<p>那Room是什么呢？Open Declaration，于是就到了Room这个类，过一会我们再来看Room这个类的事：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212120000595.png" alt="image-20250212120000595"></p>
<p>🍎循环和命令处理</p>
<p>在main函数做完Welcome之后，就会进入一个死循环：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212120350500.png" alt="image-20250212120350500"></p>
<p>其中，如果第一个字符串是go，他会调用一个叫做goRoom的函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212120826547.png" alt="image-20250212120826547"></p>
<p>其中，对于null：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212121054393.png" alt="image-20250212121054393"></p>
<p>🍎问题发现和解决</p>
<p>就这么一个代码，现在请你把这个代码下载下来，仔细的阅读一下这里的两个类，理解一下这里每一行要做&#x2F;发生的事情，然后思考一下这里有什么问题，这些代码存在着什么样的问题？</p>
<p>我们今天要学的要做的所有事情就是去找出这里面的问题，然后去解决这里面的问题。</p>
<blockquote>
<h3 id="请根据castle的代码回答这些问题"><a href="#请根据castle的代码回答这些问题" class="headerlink" title="请根据castle的代码回答这些问题"></a>请根据castle的代码回答这些问题</h3><p>Q：在探究程序的时候,回答以下的问题。</p>
<ol>
<li>这个应用程序的任务是什么?</li>
<li>这个应用程序接受什么样的命令?</li>
<li>每个命令做什么?</li>
<li>在场景中有多少间房?</li>
<li>画出现有的房间的地图。</li>
</ol>
<p> A：</p>
<ol>
<li><p>任务是参观城堡，一开始在城堡外，随后有三个门，根据自己的选择会告诉你每个门后是做什么的房间，每参观完一个房间又会提示你其他选项选择参观，如果原路返回则又回到当前房间</p>
</li>
<li><p>help、bye、go+方向 三种命令；</p>
</li>
<li><p>help 输出一段提示的文字；bye 结束；go+方向 切换到另一个房间</p>
</li>
<li><p>5个</p>
</li>
<li><p>pub →outside←lobby</p>
<p>​      ↑</p>
<p>​      study ← bedroom</p>
</li>
</ol>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212121804649.png" alt="image-20250212121804649"></p>
</blockquote>
<blockquote>
<h3 id="这个castle程序有什么问题？"><a href="#这个castle程序有什么问题？" class="headerlink" title="这个castle程序有什么问题？"></a>这个castle程序有什么问题？</h3><p>Q：来来来，先批判一下这个程序。</p>
<p>A：好多作用基本相同的代码，重复率高，显得很笨重</p>
</blockquote>
<h3 id="5-2-消除代码复制"><a href="#5-2-消除代码复制" class="headerlink" title="5.2 消除代码复制"></a>5.2 消除代码复制</h3><blockquote>
<p>[!NOTE]</p>
<p><strong>代码复制</strong></p>
<p>程序中存在相似甚至相同的代码块，是非常低级的代码质量问题。</p>
<p>代码复制存在的问题是，如果需要修改一个副本，那么就必须同时修改所有其他的副本，否则就存在不一致的问题。这增加了维护程序员的工作量，而且存在造成错误的潜在危险。很可能发生的一种情况是，维护程序员看到一个副本被修改好了，就以为所有要修改的地方都已经改好了。因为没有任何明显迹象可以表明另外还有一份一样的副本代码存在，所以很可能会遗漏还没被修改的地方。</p>
<p>我们从消除代码复制开始。消除代码复制的两个基本手段，就是函数和父类。</p>
</blockquote>
<p>这个程序其实问题是非常多的，这里面暴露出来的问题正好就是我们今天要说的在面向对象程序设计当中的一些非常基本的原则。原则第一条其实我们之前见过的，就是<strong>代码复制</strong>。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212122059919.png" alt="image-20250212122059919"></p>
<p>这个程序当中有非常明显的代码复制，在哪呢？这是我们前面看到的Welcome：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212122157047.png" alt="image-20250212122157047"></p>
<p>这是<code>goRoom</code>，当我们选择了要去某一个房间的时候：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212122235179.png" alt="image-20250212122235179"></p>
<p>这就是非常明显的代码复制，所以修改的方案也非常的简单——我们可以把这一段提取出来，把这段作为是进入到一个房间以后给玩家看的那么一段提示。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/12313.png" alt="12313"></p>
<p>前面的部分也是一样换成这个函数调用。</p>
<p>这是我们做的第一个，除了这个之外，这个程序还有上面问题呢？再仔细想想。</p>
<blockquote>
<p><strong>设计你自己的游戏</strong><br>Q：脱离计算机设计你自己的游戏场景,不要考虑如何实现和类,甚至不要去想编</p>
<p>程,就是考虑发明一个有趣的游戏。可以和一个团队一起来做这个设计。</p>
<p>游戏的基础结构是一个玩家在不同的地方移动,基于此,这个游戏可以是任何东西。以</p>
<p>下是一些例子。</p>
<p>你是一个白血球,在体内游历,寻找病毒以发起攻击⋯⋯</p>
<p>你在一个购物中心迷路了,需要找到出口⋯⋯</p>
<p>你是一只地洞里的鼹鼠,冬天来临前忘记了自己把粮食藏到哪里了⋯⋯</p>
<p>你是一个探险家,在一个充满野兽和其他怪物的地牢里搜索⋯⋯</p>
<p>你来自一个拆弹小组,必须在炸弹爆炸之前找到炸弹并且解除威胁⋯⋯</p>
<p>​			</p>
<p>游戏一定要有一个目标(这样它才能有个结束的地方,而玩家也才能“赢”)。努力</p>
<p>想很多东西来使得你的游戏有趣(有陷阱的门、有魔力的东西、只有给食吃才肯帮助你</p>
<p>的角色、时间限制、你喜欢的任何东西等),充分发挥你的想像吧。</p>
<p>在这个时候,别担心如何来实现这些事情。</p>
<p>A：《小兔子在地下城堡建家》</p>
<p>可以随机进入一个房间，进入之前并不知道是否已经有小动物居住，进去后，可能出现以下情况：</p>
<p>有动物已居住，那么就换一间查看；</p>
<p>没有小动物居住，那么考虑房间大小是否合适，如果不合适，继续寻找，如果合适，则居住下来，游戏进入下一阶段；</p>
<p>有小动作居住的房间，通过与小动物交谈可能获得其他已经被居住的房间的信息；</p>
<p>房间大小不一，小的房间不适合兔子居住；</p>
<p>一定至少有一间适合小兔子居住的房间；</p>
<p>一旦确定居住的房间，则本阶段结束。</p>
</blockquote>
<h3 id="5-3-封装"><a href="#5-3-封装" class="headerlink" title="5.3 封装"></a>5.3 封装</h3><blockquote>
<p>[!NOTE]</p>
<p>要评判某些设计比其他的设计优秀，就得定义一些在类的设计中重要的术语，以用来讨论 设计的优劣。对于类的设计来说，有两个核心术语：耦合和聚合。 耦合这个词指的是类和类之间的联系。之前的章节中提到过，程序设计的目标是一系列通 过定义明确的接口通信来协同工作的类。耦合度反映了这些类联系的紧密度。我们努力要获得低的耦合度，或者叫作松耦合（loose coupling）。</p>
<p>耦合度决定修改应用程序的容易程度。在一个紧耦合的结构中，对一个类的修改也会导致 对其他一些类的修改。这是要努力避免的，否则，一点小小的改变就可能使整个应用程序发生 改变。另外，要想找到所有需要修改的地方，并一一加以修改，却是一件既困难又费时的事情。 另一方面，在一个松耦合的系统中，常常可以修改一个类，但同时不会修改其他类，而且 整个程序还可以正常运作。</p>
<p>本周会讨论紧耦合和松耦合的例子。 聚合与程序中一个单独的单元所承担的任务的数量和种类相对应有关，它是针对类或方法 这样大小的程序单元而言的理想情况下，一个代码单元应该负责一个聚合的任务（也就是说，一个任务可以被看作是 一个逻辑单元）。一个方法应该实现一个逻辑操作，而一个类应该代表一定类型的实体。聚合 理论背后的要点是重用：如果一个方法或类是只负责一件定义明确的事情，那么就很有可能在 另外不同的上下文环境中使用。遵循这个理论的一个额外的好处是，当程序某部分的代码需要 改变时，在某个代码单元中很可能会找到所有需要改变的相关代码段。</p>
</blockquote>
<p>🍎代码质量评价标准</p>
<p>我们的这个城堡游戏的代码是能运行的，一切功能都正常，也没有发现有bug。</p>
<p>但是，<strong>一个能够正常运行的没有bug的代码不等于它就是一个好的代码</strong>。</p>
<p>评价一个代码是否好，标准是多元的——并不是只有一个没有bug、能运行，我们还有很多标准。尤其是这个代码是否适应于<strong>将来的需要</strong>。</p>
<p>什么叫做将来的需要？将来只有一种需要——就是<strong>维护</strong>。代码写出来不是跑一次，不是现在用用就好了，你要考虑它一年以后、两年以后、五年以后、甚至十年以后，这个代码还要有其他人要继续做下去（当然也可能是你自己）。需求有了变更、要进一步发展下去了，这个时候你拿之前写的那个代码怎么办呢？</p>
<p>你的代码是不是还要在今后起作用、是不是让今后做维护的人（无论是你还是其他人）能够比较容易的在这个代码基础上做事情？——这是我们去考察一个代码质量非常重要的一个原则&#x2F;指标。</p>
<p>🍎代码可扩展性</p>
<p>就是——你是不是适合于扩展。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212144756404.png" alt="image-20250212144756404"></p>
<p>比如说，我们现在在这个代码的基础上，如果我们想要给它增加新的方向怎么办呢？</p>
<p>我们现在有东南西北四个方向，对于城堡来说它可能有好几层楼，那么如果我们想要增加up down这两个方向，我们要这么做呢？</p>
<p>我们现在的城堡的方向在什么地方体现出来？你看，对于Room来说，它有四个成员变量，这四个成员变量是别的Room（北南东西）。：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212145214323.png" alt="image-20250212145214323"></p>
<p>在构造它的时候我们给了一个描述字符串就算了。但我们后面有一个<code>setExits</code>（设每一个房间的出口），在设这个出口的时候要给出四个方向其他Room的变量，然后才能把四个变量初始化出来。</p>
<p>不光是这样子，这个代码问题挺大的，不光在Room里头，在Game里头：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212145454869.png" alt="image-20250212145454869"></p>
<p><code>eg</code>：这个<code>goRoom</code>里头，我们会要用到当前房间的四个出口，我们在显示提示符（到了一个房间要显示它的信息，<code>showPrompt</code>函数）的时候，也要用到它的出口的信息——我们在很多地方用到了这个出口信息。甚至我们在初始化这个房间场景的时候我们是去做了五个房间出来，然后呢，每一个房间去设了它出口的房间。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212145734381.png" alt="image-20250212145734381"></p>
<p>——那么如果我增加了，所有以上这些地方都要改。</p>
<p>你增加了一个上（up）的方向，在这个程序里面几乎是<strong>所有</strong>的地方都要被你改掉，动静很大，那么这种代码的设计就是一种不良的体现。你的代码没有可扩展性。</p>
<p>🍎降低耦合性</p>
<p>我们在这个课程里面已经讲第二遍了，可扩展性的意思是说：将来有什么新的东西要加进来的时候，你的那些代码是不是可以<strong>很大程度上保持不变</strong>。以不变来应对将来的万变。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212150154736.png" alt="image-20250212150154736"></p>
<p>要实现这里的可扩展性，我们要做的事情还不止是一个，有很多的事情要做，我们得一步步来。</p>
<p>首先要考虑的第一件事情是：Room类和Game类紧密的结合在一起——我要增加一个出口，不仅是Room类要增加一些东西，在Game里头也要增加一些东西。-&gt;它们的耦合非常紧。</p>
<p><strong>耦合</strong>指的是：类和类之间的关系。</p>
<p>正好这几天在我们课程的讨论区里有同学提到了这件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212150446033.png" alt="image-20250212150446033"></p>
<p>——没错，我们要的就是低耦合。</p>
<p>类和类的关系越松越好，不要这么紧紧的咬在一起。<strong>保持距离很重要</strong>。</p>
<p>对象和对象之间、类和类之间尽量的保持距离，对彼此的认识越浅越好。</p>
<p>从Room来看，我们的成员变量全部是public的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212150657556.png" alt="image-20250212150657556"></p>
<p>——我们在一开始讲类的设计的时候，其实提到过一种基本原则：你应该不管怎么样首先想到的是<strong>让你的所有的成员变量都是私有的private，万不得已的时候才去做public</strong>。</p>
<p>现在的结果就是，在Game里我们不断的在使用这些Room的东西。</p>
<p>我们先来做这第一件事情——设法让他们耦合松一点。我们把Room里是所有public的成员变量都改成private的。</p>
<p>接下来Game就爆了一大堆的错误。怎么改？</p>
<p>有人说，那这样好不好：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212151134595.png" alt="image-20250212151134595"></p>
<p>那我干脆用一个函数来返回这些成员变量——这样好吗？做完了这些之后，Game的所有调用都变成了<code>Room.getNorth()</code>。</p>
<p>这不对，表面上看，对啊，我的成员变量都是私有的啦，然后我给你一些接口（函数），你通过这些接口就能得到那些变量的值。——这不是真正的OOP的解决方案，这是一种无可奈何的过渡方案。真正的方案是什么？</p>
<p>你想对Room来说，它为什么要拿到你那个<code>northExit</code>？</p>
<p>1）对于<code>ShowPrompt</code>来说：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212151515725.png" alt="image-20250212151515725" style="zoom:67%;" />

<p>我需要知道你有north出口，那么我给你显示一个north——**可是为什么要由Game来知道呢？**为什么不是Room增加告诉Game，我有一些什么出口不就行了吗？</p>
<p>所以在这里我们要做的事情并不是设一个<code>getNorth</code>这样的函数，把<code>northExit</code>这个成员变量之间铺给外面，而是应该<strong>根据</strong>外界（也就是Game）<strong>对</strong>Room<strong>的实际需要，让</strong>Room<strong>自己来做一些有意义的劳动。</strong></p>
<p>而不是直接就把自己里面的心肝肺都拿出来了。</p>
<p>🍎解决扩展性问题</p>
<p>所以我们这样来干：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">    </span><br><span class="line">   	<span class="comment">//降低耦合度1：需要一个对房间描述的东西。</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExitDesc</span><span class="params">()</span> &#123;	<span class="comment">//它可以返回一个表达现在有什么房间的字符串</span></span><br><span class="line">    	<span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> ( northExit != <span class="literal">null</span>)</span><br><span class="line">    		ret += <span class="string">&quot;north &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> ( southExit != <span class="literal">null</span>)</span><br><span class="line">    		ret += <span class="string">&quot;south &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> ( eastExit != <span class="literal">null</span>)</span><br><span class="line">    		ret += <span class="string">&quot;east &quot;</span>;</span><br><span class="line">    	<span class="keyword">if</span> ( westExit != <span class="literal">null</span>)</span><br><span class="line">    		ret += <span class="string">&quot;west &quot;</span>;</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们这个代码还是有问题的，我们一般的不会用String类型的变量来做这样的加加加加的操作，因为如果这样做的话，系统<strong>开销很大</strong></p>
<p>——理由主要是我们在入门课程中提到过，String是一个immutable（译为”不可改变的”，是一种<strong>持久化数据</strong>。它有<strong>一旦被创建就不会被修改</strong>的特性）的对象。就是String这种类型的对象你没有任何办法去对它做修改，所以我们做<code>ret += &quot;north &quot;;</code>的时候，每一次都会产生一个新的String类型的对象，那么系统开销就会很大。</p>
<p>我们会用另一种东西，叫做<code>StringBuffer</code>——可以不断修改的一种对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降低耦合度1：需要一个对房间描述的东西。</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExitDesc</span><span class="params">()</span> &#123;	<span class="comment">//它可以返回一个表达现在有什么房间的字符串</span></span><br><span class="line">    	<span class="comment">// 改用StringBuffer而非String来减少系统开销。</span></span><br><span class="line">    	<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();	</span><br><span class="line">    	<span class="keyword">if</span> ( northExit != <span class="literal">null</span>)</span><br><span class="line">    		sb.append(<span class="string">&quot;north &quot;</span>);</span><br><span class="line">    	<span class="keyword">if</span> ( southExit != <span class="literal">null</span>)</span><br><span class="line">    		sb.append(<span class="string">&quot;south &quot;</span>);</span><br><span class="line">    	<span class="keyword">if</span> ( eastExit != <span class="literal">null</span>)</span><br><span class="line">    		sb.append(<span class="string">&quot;east &quot;</span>);</span><br><span class="line">    	<span class="keyword">if</span> ( westExit != <span class="literal">null</span>)</span><br><span class="line">    		sb.append(<span class="string">&quot;west &quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以通常我们需要采用很多复杂的字符串的操作去产生一个结果字符串的时候，我们都会用<code>StringBuffer</code>而不用String。</p>
<p>这样就解开耦合了：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212153905249.png" alt="image-20250212153905249" style="zoom:67%;" />

<p>2）对于<code>goRoom</code>来说：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212154016211.png" alt="image-20250212154016211" style="zoom:67%;" />

<p>我们要从那个Room那边得到：那个方向上面有没有东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降低耦合度2：从那个Room那边得到这个方向上面有没有东西</span></span><br><span class="line">    <span class="comment">//根据这个字符串direction决定：返回一个什么Room。</span></span><br><span class="line">    <span class="keyword">public</span> Room <span class="title function_">getExit</span><span class="params">(String direction)</span> &#123;	</span><br><span class="line">    	<span class="type">Room</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    	<span class="comment">// 把原本的代码拿过来改改变量名即可。</span></span><br><span class="line">    	<span class="keyword">if</span>(direction.equals(<span class="string">&quot;north&quot;</span>)) &#123;</span><br><span class="line">            ret = northExit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(direction.equals(<span class="string">&quot;east&quot;</span>)) &#123;</span><br><span class="line">            ret = eastExit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(direction.equals(<span class="string">&quot;south&quot;</span>)) &#123;</span><br><span class="line">            ret = southExit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(direction.equals(<span class="string">&quot;west&quot;</span>)) &#123;</span><br><span class="line">            ret = westExit;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样所有的错误就都没有了：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212154726785.png" alt="image-20250212154726785" style="zoom:67%;" />

<p>现在Game和Room之间就松了很多——Game不再会去直接用到Room的任何成员变量了，Room所有的成员变量都已经是私有的了。</p>
<p>我们实现了两个接口来帮助Game和Room之间的解耦合。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212154911721.png" alt="image-20250212154911721"></p>
<p>这是我们做的第一件事情，用封装来降低耦合。但是我们还没有解决我们的扩展性问题——我们要增加up增加down到底该怎么做才是最合适的呢？</p>
<h3 id="5-4-可扩展性"><a href="#5-4-可扩展性" class="headerlink" title="5.4 可扩展性"></a>5.4 可扩展性</h3><blockquote>
<p>[!NOTE]</p>
<p><strong>扩展</strong></p>
<p>我们已经实现的设计与其原始版本比较已经有了很大的改进，然而还可以有进一步的提高。 优秀的软件设计者的一个素质就是有预见性。什么是可能会改变的？什么是可以假设在软件的生命期内不会改变的？在游戏的很多类中硬编码进去的一个假设是，这个游戏会是一个基于字符界面的游戏，通过终端进行输入输出，会永远是这样子吗？ 以后如果给这个游戏加上图形用户界面，加上菜单、按钮和图像，也是很有意思的一种扩展。如果这样的话，就不必再在终端上打印输出任何文字信息。还是可能保留着命令字，还是会在玩家输入帮助命令的时候显示命令字帮助文本，但是可能是显示在窗口的文字域中，而不是使用<code>System.out.println</code>？</p>
<p>可扩展性的意思就是代码的某些部分不需要经过修改就能适应将来可能的变化。</p>
</blockquote>
<p>🍎封装降低耦合</p>
<p>通过封装降低了耦合之后，虽然我们还没有直接实现怎么加入新的方向，但是我们为将来加入新的方向打下了一个非常好的基础。</p>
<p>为什么这么说呢？因为原本Room里面的细节是直接曝光给Game的，Game是直接使用Room里面的那四个成员变量来掌握它每个方向的出口。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212203028649.png" alt="image-20250212203028649"></p>
<p>现在呢，我们把这些成员变量都做成私有了，提供了两个接口：一个接口给出文字描述，一个接口可以根据方向来返回在那个出口方向对应的房间。</p>
<p>有了这两个接口，对于外界（Room以外的其他地方）来说，Room内部如何去表达每一个出口，如何去建立起出口方向的那个字符串和它在那个出口方向上面的对应房间的关系。——Room就可以调整了。</p>
<p>🍎使用容器表达方向</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212203421347.png" alt="image-20250212203421347"></p>
<p>我们现在在Room里面是用四个成员变量来表达四个方向上对应的房间的，如果希望做到尽可能的灵活性，我们就不应该这样<strong>硬编码</strong>。——我们就应该采用容器来表达每一个方向上对应的那个房间，这样一来，方向和Room本身没有关系了。这不是硬编码的，我可以任意往里面增加新的方向。</p>
<p>——对于Room的成员变量，我们不应该有这样的四个东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room其他的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Room&gt; exits = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Room&gt;();</span><br><span class="line"><span class="comment">//    private Room northExit;</span></span><br><span class="line"><span class="comment">//    private Room southExit;</span></span><br><span class="line"><span class="comment">//    private Room eastExit;</span></span><br><span class="line"><span class="comment">//    private Room westExit;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当然Room里有很多地方都不对了，我们就相应的进行调整：</p>
<p>1）设出口 的时候我们就不用这样设了，不是一次性把东南西北都给你，我给你一个字符串表明说这个方向是那个房间，于是你就帮我设好。——所以我们需要的是另外一个接口，叫做<code>setExit</code>（没有s是因为这是设单个）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新接口：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExit</span><span class="params">(String dir, Room room)</span> &#123;	<span class="comment">//设出口。没有s是因为这是设单个</span></span><br><span class="line">    <span class="comment">//做的事情非常简单，在exits里面put direction和room进去即可</span></span><br><span class="line">    exits.put(dir, room);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原版：</span></span><br><span class="line"><span class="comment">//    public void setExits(Room north, Room east, Room south, Room west) </span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        if(north != null)</span></span><br><span class="line"><span class="comment">//            northExit = north;</span></span><br><span class="line"><span class="comment">//        if(east != null)</span></span><br><span class="line"><span class="comment">//            eastExit = east;</span></span><br><span class="line"><span class="comment">//        if(south != null)</span></span><br><span class="line"><span class="comment">//            southExit = south;</span></span><br><span class="line"><span class="comment">//        if(west != null)</span></span><br><span class="line"><span class="comment">//            westExit = west;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当然，对应的，在Game里面使用原来用这个<code>setExits</code>去做的事情，我们要调整为<code>setExit</code>。</p>
<p>2）描述：描述就变成是说，我们要从这个<code>HashMap</code>里面拿出所有的key，因为这些key就是房间出口的名字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降低耦合度1：需要一个对房间描述的东西。</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExitDesc</span><span class="params">()</span> &#123;	<span class="comment">//它可以返回一个表达现在有什么房间的字符串</span></span><br><span class="line">    	<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();	<span class="comment">// 5.3封装-改用StringBuffer而非String来减少系统开销。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新版：</span></span><br><span class="line">    	<span class="keyword">for</span> (String dir : exits.keySet() ) &#123;	<span class="comment">//对于出口exits的keySet，拿到每一个key</span></span><br><span class="line">    		sb.append(dir);	<span class="comment">//把存储在dir里的key加进去</span></span><br><span class="line">    		sb.append(<span class="string">&#x27; &#x27;</span>);	<span class="comment">//还需要加一个空格</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">//原版：</span></span><br><span class="line"><span class="comment">//    	if ( northExit != null)</span></span><br><span class="line"><span class="comment">//    		sb.append(&quot;north &quot;);</span></span><br><span class="line"><span class="comment">//    	if ( southExit != null)</span></span><br><span class="line"><span class="comment">//    		sb.append(&quot;south &quot;);</span></span><br><span class="line"><span class="comment">//    	if ( eastExit != null)</span></span><br><span class="line"><span class="comment">//    		sb.append(&quot;east &quot;);</span></span><br><span class="line"><span class="comment">//    	if ( westExit != null)</span></span><br><span class="line">    		sb.append(<span class="string">&quot;west &quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在<code>getExit</code>的时候，这事好像就变得跟简单了，直接从容器里面拿到那个东西就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降低耦合度2：从那个Room那边得到这个方向上面有没有东西</span></span><br><span class="line">    <span class="comment">//根据这个字符串direction决定：返回一个什么Room。</span></span><br><span class="line">    <span class="keyword">public</span> Room <span class="title function_">getExit</span><span class="params">(String direction)</span> &#123;	</span><br><span class="line">    	<span class="type">Room</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//新版：</span></span><br><span class="line">    	ret = exits.get(direction);</span><br><span class="line">        <span class="comment">// 以上两行甚至可以精简为：Room ret = exits.get(direction); ，初始化也不需要用了</span></span><br><span class="line">        <span class="comment">//原版：</span></span><br><span class="line"><span class="comment">//    	if(direction.equals(&quot;north&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//            ret = northExit;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(direction.equals(&quot;east&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//            ret = eastExit;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(direction.equals(&quot;south&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//            ret = southExit;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if(direction.equals(&quot;west&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//            ret = westExit;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至以上函数可以直接精简为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...原本Room的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降低耦合度2：从那个Room那边得到这个方向上面有没有东西</span></span><br><span class="line">    <span class="comment">//根据这个字符串direction决定：返回一个什么Room。</span></span><br><span class="line">    <span class="keyword">public</span> Room <span class="title function_">getExit</span><span class="params">(String direction)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exits.get(direction);</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🍎维持恰当接口</p>
<p>如果精简成这样可能会有疑问说：像这样一个函数还有必要存在吗？</p>
<p>且慢，我们的原则是什么？</p>
<p>——<strong>封装</strong>。保持恰当的接口。我现在是用这个方式的，你怎么知道我将来不会换别的方式呢？</p>
<p>我有<code>getExit</code>接口，只要维持这个接口不变里头我可以根据各种情况来选择恰当的方式。所以我们要维持这个接口。</p>
<p>然后对于Game来说，这段代码是唯一收到影响的代码：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212211014352.png" alt="image-20250212211014352"></p>
<p>——因为我们刚才做了接口了，所以<code>showPrompt</code>和<code>goRoom</code>不用做任何调整。因为这两个接口（在5.3实现的两个接口）没变，虽然内部变了，接口没变。</p>
<p>这里出错误是因为我们接口变了——我们原来是<code>setExits</code>的，现在我们变成要一个一个去设了。</p>
<p>🍎可扩展性</p>
<p>那么这里我们要做调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	初始化房间的出口</span></span><br><span class="line">      outside.setExit(<span class="string">&quot;east&quot;</span>, lobby);</span><br><span class="line">      outside.setExit(<span class="string">&quot;south&quot;</span>, study);</span><br><span class="line">      outside.setExit(<span class="string">&quot;west&quot;</span>, pub);</span><br><span class="line">      lobby.setExit(<span class="string">&quot;west&quot;</span>, outside);</span><br><span class="line">      pub.setExit(<span class="string">&quot;east&quot;</span>, outside);</span><br><span class="line">      study.setExit(<span class="string">&quot;north&quot;</span>, outside);</span><br><span class="line">      study.setExit(<span class="string">&quot;east&quot;</span>, bedroom);</span><br><span class="line">      bedroom.setExit(<span class="string">&quot;west&quot;</span>, study);</span><br></pre></td></tr></table></figure>

<p>在这基础上如果我们想要做up，<code>eg</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212211829775.png" alt="image-20250212211829775"></p>
<p>测试一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212211908567.png" alt="image-20250212211908567"></p>
<p>这样up和down的加入，和Room就没有任何关系了：我们只要在外面给它恰当的字符串和恰当的和Room之间的关系，就能把这个事情建起来。</p>
<p>因此，这个Room它就对于出口体现出了可扩展性。</p>
<h3 id="5-5-框架加数据"><a href="#5-5-框架加数据" class="headerlink" title="5.5 框架加数据"></a>5.5 框架加数据</h3><blockquote>
<p>[!NOTE]</p>
<p>框架和数据</p>
<p>从程序中识别出框架和数据，以代码实现框架，将部分功能以数据的方式加载，这样能在很大程度上实现可扩展性。</p>
</blockquote>
<p>🍎改造成框架</p>
<p>我们对Room做了改造，我们把出口从原来以成员变量做硬编码，变成了用容器、用Hash表——这给我们一个启发，原本我们是硬编码的东西，我们把它做成框架了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212220410133.png" alt="image-20250212220410133"></p>
<p>在Room里有一个框架，这个框架表明说：我建立一个数据结构，这个数据结构是名字和对应的那个地方的房间之间的一个对应关系。实现了这样一个框架之后（当然围绕这个框架不仅仅是<code>HashMap</code>，我们还要那些接口（<code>eg</code>:<code>discribe</code>、<code>getexit</code>这些接口函数）。</p>
<p>这些东西形成了一个框架，在这个框架里头如果要增加新的出口很容易。——所以这是一种思路，就是<strong>把程序的硬编码尽可能的解成框架和数据的结构</strong>。</p>
<p>🍎<code>hashmap</code>和函数接口</p>
<p>框架就是：我们有那么一个<code>HashMap</code>，我们有这样几个接口函数。</p>
<p>数据就是：我们放在这个<code>HashMap</code>里面的东西。</p>
<p>在这个程序还有一个地方是硬编码的：就是我们的命令解析。我们现在有三个命令（go、help、bye），这个代码出现在这里：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212221049617.png" alt="image-20250212221049617"></p>
<p>——我们在Game里有一个循环，用if-else来判断这个命令是哪一种。</p>
<p>这是一种硬编码，它能不能被变成框架？</p>
<p>我们知道，字符串对应一个什么东西，这事情<code>HashMap</code>能做，但是对应什么？我们这里要对应的好像是函数是吧？（输入go的时候去调用什么函数，输入help的时候去调另外一个什么函数…）这个函数怎么能够变成在<code>HashMap</code>里面能够放的东西呢？</p>
<p><code>HashMap</code>放的是一个key和一个value，key和value都必须是对象，而函数不是对象。可是类里头有函数是不是？</p>
<p>我们能不能做这样的事情？我们定义一个叫做Handler的类，这个类里有一个public的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hander</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先把它定义成这个样子，当然对应这个Hander来说它什么都不做，它只是提供一个基础，接下来我们会要有：比如说做help的handler、比如说做go的handler和做buy的handle。</p>
<p>但buy有一定的特殊性，我们可以以特殊的方法来处理。</p>
<p>如果我们把它定义成这个样子，接下来我们需要做的事情是：我们需要在Game里面有一个数据结构，它保存了字符串和handler的对象之间的那么一个对应关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;String, Handler&gt; handlers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Handler&gt;();</span><br></pre></td></tr></table></figure>

<p>🍎特殊处理bye命令</p>
<p>那么在Game构造的时候，我们需要给它（handlers）填进去。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212222330606.png" alt="image-20250212222330606"></p>
<p>——实际上是我们要构造一个叫做<code>HandlerGo</code>的对象出来，把它放进<code>HashMap</code>里去。</p>
<p>当然现在我们还没有做这么一个<code>HandlerGo</code>的类出来。这一次我们需要把<code>HandlerGo</code>这个类定义出来，它要做的事情是能够对Game去做点操作。这里面会牵扯到比较复杂的<code>HandlerGo</code>这个类和Game这个类之间的关系，今天呢，我们先来看一种方案，过几周呢，我们还有另外的一种方案。</p>
<p>在这之前我们还要做一件事情，我们需要把下图中的循环和<code>Scanner in = new Scanner(System.in);</code>（第80行）给它放到Game里头去：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212223104048.png" alt="image-20250212223104048"></p>
<p>我们需要有一个叫做run或者play的函数：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212223234166.png" alt="image-20250212223234166" style="zoom:67%;" />

<p>做了这一系列改动的目的是什么呢？因为我们在第84行后要用到我们的这个handlers。我们要去用它get这个word的零，得到了一个handler：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212224147338.png" alt="image-20250212224147338"></p>
<p>现在我们有两个问题没有解决：第一个问题是那个bye怎么办？</p>
<p>我们显然是需要让这个handler在读command之后，如果这个handler是bye那个handler，它能够给我们一个bye。</p>
<p>1）一种方案是ok，我们在handler前面再来个特殊的判断，如果word[0]的equals是bye的话，我们怎么怎么样：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212224437983.png" alt="image-20250212224437983" style="zoom:67%;" />

<p>——但是这样的话我们就增加了例外，我们希望一切都能够在框架内完成的话，也许我们就需要这个hander有一个特殊的东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212224836606.png" alt="image-20250212224836606"></p>
<p>——如果这个handler能够告诉我们说<code>isBye</code>&#x2F;<code>isExit</code>，那么我们再来break。所以handler需要有另外一个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBye</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以我们需要有一个类叫<code>HandlerBye</code>（Handler的子类），它需要返回一个true，来告诉别人说这是bye：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerBye</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBye</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么在Game这边，如果这个Handler是一个Bye Handler，我们就得到了这个bye的消息。所以我们现在这个地方先放一个bye的handler。先不放go，因为go我们没解决：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212231410647.png" alt="image-20250212231410647"></p>
<p>另外呢我们在这里也不能之间使用words[1]，因为我们如果使用了比如说bye这种命令，它是没有words[1]的。上面我们用不到所以不会出现这种问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">	<span class="comment">// ...原本Game的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;	<span class="comment">//或者叫做run</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    	<span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    		<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">    		String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    		<span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> handlers.get(words[<span class="number">0</span>]);</span><br><span class="line">    		<span class="comment">//没有words[1]的情况：</span></span><br><span class="line">    		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    		<span class="keyword">if</span> ( words.length &gt; <span class="number">1</span>)</span><br><span class="line">    			value = words[<span class="number">1</span>];</span><br><span class="line">    		<span class="comment">//新版实现：</span></span><br><span class="line">    		<span class="keyword">if</span> ( handler != <span class="literal">null</span> ) &#123; <span class="comment">//handler不是null，说明这是一个有效的命令。</span></span><br><span class="line">    			handler.doCmd(value);	<span class="comment">//解决没有words[1]的情况</span></span><br><span class="line"><span class="comment">//    			handler.doCmd(word[1]);	//让handle做doCmd，给它word[1]就可以了。</span></span><br><span class="line">    			<span class="keyword">if</span> ( handler.isBye() ) <span class="comment">//或isExit</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">            <span class="comment">//原版实现：以下就可以都没有了</span></span><br><span class="line"><span class="comment">//    		if ( words[0].equals(&quot;help&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">//    			printHelp();</span></span><br><span class="line"><span class="comment">//    		&#125; else if (words[0].equals(&quot;go&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">//    			goRoom(words[1]);</span></span><br><span class="line"><span class="comment">//    		&#125; else if ( words[0].equals(&quot;bye&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">//    			break;</span></span><br><span class="line"><span class="comment">//    		&#125;</span></span><br><span class="line">    	&#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">		game.printWelcome();</span><br><span class="line">		game.play();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;感谢您的光临。再见！&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下，bye是正常的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212232119339.png" alt="image-20250212232119339"></p>
<p>🍎添加help命令</p>
<p>所以我们需要有help：对于help来说，我们需要有一个<code>doCmd</code>，而这个<code>doCmd</code>做什么事呢？原来在Game里有一段这个，我们把这个给抄过来，然后Game里这个函数就可以不存在了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212232333699.png" alt="image-20250212232333699"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerHelp</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">	<span class="comment">// 以下为用户命令</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;迷路了吗？你可以做的命令有：go bye help&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如：\tgo east&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要让help起作用，我们需要在构造的时候放那个help进去，</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212232600854.png" alt="image-20250212232600854"></p>
<p>测试一下，help也出来了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212232629910.png" alt="image-20250212232629910"></p>
<p>🍎可扩展性</p>
<p>那么go这么做？go的地方问题在哪呢？你想，如果我们把go写出来了，当然我们要去实现它的<code>doCmd</code>，<code>doCmd</code>拿到了一个word，我们要拿那个word去go——那怎么go呢？go不是在Handler里go的。因为原来bye很简单，is bye返回一个true就可以了；help也很简单，输出一段话就可以了，跟别人都没关系。go呢？</p>
<p>go要做的事情其实在Game里头，是Game的那个<code>goRoom</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212233440918.png" alt="image-20250212233440918"></p>
<p>就是如果你有办法拿到一个指向Game的指针，<code>eg</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212233524529.png" alt="image-20250212233524529"></p>
<p>——也可以嘛。但是，这个game在哪？你怎么能够拿到那个game的对象？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212233649745.png" alt="image-20250212233649745"></p>
<p>方法是这样的：在几周之后，我们会提到另外一个更好的方法，现在在讲那个东西之前，我们只能用一些比较曲折的办法：</p>
<p>我们可以在Handler构造的时候，让他记下那个Game。也就是说我们的handler里面有一个Game的对象（Game对象的管理者）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> Game game;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Game game)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.game = game;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBye</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么其实它的每一个子类都需要实现那么一个带有Game的构造函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212234123588.png" alt="image-20250212234123588"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerGo</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HandlerGo</span><span class="params">(Game game)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(game);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;</span><br><span class="line">		game.goRoom(word);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就好了。</p>
<p>还有一个问题，构造的时候要把this交过去：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212234402077.png" alt="image-20250212234402077"></p>
<p>OK，我们所有的的叉叉都消除了，测试一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250212234438600.png" alt="image-20250212234438600"></p>
<p>OK，它能够go了。</p>
<p>做完这个之后，我们的这个代码今后如果想要增加新的命令，我们要做的事情只要两个地方：第一，要有新的handler类型；第二，要在Game的构造器里头要把新的Handler放进去。然后下面在play的地方的代码不需要做任何的改动——这段代码对于任何新的命令都是不变的——这就是可扩展性。</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Room currentRoom;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Handler&gt; handlers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Handler&gt;();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Game</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">    	handlers.put(<span class="string">&quot;bye&quot;</span>, <span class="keyword">new</span> <span class="title class_">HandlerBye</span>(<span class="built_in">this</span>));</span><br><span class="line">    	handlers.put(<span class="string">&quot;help&quot;</span>, <span class="keyword">new</span> <span class="title class_">HandlerHelp</span>(<span class="built_in">this</span>));</span><br><span class="line">    	handlers.put(<span class="string">&quot;go&quot;</span>, <span class="keyword">new</span> <span class="title class_">HandlerGo</span>(<span class="built_in">this</span>));</span><br><span class="line">        createRooms();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createRooms</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Room outside, lobby, pub, study, bedroom;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//	制造房间</span></span><br><span class="line">        outside = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;城堡外&quot;</span>);</span><br><span class="line">        lobby = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;大堂&quot;</span>);</span><br><span class="line">        pub = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;小酒吧&quot;</span>);</span><br><span class="line">        study = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;书房&quot;</span>);</span><br><span class="line">        bedroom = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;卧室&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//	初始化房间的出口</span></span><br><span class="line">        outside.setExit(<span class="string">&quot;east&quot;</span>, lobby);</span><br><span class="line">        outside.setExit(<span class="string">&quot;south&quot;</span>, study);</span><br><span class="line">        outside.setExit(<span class="string">&quot;west&quot;</span>, pub);</span><br><span class="line">        lobby.setExit(<span class="string">&quot;west&quot;</span>, outside);</span><br><span class="line">        pub.setExit(<span class="string">&quot;east&quot;</span>, outside);</span><br><span class="line">        study.setExit(<span class="string">&quot;north&quot;</span>, outside);</span><br><span class="line">        study.setExit(<span class="string">&quot;east&quot;</span>, bedroom);</span><br><span class="line">        bedroom.setExit(<span class="string">&quot;west&quot;</span>, study);</span><br><span class="line">        lobby.setExit(<span class="string">&quot;up&quot;</span>, pub);</span><br><span class="line">        pub.setExit(<span class="string">&quot;down&quot;</span>, lobby);</span><br><span class="line"></span><br><span class="line">        currentRoom = outside;  <span class="comment">//	从城堡门外开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消除代码复制：把重复的代码提取出来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printWelcome</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎来到城堡！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个超级无聊的游戏。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如果需要帮助，请输入 &#x27;help&#x27; 。&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        showPrompt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goRoom</span><span class="params">(String direction)</span> </span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">Room</span> <span class="variable">nextRoom</span> <span class="operator">=</span> currentRoom.getExit(direction);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextRoom == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;那里没有门！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            currentRoom = nextRoom;</span><br><span class="line">            showPrompt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPrompt</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;你在&quot;</span> + currentRoom);</span><br><span class="line">        System.out.print(<span class="string">&quot;出口有: &quot;</span>);</span><br><span class="line">        <span class="comment">//这样就解开耦合了</span></span><br><span class="line">        System.out.print(currentRoom.getExitDesc());	</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;	<span class="comment">//或者叫做run</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    	<span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">    		<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">    		String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    		<span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> handlers.get(words[<span class="number">0</span>]);</span><br><span class="line">    		<span class="comment">//没有words[1]的情况：</span></span><br><span class="line">    		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    		<span class="keyword">if</span> ( words.length &gt; <span class="number">1</span>)</span><br><span class="line">    			value = words[<span class="number">1</span>];</span><br><span class="line">    		<span class="comment">//新版实现：</span></span><br><span class="line">    		<span class="keyword">if</span> ( handler != <span class="literal">null</span> ) &#123; <span class="comment">//handler不是null，说明这是一个有效的命令。</span></span><br><span class="line">    			handler.doCmd(value);	<span class="comment">//解决没有words[1]的情况</span></span><br><span class="line"><span class="comment">//    			handler.doCmd(word[1]);	//让handle做doCmd，给它word[1]就可以了。</span></span><br><span class="line">    			<span class="keyword">if</span> ( handler.isBye() ) <span class="comment">//或isExit</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="comment">//原版实现：以下就可以都没有了</span></span><br><span class="line"><span class="comment">//    		if ( words[0].equals(&quot;help&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">//    			printHelp();</span></span><br><span class="line"><span class="comment">//    		&#125; else if (words[0].equals(&quot;go&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">//    			goRoom(words[1]);</span></span><br><span class="line"><span class="comment">//    		&#125; else if ( words[0].equals(&quot;bye&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">//    			break;</span></span><br><span class="line"><span class="comment">//    		&#125;</span></span><br><span class="line">    	&#125;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Game</span> <span class="variable">game</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Game</span>();</span><br><span class="line">		game.printWelcome();</span><br><span class="line">		game.play();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;感谢您的光临。再见！&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Room&gt; exits = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Room&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Room</span><span class="params">(String description)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExit</span><span class="params">(String dir, Room room)</span> &#123;	<span class="comment">//设出口。没有s是因为这是设单个</span></span><br><span class="line">    	exits.put(dir, room);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降低耦合度1：需要一个对房间描述的东西。</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getExitDesc</span><span class="params">()</span> &#123;	<span class="comment">//它可以返回一个表达现在有什么房间的字符串</span></span><br><span class="line">    	<span class="comment">// 改用StringBuffer而非String来减少系统开销。</span></span><br><span class="line">    	<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();	</span><br><span class="line">    	<span class="keyword">for</span> (String dir : exits.keySet() ) &#123;	<span class="comment">//对于出口exits的keySet，拿到每一个key</span></span><br><span class="line">    		sb.append(dir);	<span class="comment">//把存储在dir里的key加进去</span></span><br><span class="line">    		sb.append(<span class="string">&#x27; &#x27;</span>);	<span class="comment">//还需要加一个空格</span></span><br><span class="line">    	&#125;</span><br><span class="line">    		sb.append(<span class="string">&quot;west &quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//降低耦合度2：从那个Room那边得到这个方向上面有没有东西</span></span><br><span class="line">    <span class="comment">//根据这个字符串direction决定：返回一个什么Room。</span></span><br><span class="line">    <span class="keyword">public</span> Room <span class="title function_">getExit</span><span class="params">(String direction)</span> &#123;	</span><br><span class="line">    	<span class="keyword">return</span> exits.get(direction);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> Game game;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Game game)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.game = game;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBye</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerBye</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HandlerBye</span><span class="params">(Game game)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(game);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBye</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerHelp</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HandlerHelp</span><span class="params">(Game game)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(game);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 以下为用户命令</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;迷路了吗？你可以做的命令有：go bye help&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如：\tgo east&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerGo</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HandlerGo</span><span class="params">(Game game)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(game);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;</span><br><span class="line">		game.goRoom(word);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="程序中还有没有能以框架加数据来表达的东西？"><a href="#程序中还有没有能以框架加数据来表达的东西？" class="headerlink" title="程序中还有没有能以框架加数据来表达的东西？"></a>程序中还有没有能以框架加数据来表达的东西？</h3><p>Q：程序中还有没有能以框架加数据来表达的东西？</p>
<p>A：是否可以把game类里的<code>goRroom</code>和<code>showPrompt</code>摘出来？</p>
</blockquote>
<h3 id="5-6-类型系统"><a href="#5-6-类型系统" class="headerlink" title="5.6 类型系统"></a>5.6 类型系统</h3><blockquote>
<p><code>Q1</code>：<strong>如何实现任意门？</strong><br>如果想要实现任意门，即在某个房间，想要从某个出口出去，结果每次会走到不同的房间去。</p>
<p>如果要实现这样的任意门，整个程序的架构应该是怎样的？</p>
<p>如果任意门只是在这个房间的所有的门之间轮转，应该怎样实现？</p>
<p>如果任意门能在整个城堡的所有的门之间轮转，应该怎样实现？</p>
<p><code>A1</code>：可以设置一个任意门的类，在每次给出方向切换房间之前判断是否处于任意门处</p>
<p>如果任意门是固定的一个，则切换之前先判断当前room以及行进的方向是不是任意门，如果不是继续正常运行，是的话，则用一个<code>ArrayLis</code>t将所有的房间放进去，除了当前的这个房间，随机数一个，根据随机数结果切换房间</p>
<p>如果任意门是固定房间的某一个门，则先判断当前room是不是有任意门，然后多一个随机数0或1，1则这个方向就是任意门，否则就是正常切换</p>
<p>如果任意门是所有房间某一个门，则不判断room，直接随机数决定当前是不是任意门，也可以降低任意门的概率</p>
</blockquote>
<blockquote>
<p><code>Q2</code>：<strong>隐形耦合</strong><br>现在的代码，如果增加新的命令，那么help所输出的内容就需要做变化，而help的输出内容目前是硬编码的。如何修改代码能实现help的输出内容与help的输出函数无关，使得新的命令加入的时候，help能自动输出新的内容？</p>
<p><code>A</code>2：在handler里添加了对于每个命令描述的方法，，然后各个子类覆盖该方法描述自己具体做什么。在room里添加了当前room的方向输出的<code>ArrayList</code>，方便go后面接一个方向；每个命令在代码里是直接写的，例如<code>handlerGo</code>里直接写了go，但是考虑到这个类就是为了go创建的，所以认为直接硬编码“go”无伤大雅吧。然后help统筹将各个handler的方法描述调用，输出展示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//handler更新的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHelp</span><span class="params">()</span>&#123;<span class="keyword">return</span>  <span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helpNote</span><span class="params">(HashMap&lt;String,Handler&gt; handlers,String des)</span>&#123; &#125;<span class="comment">// help用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cmdExp</span><span class="params">(String roomDes)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// room类更新的地方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ArrayList&lt;String&gt; roomExit = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();<span class="comment">//房间的出口</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//返回该房间的出口的ArrayList</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title function_">getExitAaary</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String dir: exits.keySet())&#123;</span><br><span class="line">            roomExit.add(dir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roomExit;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// HandlerBye更新的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cmdExp</span><span class="params">(String roomDes)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;如：\tbye&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HandlerHelp更新的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHelp</span><span class="params">()</span>&#123;<span class="keyword">return</span>  <span class="literal">true</span>;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helpNote</span><span class="params">(HashMap&lt;String,Handler&gt; handlers,String roomDes)</span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;迷路了吗？你可以做的命令有：&quot;</span>);</span><br><span class="line">    System.out.println(handlers.keySet());</span><br><span class="line">    <span class="keyword">for</span> (String ks: handlers.keySet())&#123;</span><br><span class="line">        handlers.get(ks).cmdExp(roomDes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCmd</span><span class="params">(String word)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cmdExp</span><span class="params">(String roomDes)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;如：\thelp&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HandlerGo更新的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cmdExp</span><span class="params">(String roomDes)</span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;如：\tgo &quot;</span>);</span><br><span class="line">    System.out.println(roomDes);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Game更新的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">       <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">           String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> handlers.get(words[<span class="number">0</span>]);</span><br><span class="line">           <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">           <span class="keyword">if</span>(words.length &gt;<span class="number">1</span>)&#123;</span><br><span class="line">               value = words[<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (handler != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(handler.isHelp())&#123;</span><br><span class="line">                   handler.helpNote(handlers,currentRoom.getExitAaary().get(<span class="number">0</span>));</span><br><span class="line">               &#125;</span><br><span class="line">               handler.doCmd(value);</span><br><span class="line">               <span class="keyword">if</span>(handler.isBye())</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       in.close();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line">help</span><br><span class="line">迷路了吗？你可以做的命令有：[help, go, bye]</span><br><span class="line">如：	help</span><br><span class="line">如：	go east</span><br><span class="line">如：	bye</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>Q3：<strong>新的游戏</strong></p>
<p>这其实就是本周的作业。</p>
<p>请以castle为基础，扩展出你能想到的新元素，同时注意遵循本周所讲述的设计原则。</p>
<p>把你设计的游戏的代码跟帖发布这里。</p>
<p>然后，我们根据收到的赞的数量来打分。具体规则如下：</p>
<p>截止时间为2016年7月4日23点；</p>
<p>若收到的赞的数量最高记为m，则每个人收到的赞的数量n位于[0,m]的区间内，每个人的最后得分x为n从[0,m]到[0,5]的映射；</p>
<p>学期结束后，由我们手工将这个分数x加到最后的总分上。如果某人总分因此超过100分则记100分。</p>
<p>A3：任意门 开启任意门模式则会随机传送，关闭则正常传送。</p>
<p>输入输出如下：</p>
<p>help</p>
<p>迷路了吗？你可以做的命令有：[help, go, bye, goRandom]</p>
<p>如：	help</p>
<p>如：	go east</p>
<p>如：	bye</p>
<p>如需打开任意门模式，请回复如：goRandom true</p>
<p>如需关闭任意门模式，请回复如：goRandom false</p>
<p>目前任意门模式已关闭</p>
<p>goRandom true</p>
<p>true</p>
<p>任意门模式已打开</p>
<p>go west</p>
<p>开启随机传送</p>
<p>2</p>
<p>你在小酒吧</p>
<p>出口有: east down </p>
<p>goRandom false</p>
<p>false</p>
<p>任意门模式已关闭</p>
<p>go east</p>
<p>你在城堡外</p>
<p>出口有: east south west </p>
<p>Game的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> castle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Room currentRoom ;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,Handler&gt; handlers ;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Room&gt; rooms =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Room&gt;();<span class="comment">//创建房间的ArrayList</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Game</span><span class="params">()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        handlers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Handler&gt;();</span><br><span class="line">        handlers.put(<span class="string">&quot;go&quot;</span>,<span class="keyword">new</span> <span class="title class_">HandlerGo</span>(<span class="built_in">this</span>));</span><br><span class="line">        handlers.put(<span class="string">&quot;bye&quot;</span>,<span class="keyword">new</span> <span class="title class_">HandlerBye</span>(<span class="built_in">this</span>));</span><br><span class="line">        handlers.put(<span class="string">&quot;help&quot;</span>,<span class="keyword">new</span> <span class="title class_">HandlerHelp</span>(<span class="built_in">this</span>));</span><br><span class="line">        handlers.put(<span class="string">&quot;goRandom&quot;</span>,<span class="keyword">new</span> <span class="title class_">HandlerGoRandom</span>(<span class="built_in">this</span>));<span class="comment">//任意门</span></span><br><span class="line">        createRooms();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createRooms</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Room outside, lobby, pub, study, bedroom;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 制造房间</span></span><br><span class="line">        outside = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;城堡外&quot;</span>);</span><br><span class="line">        lobby = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;大堂&quot;</span>);</span><br><span class="line">        pub = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;小酒吧&quot;</span>);</span><br><span class="line">        study = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;书房&quot;</span>);</span><br><span class="line">        bedroom = <span class="keyword">new</span> <span class="title class_">Room</span>(<span class="string">&quot;卧室&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化房间的出口</span></span><br><span class="line">        outside.setExit(<span class="string">&quot;east&quot;</span>, lobby);</span><br><span class="line">        outside.setExit(<span class="string">&quot;south&quot;</span>, study);</span><br><span class="line">        outside.setExit(<span class="string">&quot;west&quot;</span>, pub);</span><br><span class="line">        lobby.setExit(<span class="string">&quot;west&quot;</span>, outside);</span><br><span class="line">        pub.setExit(<span class="string">&quot;east&quot;</span>, outside);</span><br><span class="line">        study.setExit(<span class="string">&quot;north&quot;</span>,outside);</span><br><span class="line">        study.setExit(<span class="string">&quot;west&quot;</span>, bedroom);</span><br><span class="line">        bedroom.setExit(<span class="string">&quot;west&quot;</span>, study);</span><br><span class="line">        lobby.setExit(<span class="string">&quot;up&quot;</span>,pub);</span><br><span class="line">        pub.setExit(<span class="string">&quot;down&quot;</span>,lobby);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加房间</span></span><br><span class="line">        rooms.add(outside);</span><br><span class="line">        rooms.add(lobby);</span><br><span class="line">        rooms.add(pub);</span><br><span class="line">        rooms.add(study);</span><br><span class="line">        rooms.add(bedroom);</span><br><span class="line"></span><br><span class="line">        currentRoom = outside;  <span class="comment">// 从城堡门外开始</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printWelcome</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;欢迎来到城堡！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个超级无聊的游戏。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如果需要帮助，请输入 &#x27;help&#x27; 。&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        showPrompt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为用户命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goRoom</span><span class="params">(String direction)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">nextRoom</span> <span class="operator">=</span> currentRoom.getExit(direction);</span><br><span class="line">        <span class="keyword">if</span> (nextRoom == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;那里没有门！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            currentRoom = nextRoom;</span><br><span class="line">            showPrompt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">goRoomRandom</span><span class="params">(String direction)</span> <span class="comment">// 任意门</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启随机传送&quot;</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">randRoom</span> <span class="operator">=</span>rand.nextInt(rooms.size());</span><br><span class="line">        System.out.println(randRoom);</span><br><span class="line">        <span class="type">Room</span> <span class="variable">nextRoom</span> <span class="operator">=</span> rooms.get(randRoom);</span><br><span class="line">        <span class="keyword">if</span> (nextRoom == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;那里没有门！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            currentRoom = nextRoom;</span><br><span class="line">            showPrompt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showPrompt</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你在&quot;</span> + currentRoom);</span><br><span class="line">        System.out.print(<span class="string">&quot;出口有: &quot;</span>);</span><br><span class="line">        System.out.println(currentRoom.getExitDesc());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">            String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> handlers.get(words[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(words.length &gt;<span class="number">1</span>)&#123;</span><br><span class="line">                value = words[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(handler.isHelp())&#123;</span><br><span class="line">                    handler.helpNote(handlers,currentRoom.getExitAaary().get(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                handler.doCmd(value);</span><br><span class="line">                <span class="keyword">if</span>(handler.isBye())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">/* if ( words[0].equals(&quot;help&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">                printHelp();</span></span><br><span class="line"><span class="comment">            &#125; else if (words[0].equals(&quot;go&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">                goRoom(words[1]);</span></span><br><span class="line"><span class="comment">            &#125; else if ( words[0].equals(&quot;bye&quot;) ) &#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">  &amp;n</span><br></pre></td></tr></table></figure></blockquote>
<h2 id="第6周抽象与接口"><a href="#第6周抽象与接口" class="headerlink" title="第6周	抽象与接口"></a>第6周	抽象与接口</h2><h3 id="6-1-抽象"><a href="#6-1-抽象" class="headerlink" title="6.1 抽象"></a>6.1 抽象</h3><blockquote>
<p>[!NOTE]</p>
<p>在第一周就有一个Shape类的例子。这个类有很多的子类，每个子类也都实现了父类的方法。实际上父类Shape只是一个抽象的概念而并没有实际的意义。如果请你画一个圆，你知道该怎么画；如果请你画一个矩形，你也知道该怎么画。但是如果我说：“请画一个形状，句号”。你该怎么画？同样，我们可以定义Circle类和Rectangle类的draw()，但是Shape类的draw()呢？</p>
<p>Shape类表达的是一种概念，一种共同属性的抽象集合，我们并不希望任何Shape类的对象会被创建出来。那么，我们就应该把这个Shape类定义为抽象的。我们用abstract关键字来定义抽象类。抽象类的作用仅仅是表达接口，而不是具体的实现细节。抽象类中可以存在抽象方法。抽象方法也是使用abstract关键字来修饰。抽象的方法是不完全的，它只是一个方法签名而完全没有方法体。</p>
<p>如果一个类有了一个抽象的方法，这个类就必须声明为抽象类。如果父类是抽象类，那么子类必须覆盖所有在父类中的抽象方法，否则子类也成为一个抽象类。一个抽象类可以没有任何抽象方法，所有的方法都有方法体，但是整个类是抽象的。设计这样的抽象类主要是为了防止制造它的对象出来。</p>
</blockquote>
<p>🍎抽象类和抽象函数</p>
<p>我们第一周就见过这个shapes程序，我们知道用它可以画出各种形状来，然后呢让大家很开心的去画了很多图形。</p>
<p>有没有人注意过这个shapes程序的最根上那个类Shape它是长什么样子的呢？你看它的源代码其实是这个样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shapes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="comment">//abstract：抽象</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Graphics g)</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个Shape类在public和class中间多了一个单词，叫做abstract。在这个类里头唯一的那个draw函数，它的public和void中间也有一个abstract。这个单词的意思是抽象。</p>
<p>为什么要这样子呢？因为你看，我们现在的shape的家族其实是这样子的</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109182121096.png" alt="image-20250109182121096"></p>
<p>从Shape类，我们派生出了Rectangle、Ellipse、Square、Circle等等各种各样的形状。而在Shape里我们定义了叫做draw的函数。这个函数定义出来之后，所有的Shape类的子类都有一个叫做draw的函数。然后现在假如我们要说，我们要来做这个Circle，这个Circle怎么做？很简单，就是画一个圆。假如来做这个Square，很简单就是画一个矩形呀。</p>
<p>但是如果我跟你说我现在有一个Shape，要去写它的draw（就像三岁小儿也知道该怎么画个圆，顶多画的不圆。长方形、直线同理。可如果说现在请你画个形状，你画什么？）。</p>
<p>也就是说像Shape这样的一个类，在程序中它的作用是什么？它提供了Circle、Rectangle、Ellipse、Square这么一些东西的一个公共的概念 &#x2F; 父类。在这个公共的概念中它提出来说，所有的Shapes不管是哪种形状，都应该会draw()，这是我们之前讲<strong>多态</strong>的时候提出的概念——由这个公共的父类提出了draw()这件事情，因此所有的子类都可以draw()了。这就是这个公共父类存在的意义。</p>
<p>如果没有这个Shape，那么Circle和Rectangle之间就没有关系了。现在因为有这个Shape，所有Circle和Rectangle可以被认为都是一种Shape。所以Shape类的意义就在这儿，我们从来也没有想过要去真的去产生一个Shape类的对象，因为如果真的有一个Shape类的对象出来，你就没有办法说我到底要你这么draw，因为他没有任何存在的意义，它只是表达一种概念。</p>
<p>在这种情况下，我们最合适的方式就是让这个类成为一个abstract类，也就是成为一个抽象的类。</p>
<p>而在这个抽象类中的draw()方法，它在这个类里头没有存在的意义。它的意义就是为了告诉别人说，所有Shape类的子类都具有那么一个draw函数。所以这个函数&#x2F;方法本身也应该是抽象（abstract）的。</p>
<p>🍎抽象类的定义和使用</p>
<p>从语法上来说，由于这个draw是抽象的，所以这个draw在这里是没有大括号的。如果把大括号加上去就会报错，因为抽象的函数不能有括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shapes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="comment">//abstract：抽象</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Graphics g)</span>; <span class="comment">//没有【 &#123;&#125; 】</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，如果你有一个draw函数是抽象的，把class中的abstract去掉也会报错。它会说，由于你这个类里面有一个抽象的函数了，那么这个类就必须是抽象的。</p>
<p>——因为抽象的类（class）还有另外一种意思：就是这个类是不能够产生对象的。</p>
<blockquote>
<p>[!NOTE]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Shape</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Shape</span>(); <span class="comment">//测试一下能不能产生对象：制造出了一个Shape的对象s。有一个Shape的类s等于new一个Shape。</span></span><br></pre></td></tr></table></figure>

<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109184305152.png" alt="image-20250109184305152"></p>
<p>报错：不能实例化Shape这个类型，因为这个类型是抽象的。</p>
</blockquote>
<p>假如这件事能做成：我们说这个类中有一个抽象的函数，但是这个类<strong>不是</strong>抽象的。那么这个类不是抽象的话，就意味着它能够制造对象了。如果我们制造出了一个Shape的对象s，现在你说： s.draw(); 那它该这么做呢？这个draw函数没有定义呀，这个draw函数没有body呀？我们只是声明了说这里会有这样的一个draw，但是没有给出函数体啊？所以  s.draw(); 依然无法执行。</p>
<p>所以只要这个类里头有一个函数是抽象的，那么整个类就是抽象的。</p>
<p>🍎抽象函数的定义和使用</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109185150618.png" alt="image-20250109185150618"></p>
<p>eg：抽象函数——Shape里的那个draw。抽象类——Shape。</p>
<p>抽象类不能制造对象，但是可以用抽象类的名字来定义变量。当然实际上将来赋给这个变量的一定是这个类的非抽象的子类，才能去赋给这个抽象类的变量。</p>
<p>这个时候这个抽象类的变量的意思是：任何继承了抽象类的非抽象类的对象可以赋给这个变量。（比如说Shape类的变量s，那就是指任何Shape类的子类的对象都可以由这个s来管理。）</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109190213653.png" alt="image-20250109190213653"></p>
<p>当我们有一个子类，这个子类去继承了一个抽象类以后，那个抽象类里面所有的抽象的函数都必须要被这个子类所实现，也就是说被它给覆盖。——对于这种覆盖，我们叫做实现。</p>
<p>否则的话，这个类自己就成为一个抽象类了。</p>
<blockquote>
<p>[!NOTE]</p>
<p>eg：为Shape类增加一个新函数&#x2F;方法 move</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109190455587.png" alt="image-20250109190455587"></p>
<p>因为他们没有实现应该实现的东西。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109190543094.png" alt="image-20250109190543094"></p>
<p>比如说可以到Circle那边去看，他会说：Circle这个类型必须去实现继承得到的抽象的方法Shape的那个move因为你想从继承的概念来说</p>
<p>因为你想：从继承的概念来说，父类所有的东西都继承来了，那么在Shape类里头，我们有draw，有move。对于draw来说我们在Circle中通过Circle的draw函数把它给覆盖掉了，因此draw函数在Circle里头它不是抽象的了。而Shape里的move函数在Circle里没有任何函数去覆盖它，所有现在在Circle里头这个move就成为抽象的啦。解决办法1：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109191252655.png" alt="image-20250109191252655"></p>
<p>Add unimplemented methods 加上没有实现的方法。</p>
<p>解决办法2：让子类也成为抽象的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109191413577.png" alt="image-20250109191413577"></p>
<p>当然后面也会有问题，因为这样的话你就不能去制造（new）一个Line类的对象出来了。</p>
</blockquote>
<p>🍎抽象类的继承和实现</p>
<p>就是如果一个类去继承了一个抽象的类，又没有去实现所有的抽象方法，那么这个类自己就成为了一个新的抽象类。它也不能够去制造对象出来。</p>
<p>🍎抽象的两种含义</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250109191751707.png" alt="image-20250109191751707"></p>
<p>讲到这呢，我们得要来澄清一下概念：其实我们之前也提到过抽象这个概念</p>
<p>**其实在计算机的术语体系当中，抽象是有两种不同的意义的。**只是很多人没有意识到这一点。</p>
<p>我们会在两个不同的语境底下来用抽象这个词，它们的含义有相似的地方，但是有非常细微的不同。</p>
<p>1）与具体相对的。eg：我们这里这个Shape类的抽象。因为Shape表达的是概念而不是具体的东西，Circle才有可能是具体的东西。与具体相对的，这是一种抽象。</p>
<p>2）与细节相对的。之前我们还提到过的另外一种抽象。eg：当我们看到一辆汽车的时候，普通人只会看到说这是一辆小轿车，顶多说这是一辆蓝色的小轿车。他不会一下子想到说，噢这个发动机是四缸的，这个是直立的，这个是什么样的变速箱——正常人不会去想这些东西。</p>
<p><strong>因为我们人的思维都会在一定程度上去掩盖细节，不去看到一定层次上的细节下面的东西</strong></p>
<p>所以在计算机的整个术语体系当中，其实我们是存在着这样两种不同的抽象。两种抽象，两种抽象的能力和实现。</p>
<h3 id="6-2-数据与表现分离：细胞自动机"><a href="#6-2-数据与表现分离：细胞自动机" class="headerlink" title="6.2 数据与表现分离：细胞自动机"></a>6.2 数据与表现分离：细胞自动机</h3><h4 id="6-2-1-细胞自动机"><a href="#6-2-1-细胞自动机" class="headerlink" title="6.2.1 细胞自动机"></a>6.2.1 细胞自动机</h4><p>🍎细胞自动机</p>
<p>我们先来看这程序运行起来什么样：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213124546094.png" alt="image-20250213124546094" style="zoom:67%;" />

<p>这个一下子也看不明白是吧？看见这个网格上面好多黑的点点动来动去动，到底在干什么呢？</p>
<p>这是个细胞自动机。它的基本概念是这样：就是在这个棋盘&#x2F;网格上面，每一个点都可能是一个细胞，黑点表示这是一个或者的细胞、白点表示这是一个死了的细胞。</p>
<p>每一轮&#x2F;每一步，它做的事情就是检查所有的细胞，看这个细胞和它周围细胞的情况。每一个细胞都在一个九宫格里头，所以它周围有8个细胞。周围的8个细胞我们去数活着的细胞的数量，如果说（8个里面）有2个或3个活着，则不动。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213125046253.png" alt="image-20250213125046253"></p>
<p>这样子循环往复我们就看到看到的是我们刚才哪一系列看到的情况。</p>
<p>这就是细胞自动机，它可以表达出一些有意思的现象。</p>
<p>那么我们来看一下这个程序，这个程序到目前为止可能是比较复杂的。</p>
<p>🍎阅读代码的方法</p>
<p>我们拿到一个陌生的程序，怎么看懂这个程序有两种看法：</p>
<p>1）去找main（因为程序总是从main开始的），找到main以后想办法去读懂它的每一句（看它每一句都是干什么的，这一句中都提到过什么样的类），然后再展开去看那个类。</p>
<p>2）去找最小的类（想办法能不能找到一个最细节的类），然后对这个类追追追追到它的父类（追到最顶上的父类），从细节开始看懂每一个小部件是干什么的，最后再把整个程序给拼起来。</p>
<p>我们先从main（<code>CellMachine</code>类）开始来试试看怎么去看懂别人写的代码：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213191523483.png" alt="image-20250213191523483"></p>
<p>然后遍历的这个field我们做了一个place…</p>
<p>其实到目前我们已经看到了很多类，我们的<code>CellMachine</code>是入口，在<code>CellMachine</code>先去做了一个Field，在Field里我们放进了很多Cell，这就是我们目前做的事情。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213192101044.png" alt="image-20250213192101044"></p>
<p>到这为止，可以说这一段（12~29行）我们在准备数据。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213192859788.png" alt="image-20250213192859788"></p>
<p><code>JFrame</code>这是同样我们出现在第一周（Shape程序）没有展开讲的，我们看到的图形窗口在Java来说是叫做一个<code>JFrame</code>。</p>
<p>如果我们的程序到此为止，从这儿下面的代码都不存在的话（注释掉后），我们来跑一下这个程序看看：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213193000391.png" alt="image-20250213193000391" style="zoom:67%;" />

<p>我们就出现了一个静态&#x2F;静止的画面：有这样一个窗口，因为它是不可改变大小的，所以现在不能把它变大变小，但可以拖动。上面有了棋盘&#x2F;网格，网格上面有些是黑的、有些是白的。点x可以把它关掉。</p>
<p>所以我们可以知道，到这一步（39行）其实我们做了什么呢？我们知道12<del>29行准备了一个叫做Field的东西，有数据了。30</del>39行代码准备了一个叫做View的东西，View是干什么的？</p>
<p>我们看代码的时候其实通常会比较关系我们看得见的那些东西，显然看起来View像是我们看见的那个窗口，那么我们来看View。</p>
<p>🍎View类的作用</p>
<p>对于View：</p>
<p>其实对于整个View，有用的只有paint函数。这个paint函数是@Override的，就是说其实是继承来的。因为View本身是一个<code>JPanel</code>（Java的图形库当中用来表达一块画面的那么一个东西），paint函数（21行）做的事情是说：每一次当我的这个窗口要被显示出来的时候，这个paint函数就会被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cell.Cell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">View</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5258995676212660595L</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GRID_SIZE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">private</span> Field theField;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">View</span><span class="params">(Field field)</span> &#123; <span class="comment">//构造的时候记录了一个Field</span></span><br><span class="line">		theField = field;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123; <span class="comment">//被调用时得到一个Graphics的对象（当前要画的对象）</span></span><br><span class="line">		<span class="built_in">super</span>.paint(g);</span><br><span class="line">		<span class="comment">//一个两重循环，</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row&lt;theField.getHeight(); row++ ) &#123;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col&lt;theField.getWidth(); col++ ) &#123;</span><br><span class="line">				<span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> theField.get(row, col); <span class="comment">//从Field里面得到了每一个Cell</span></span><br><span class="line">				<span class="keyword">if</span> ( cell != <span class="literal">null</span> ) &#123; <span class="comment">//如果这个Cell是有的，那么就让这个Cell去draw</span></span><br><span class="line">					cell.draw(g, col*GRID_SIZE, row*GRID_SIZE, GRID_SIZE);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Dimension <span class="title function_">getPreferredSize</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dimension</span>(theField.getWidth()*GRID_SIZE+<span class="number">1</span>, theField.getHeight()*GRID_SIZE+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Field</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row&lt;field.getHeight(); row++ ) &#123;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col&lt;field.getWidth(); col++ ) &#123;</span><br><span class="line">				field.place(row, col, <span class="keyword">new</span> <span class="title class_">Cell</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">View</span>(field);</span><br><span class="line">		<span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line">		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">		frame.setResizable(<span class="literal">false</span>);</span><br><span class="line">		frame.setTitle(<span class="string">&quot;Cells&quot;</span>);</span><br><span class="line">		frame.add(view);</span><br><span class="line">		frame.pack();</span><br><span class="line">		frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些东西我们大多数在第一周的Shape函数都见过。从Field里面得到了每一个Cell，如果这个Cell是有的，那么就让这个Cell去draw——你看多么熟悉的画面，这个代码我们在Shape里见过类似的。在Shape里面也是去遍历那个Shape的列表，让每一个Shape的对象去draw自己。</p>
<p>现在我们也是，我们在View里面做的事情是去遍历这个Field（让这个Field的每一个单元拿出来），如果那个格子是有的、那个细胞是有的，那么这个细胞你自己去把自己画出来。</p>
<p>这是View，然后Field是做什么事呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cell.Cell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Field</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">	<span class="keyword">private</span> Cell[][] field; <span class="comment">//一个Cell的二维数组</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Field</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.width = width;</span><br><span class="line">		<span class="built_in">this</span>.height = height;</span><br><span class="line">		field = <span class="keyword">new</span> <span class="title class_">Cell</span>[height][width];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123; <span class="keyword">return</span> width; &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123; <span class="keyword">return</span> height; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Cell <span class="title function_">place</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, Cell o)</span> &#123;</span><br><span class="line">		<span class="type">Cell</span> <span class="variable">ret</span> <span class="operator">=</span> field[row][col];</span><br><span class="line">		field[row][col] = o;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Cell <span class="title function_">get</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> field[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Cell[] getNeighbour(<span class="type">int</span> row, <span class="type">int</span> col) &#123;</span><br><span class="line">		ArrayList&lt;Cell&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Cell&gt;();</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=-<span class="number">1</span>; i&lt;<span class="number">2</span>; i++ ) &#123;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="type">int</span> j=-<span class="number">1</span>; j&lt;<span class="number">2</span>; j++ ) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> row+i;</span><br><span class="line">				<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> col+j;</span><br><span class="line">				<span class="keyword">if</span> ( r &gt;-<span class="number">1</span> &amp;&amp; r&lt;height &amp;&amp; c&gt;-<span class="number">1</span> &amp;&amp; c&lt;width &amp;&amp; !(r== row &amp;&amp; c == col) ) &#123;</span><br><span class="line">					list.add(field[r][c]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">Cell</span>[list.size()]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;height; i++ ) &#123;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="type">int</span> j=<span class="number">0</span>; j&lt;width; j++ ) &#123;</span><br><span class="line">				field[i][j] = <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Field很简单，Field说我里面有一个Cell的二维数组，我就维持好这个二维数组。你要place（第21行）我就把它放进去、你要get（27行）我就拿出来给你——做的就是这么一件事情。</p>
<p>🍎Field类的作用</p>
<p>然后我们看到，View和Field之间的互动是什么？</p>
<p>这个互动要从<code>CellMachine</code>的下面（41行）来看，我们再来解开它的注释、研究一下下面的代码：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213195610015.png" alt="image-20250213195610015"></p>
<p>所以其实核心的代码就在这儿（44~68行）：就是每一轮我去取出相应的一个格子来以后，用Field的一个方法得到我所有的邻居，然后根据邻居的活着的数量来决定 我该怎么办。</p>
<p><code>eg</code>，cell的die（<code>CellMachine</code>61行）做了什么事情呢？（对应Cell的第8行）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">alive</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//有一个alive的变量，表明自己是不是活着的。</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">die</span><span class="params">()</span> &#123; alive = <span class="literal">false</span>; &#125; <span class="comment">//die -&gt; alive置为false。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reborn</span><span class="params">()</span> &#123; alive = <span class="literal">true</span>; &#125; <span class="comment">//reborn -&gt; alive置为true。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123; <span class="keyword">return</span> alive; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Graphics g, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">		g.drawRect(x, y, size, size); <span class="comment">//先画个方框</span></span><br><span class="line">		<span class="keyword">if</span> ( alive ) &#123;	<span class="comment">//如果是活着的</span></span><br><span class="line">			g.fillRect(x, y, size, size); <span class="comment">//这个方框是要填起来的。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是Cell做的事情。</p>
<p>也就是说，我们现在在这个程序里面这四个类（Cell、Field、View、<code>CellMachine</code>）中，<code>CellMachine</code>其实实现的是最终的业务逻辑，通过它在main里做的业务把Field和View粘结在一起。</p>
<p>所以<code>CellMachine</code>并不代表任何的东西，所以我们有价值去看的就是Cell、Field、View这三者之间的关系。他们是怎么样的呢？——见6.2.2 </p>
<p>附<code>CellMachine</code>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cellmachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cell.Cell;</span><br><span class="line"><span class="keyword">import</span> field.Field;</span><br><span class="line"><span class="keyword">import</span> field.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CellMachine</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Field</span>(<span class="number">30</span>,<span class="number">30</span>); <span class="comment">//大概可以猜到这是一个30x30的网格</span></span><br><span class="line">		<span class="comment">// 一个两重循环，大概去遍历了整个Field</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row&lt;field.getHeight(); row++ ) &#123; <span class="comment">//行从0到它的height</span></span><br><span class="line">			<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col&lt;field.getWidth(); col++ ) &#123;	<span class="comment">//列从0到它的width</span></span><br><span class="line">				field.place(row, col, <span class="keyword">new</span> <span class="title class_">Cell</span>());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//又去做了一边Field的遍历，</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row&lt;field.getHeight(); row++ ) &#123;</span><br><span class="line">			<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col&lt;field.getWidth(); col++ ) &#123;</span><br><span class="line">				<span class="comment">//做field的get：拿出row和col位置上的一个Cell出来。</span></span><br><span class="line">				<span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> field.get(row, col); </span><br><span class="line">				<span class="keyword">if</span> ( Math.random() &lt; <span class="number">0.2</span> ) &#123; <span class="comment">//判断如果随机数小于0.2</span></span><br><span class="line">				<span class="comment">//Math.random()函数会返回0~1之间的随机数。小于0.2，概率是1/5。</span></span><br><span class="line">					cell.reborn(); <span class="comment">//重生，让1/5的细胞活过来</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">View</span>(field); <span class="comment">//做了一个View，做的时候告诉它相应的field</span></span><br><span class="line">		<span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(); <span class="comment">//Java的图形窗口</span></span><br><span class="line">		<span class="comment">//做一个默认的关闭操作EXIT_ON_CLOSE：保证将来点图形窗口上面的叉叉能够把整个程序给结束掉</span></span><br><span class="line">		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); </span><br><span class="line">		<span class="comment">//做了一堆设置</span></span><br><span class="line">		frame.setResizable(<span class="literal">false</span>); <span class="comment">//不可以改变大小</span></span><br><span class="line">		frame.setTitle(<span class="string">&quot;Cells&quot;</span>); <span class="comment">//它的title是Cells</span></span><br><span class="line">		frame.add(view); <span class="comment">//在这个frame里面把刚才的那个view给加进去</span></span><br><span class="line">		frame.pack(); <span class="comment">//让它自己决定一下大小</span></span><br><span class="line">		frame.setVisible(<span class="literal">true</span>); <span class="comment">//把整个图形窗口显示出来</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++ ) &#123; <span class="comment">//做了一千步（要开始变化了）</span></span><br><span class="line">			<span class="comment">//每一次遍历同样的两层循环：遍历整个Field</span></span><br><span class="line">			<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row&lt;field.getHeight(); row++ ) &#123;</span><br><span class="line">				<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col&lt;field.getWidth(); col++ ) &#123;</span><br><span class="line">					<span class="type">Cell</span> <span class="variable">cell</span> <span class="operator">=</span> field.get(row, col); <span class="comment">//找到这个Field里面每一个单元取出来</span></span><br><span class="line">					<span class="comment">//让Field帮我去找到这个单元所有的邻居（这个格子周围的那8个）</span></span><br><span class="line">					Cell[] neighbour = field.getNeighbour(row, col);</span><br><span class="line">					<span class="comment">//以下6行：知道自己周围有多少个活着的邻居</span></span><br><span class="line">					<span class="type">int</span> <span class="variable">numOfLive</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span> ( Cell c : neighbour ) &#123; <span class="comment">//遍历所有的邻居</span></span><br><span class="line">						<span class="keyword">if</span> ( c.isAlive() ) &#123; <span class="comment">//如果这个邻居是活着的</span></span><br><span class="line">							numOfLive++; <span class="comment">//活着的邻居数量++</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.print(<span class="string">&quot;[&quot;</span>+row+<span class="string">&quot;][&quot;</span>+col+<span class="string">&quot;]:&quot;</span>);</span><br><span class="line">					System.out.print(cell.isAlive()?<span class="string">&quot;live&quot;</span>:<span class="string">&quot;dead&quot;</span>);</span><br><span class="line">					System.out.print(<span class="string">&quot;:&quot;</span>+numOfLive+<span class="string">&quot;--&gt;&quot;</span>);</span><br><span class="line">					<span class="keyword">if</span> ( cell.isAlive() ) &#123; <span class="comment">//如果我自己是活着的</span></span><br><span class="line">						<span class="comment">//根据前面说的规则：如果邻居数量是小于2个或者大于3个的，我自己就要死掉</span></span><br><span class="line">						<span class="keyword">if</span> ( numOfLive &lt;<span class="number">2</span> || numOfLive &gt;<span class="number">3</span> ) &#123;</span><br><span class="line">							cell.die();</span><br><span class="line">							System.out.print(<span class="string">&quot;die&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( numOfLive == <span class="number">3</span> ) &#123; <span class="comment">//如果我自己是死掉的，并且邻居有3个</span></span><br><span class="line">						cell.reborn(); <span class="comment">//我要重生</span></span><br><span class="line">						System.out.print(<span class="string">&quot;reborn&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;UPDATE&quot;</span>);</span><br><span class="line">			frame.repaint();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">200</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-数据与表现分离"><a href="#6-2-2-数据与表现分离" class="headerlink" title="6.2.2 数据与表现分离"></a>6.2.2 数据与表现分离</h4><p>🍎数据与表现分离</p>
<p><code>CellMachine</code>并不代表任何的东西，所以我们有价值去看的就是Cell、Field、View这三者之间的关系。他们是怎么样的呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213201845317.png" alt="image-20250213201845317"></p>
<p>Field是一个容器，里面放了很多东西。放在里面的是一个一个的Cell。它做的事情是：维持自己内部的数据，可以place（可以把Cell放进来）、可以get（可以从Field的某个位置得到那个Cell）、有一个叫做neighbour（找出八个邻居）。Field不知道View，它是<strong>管数据的——Data</strong>。</p>
<p>View并不去管Cell，它知道一个叫做Field的东西。它做的事情非常简单：paint（draw&#x2F;画）——如果我要画了，我就问Field去要数据。这是<strong>表现（presentation）</strong>。</p>
<p>Cell它并不认识Field，Cell只知道说：我作为一个Cell，我可以被draw出来——我知道自己怎么把自己给画出啦。</p>
<p>在代码里在什么地方呢？：</p>
<p>1）我们在前面做了一轮的二重循环（43~69行），把整个Field扫描了一遍，每一个Cell都决定了它要死要活。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213202027068.png" alt="image-20250213202027068"></p>
<p>2）然后我们对frame说repaint：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213202236110.png" alt="image-20250213202236110"></p>
<p>——我们没有说当我这死了一个或者活了一个我们就让那个View去重画。我们把整个Field里所有的数据都更新好了之后，让第三方（<code>CellMachine</code>）去做操作：</p>
<p>🍎责任驱动设计</p>
<p><code>CellMachine</code>才是又知道Field又知道View的那个人。<code>CellMachine</code>对Data（Field）做完一遍扫描的操作以后，跟View（presentation）说你现在给我更新一下repent，然后View就去Field那边去取数据，取完数据又把自己重画一遍。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213203007542.png" alt="image-20250213203007542"></p>
<p>我们不在每一个细胞上面去纠结说：我们是不是这个东西改了那个东西没改，没改的我就不要画了，改了的去画一画——不去做那么复杂的事。我们就做一个非常单纯的事，View就做一件单纯的事：给我数据然后完全重画一遍。</p>
<p>所以这个程序里面非常重要的一些设计理念是什么？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213204642266.png" alt="image-20250213204642266"></p>
<p>——因为我们看程序看什么？<strong>学习编程不仅仅是学那些语法</strong>（怎么做加法、怎么做减法、怎么做继承、extends怎么写…这是简单的），<strong>更重要的是学习在这些程序、这些例子当中，它们体现出来一些怎么样的设计理念。</strong></p>
<p>在这个细胞自动机里面非常重要的一件事情就是我们看到数据和表现是分离的——数据是数据（Field以及Field里面放的那些Cell）、表现是表现（View）。</p>
<p>分开的最大好处就是：这个表现你今天看到是这样的一个图形界面，我可不可以把它弄得更丰富点？我可不可以用文字的形式来表达它？（文字的形式我也有可能用符号画画的方式给它做一些可以直观表现的东西出来）我可不可以不是在我本机？我可不可以背后是有网络通过socket的通信在远端的？我可不可以是通过html的页面去表达的？</p>
<p>只要我把数据和表现在程序一开始就是分开的，那么我的数据就可以只做自己数据的操作，而表现也只做自己表现的操作。</p>
<p>在这个里面我们的Field和View的关系就表达了数据和表现的关系。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213205555253.png" alt="image-20250213205555253"></p>
<p>🍎设计优缺点</p>
<p>那么一旦数据更新了以后，我们就通知View把画面重新画出来，而不需要一点点小地方去决定说这个小地方画一下、那个小地方画一下——现在的图形界面程序都是这个思路。</p>
<p>40年前、30年前也许人们还会想：因为画的不够快，我要画的东西最少——今天没有这个事。人的眼睛能够感觉到的变化是1&#x2F;25秒，计算机怎么都比这个要来的快。</p>
<p>整个重画反而是最经济最好的方法。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213205906430.png" alt="image-20250213205906430"></p>
<p>在这个程序中还体现出来一件很重要的事情就是<strong>责任驱动的程序设计</strong>。</p>
<p>所谓的责任驱动设计意思就是说：我们的从整个程序的功能究竟应该<strong>分摊</strong>在什么类上来实现。我们有View、有Field、有Cell，什么功能在哪里做？<code>CellMachine</code>做了什么样的事情？</p>
<p>我们看到我们的View的功能是很单一的，我们的Field的功能也是很单一的。Field的表现就是place、get、neighbor。我们Cell的功能也很单一。最后业务逻辑放在<code>CellMachine</code>里面。——<strong>每一部分都做自己最擅长做的事情</strong>。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213210259000.png" alt="image-20250213210259000"></p>
<p>另外，在这个里面还有一个细节，就是我们的整个程序的表现是网格化的——这样做的最大的好处就是对于数据处理来说，你不用关系我到底是在x y坐标为多少的地方，我只要关心在第几行第几列就可以了。</p>
<p>具体在这个格子里面，我们可以有更高解析度的画面。其实很多游戏表面看起来这是一个连贯的画面，但是它内部设计的时候也是采用网格化的方式来做的。因为这样子能够让我们整个的画面设计最简单。</p>
<p>下面就留了一些讨论题让大家来讨论：</p>
<blockquote>
<h3 id="为什么没有Cell-setAlive"><a href="#为什么没有Cell-setAlive" class="headerlink" title="为什么没有Cell.setAlive()?"></a>为什么没有Cell.setAlive()?</h3><p>Q：为什么不是在Cell提供</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAlive(<span class="type">boolean</span>)</span><br></pre></td></tr></table></figure>

<p>函数？而是采用复杂的die()、reborn()两个函数？</p>
<p>——我们Cell类有一个叫做<code>isAlive</code>用来得到alive与否的数据。然后我们并没有一个叫做<code>setAlive</code>的函数说set true或者false，而是一个叫做die、一个叫做reborn。这样做有什么好处？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213211007415.png" alt="image-20250213211007415"></p>
<p>A：更符合面向对象的思想，die和reborn是cell对象的两种方法，更符合细胞对象的逻辑意义</p>
</blockquote>
<blockquote>
<h3 id="关于Field-getNeighbour"><a href="#关于Field-getNeighbour" class="headerlink" title="关于Field.getNeighbour()"></a>关于Field.getNeighbour()</h3><p>Q：为什么<code>Field.getNeighbour()</code>不直接看<code>Cell.isAlive()</code>来返回一个数字，而是要返回一个数组让外面来数数？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213211205347.png" alt="image-20250213211205347"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213211232352.png" alt="image-20250213211232352"></p>
<p>——为什么不是由Field直接给出一个函数说get alive number这么一个函数直接给出那个数量？</p>
<p>A：这样设置更符合面向对象编程的思维方式，题目的假设是细胞的生与死依赖于周围邻居的生死，通过方法获得周围邻居更符合题设，这样将重生规则将完全在<code>cellMachine</code>对象中实现，而直接从field对象返回周围邻居生死个数意味着有一半的重生规则需要依赖field对象的逻辑，获得邻居对象比单纯获得生死个数更容易应对重生规则的变化。</p>
</blockquote>
<blockquote>
<h3 id="Cell为什么不自己判断邻居情况？"><a href="#Cell为什么不自己判断邻居情况？" class="headerlink" title="Cell为什么不自己判断邻居情况？"></a>Cell为什么不自己判断邻居情况？</h3><p>Q：为什么不是由Cell自己判断自己的邻居的情况来决定自己是否应该被die或reborn？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213211407542.png" alt="image-20250213211407542"></p>
<p>——如果由Cell自己来做我们这张图里面有什么地方是有变化的？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213211501281.png" alt="image-20250213211501281"></p>
<p>——如果Cell要有一个函数说你自己判断一些自己是死还是活，那你就需要什么？你就需要知道Field。Cell就和Field的耦合就更紧了。在这种情况下让Cell知道Field好呢，还是让Cell不知道Field好？各自有什么优缺点？</p>
<p>A：<code>Cell</code>自己不知道自己所处的位置，如果cell要知道自己的位置，则需要将细胞容器（field）引入到cell，这样增加了耦合度，不是合理的方案</p>
</blockquote>
<h3 id="6-3-接口：狐狸与兔子"><a href="#6-3-接口：狐狸与兔子" class="headerlink" title="6.3 接口：狐狸与兔子"></a>6.3 接口：狐狸与兔子</h3><h4 id="6-3-1-狐狸与兔子"><a href="#6-3-1-狐狸与兔子" class="headerlink" title="6.3.1 狐狸与兔子"></a>6.3.1 狐狸与兔子</h4><p>🍎细胞自动机</p>
<p>我们刚才看的这个细胞自动机，它是在一个网格上面，有细胞。这个细胞有两种状态，要么是活的，要么是死的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213222610034.png" alt="image-20250213222610034"></p>
<p>现在我们想把这个故事再往前推进一步，我们想做一个农场&#x2F;地，这里面有狐狸还有兔子。所以它们的互动就比较多，细胞只有活的、死的两种状态；对于兔子和狐狸来说当然也有活的和死的两种状态，更复杂的是：它们还有年龄——随着程序的进展它们的年龄会不断增大，然后它们的年龄会有一个上限。到了这个上限它就死了。</p>
<p>另外，狐狸和兔子是捕食者和被捕食者的关系，所以狐狸会在周围8格也没有兔子，有的话就有概率吃一只兔子，当然，吃了以后年龄上限就会增高。</p>
<p>然后它们都可以生小的，有一定的几率来生，然后放在旁边。</p>
<p>如果不吃也不生，狐狸和兔子还可以移动。</p>
<p>——我们想实现这么一个仿真程序，这就比原来只有一个细胞，只有一种活和死的状态要复杂的多。我们来看看做出来的效果是怎么样子的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213222718761.png" alt="image-20250213222718761"></p>
<p>这里红色是兔子，黑色是狐狸。颜色随着年龄的增长越来越淡，最后看不见了就是死了。走完若干步以后，停下来就形成了最终状态。</p>
<p>🍎多继承</p>
<p>这个程序怎么做呢？其实我们在这个程序里面还是看到一些和刚才的那个细胞自动机相似的元素。比如说都有网格，网格里都有颜色。</p>
<p>但也有不同的东西，比如说颜色有红色有黑色。比如颜色会变淡。</p>
<p>那么整个程序的架构是怎么样子的？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213223058844.png" alt="image-20250213223058844"></p>
<p>我们还是维持了刚才的Field（里面有Field有View）的这样一种架构，就是数据和表现是分离的。——我们还是Field来表达数据，View来表达表现。</p>
<p>Cell还是那个Cell。</p>
<p>然后我们有了Fox和Rabbit来分别表达狐狸和兔子。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250213223703018.png" alt="image-20250213223703018"></p>
<p>但是在这个程序当中呢，Cell这个类的定位就很尴尬了。我们在细胞自动机这个程序里面，Cell其实表达的是细胞，然后呢细胞有活的有死的，活的是一个白色的框框，死的是一个黑色的框框。</p>
<p>但Cell这个单词的本意其实是格子——在英文当中最开始的意思是格子，后来用它表达细胞。那么在细胞自动机里面的格子和细胞<strong>刚好</strong>是同一种东西。</p>
<p>但是到了兔子和狐狸的这个故事当中，Cell的地位就很尴尬：它到底是表达格子呢？还是表达在这个格子里的东西？因为我们现在的局面是说，我们在这个Field里头每一个格子其实是三种情况：没东西、狐狸、兔子。</p>
<p>也就是说我们的狐狸和兔子将来这两个类做出来之后，它们的上面的一个<strong>父类</strong>应该是什么？</p>
<p>我们知道从问题本身的角度来说，如果狐狸和兔子它们如果有一个公共父类的话，它们的父类应该是动物Animal。因为这也很合理，我们想得到在这个程序里狐狸和兔子是有很多相同的动作的（比如说没经过一轮年龄都要增长，它们都要生小baby，它们要移动）。它们有很多相同的动作，这些相同的东西都应该放在一个公共的父类，比如说那个Animal。（这是我们从媒体数据库那边得到的知识。我们的CD和DVD有相同的东西就应该拿出一个Item类来）</p>
<p>可是这个时候Cell怎么办？</p>
<p>🍎类的关系</p>
<p>我们现在的这个关系是这个样子的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214091140271.png" alt="image-20250214091140271"></p>
<p>我们有一个叫做Animal的类，从它派生出了Fox和Rabbit。</p>
<p>Field和View维持细胞自动机的关系不变，一个表达数据一个表达表现。</p>
<p>在Field里放的是Cell，所以Field知道有Cell这种东西，它管理着Cell。</p>
<p>现在我们希望说Field里放Fox和Rabbit，比如说<code>place(r, c , Cell);</code>。现在如果我们想通过place把Rabbit放进去的话，Rabbit应该是Cell的子类。</p>
<p>——但如果我们让Rabbit同时从Animal和Cell两个类得到继承，那么这就形成了一种事实上的<strong>多继承</strong>。</p>
<p>多继承：一个类从两个父类得到继承。而多继承在Java是不被允许的。事实上，所有的OOP（Object Oriented Programming 面向对象编程）语言<strong>都不支持</strong>多继承。</p>
<p>只有C++支持。因为多继承从编程的角度来说、从语言实现的角度来说，有很多不好实现的地方。</p>
<p>因此我们不能让Rabbit一方面作为一个Animal，一方面又作为一个Cell。</p>
<p>——这样不行的话能不能说Animal是一种Cell呢？：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214091248882.png" alt="image-20250214091248882"></p>
<p>如果这样又带来一个问题，就是它在<strong>语义上是含糊的</strong>：Animal是动物，Cell是一种特殊的细胞&#x2F;格子？</p>
<p>如果我们认为Cell不再是表达细胞而表达的是格子（在Field的一个格子），是因为Field需要有一个类型，Field只能管它认识的类型。——我们的问题其实是在这儿：Field必须要有一个它认识的类型，它才能够管。而现在我们的代码已经写好了，它管的就是一种Cell的类型。</p>
<p>那么如果我们现在说Animal是一种Cell行不行？有一个很大的问题就是在语义上面：Animal怎么就是一个Cell了呢？Animal为什么是个格子？Animal不是格子。</p>
<p>我们不认为从语义上来说，Animal和Cell之间有一个联系是恰当的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214091728456.png" alt="image-20250214091728456"></p>
<p>——这个联系不恰当，这个联系使得Animal这个类成为一个很奇怪的东西。而且我们本来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214092130154.png" alt="image-20250214092130154"></p>
<p>Animal、Fox、Rabbit三个类的家族关系，其实和Cell没有关系、和Field没有关系、和View更加没有关系。因为Animal派生出了Fox和Rabbit这是动物自己的一个继承体系。在这个体系里面你要做什么事情，和你要不要在这块田里、要不要在我们的这种Field和View的这种架构里面放进去其他东西其实是没有关系的。那怎么办？</p>
<p>Field说你得给我一个Cell我才能管你的东西。Animal说Animal，Animal不是Cell怎么办？</p>
<p>——见6.3.2</p>
<h4 id="6-3-2-接口"><a href="#6-3-2-接口" class="headerlink" title="6.3.2 接口"></a>6.3.2 接口</h4><p>🍎接口的概念和特点</p>
<p>于是我们的解决方案是这样的：我们把那个Cell改造一下，它不是一个类吗？</p>
<p>我们把它从类改造成为一个<strong>接口</strong>（interface）。改造成接口之后，它就不再是类了，它就不再表达一个具体的东西：</p>
<p>因为<strong>类表达一个东西，而接口表达的是概念、是规范。</strong></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214092246130.png" alt="image-20250214092246130"></p>
<p>在这个里面，Java的接口其实它是一个纯的抽象类，也就是说在这个接口里头所有的函数都是abstract（抽象的）。——因此你不用说abstract：如果一个接口里面有变量，它实际上是<code>public static final</code>的。</p>
<p><code>public static final</code>的意思就是：这个变量首先它不属于任何对象，它属于整个类；第二，因为它是final的，因此它其实就是常量（这是一个编译时刻已经知道值的东西）。</p>
<p>所以这样的东西就成了一个接口。我们看代码是什么样子的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Graphics g, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> size)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是我们的Cell，其实空空的啥也没有，只有一个draw。只是说Cell要起的作用就是：所有实现了Cell这个接口的类的对象可以被放到Field里头去，因为Field对这个Cell的所有的管理权限就是放进去、拿出来、然后View将来要那这些Cell去draw。</p>
<p>就这么一个关系。</p>
<p>🍎接口的实现和使用</p>
<p>所以从图来看就变成是这样子了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214093633307.png" alt="image-20250214093633307"></p>
<p>——我们让Animal和Cell没有关系，但我们让Fox和Rabbit都去实现Cell。</p>
<p>实现了这个接口以后，Fox和Rabbit的对象就能被放到Field里头去了。能放的原因是：Field说“我要一个Cell”，Rabbit和Fox说“我实现了一个sale”，于是就可以放进去了。</p>
<p>怎么去实现Cell呢？我们来看Fox：</p>
<p>既然说<strong>实现</strong>嘛，我们就用一个新的关键词叫做<code>implements</code>。同样的最后有”s”因为是第三人称单数。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214094743008.png" alt="image-20250214094743008"></p>
<p>因为对于Field来说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214095617280.png" alt="image-20250214095617280"></p>
<p>——place说：我要一个Cell。这个时候，Cell的这个o是什么意思？</p>
<p>Cell本身是一个接口，接口的所有的函数都是abstract。因此，Cell一定不可能有对象，对吧？不可能有任何的Cell的对象被制造出来。</p>
<p>Cell的这个变量o的意思是：<strong>任何实现了Cell接口的类的对象都可以交给o这个变量</strong>。于是Fox可以、Rabbit也可以。对于Field来说，它不在乎你是Fox函数Rabbit、你是不是继承自Animal——跟它无关。它只管你是不是一个Cell，因为你只要是一个Cell，你就可以给我、我就可以给你管起来放进去。</p>
<p>🍎接口的作用和关系</p>
<p>因为对于后面的View来说，View要用Field的地方就在于View要去遍历整个Field，让Field去拿到每一个Cell，然后让这个Cell去做draw。我们的Cell就规定了这样的一个draw动作而已，其他什么都不管。</p>
<p>所以对于Fox来说，它实现了这个Cell（<code>Fox extends Animal implements Cell</code>）以后，他就必须去Override这个draw、去实现这个draw、去把这个draw函数做出来，然后它就能够在这个View和Field的之间的关系里头被画出来了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214123832783.png" alt="image-20250214123832783"></p>
<p>我们回到主程序，我们看到的和细胞很像啊。我们的构造里头，这一个两重的循环去往里面填东西，然后根据可能性往里面放狐狸或者兔子到田里头去：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214173608205.png" alt="image-20250214173608205"></p>
<p>然后把窗口做出来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214173807870.png" alt="image-20250214173807870"></p>
<p>——这跟我们前面的细胞自动机几乎是一样的。</p>
<p>在start里面：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214174904384.png" alt="image-20250214174904384"></p>
<p>在每一步里做的事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214175844107.png" alt="image-20250214175844107"></p>
<p>Animal的grow做的事情也很简单：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214180421603.png" alt="image-20250214180421603"></p>
<p>所以在<code>FoxAndRabbit</code>的这里，grow了之后：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214181006560.png" alt="image-20250214181006560"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214181014676.png" alt="image-20250214181014676"></p>
<p>remove做的事情也很简单：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214181847406.png" alt="image-20250214181847406"></p>
<p>然后如果是活着的，就要做三个动作：move（移动）、eat（吃）、breed（生小baby）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214182146096.png" alt="image-20250214182146096"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214182159866.png" alt="image-20250214182159866"></p>
<p>🍎接口的方法和实现</p>
<p>那么这些事情一个个来看是怎么做的：</p>
<p>1）move 移动：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214182847889.png" alt="image-20250214182847889"></p>
<p>所以animal有一个move函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214183527794.png" alt="image-20250214183527794"></p>
<p>所以如果那个Animal决定要移动：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214183711153.png" alt="image-20250214183711153"></p>
<p>2）eat 吃：比较复杂点：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214185545494.png" alt="image-20250214185545494"></p>
<p>——这一块高亮的地方做完之后，我们得到了当前这个邻居周围所有的兔子。</p>
<p>然后：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214185846385.png" alt="image-20250214185846385"></p>
<p>而animal的feed，对于Animal来说，它的feed做的事情是 什么也不吃：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214190106947.png" alt="image-20250214190106947"></p>
<p>而对于Rabbit来说，它就没有feed函数，所以它也什么都不吃：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214190605000.png" alt="image-20250214190605000"></p>
<p>对于Fox来说，它的feed函数就要吃了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214191130088.png" alt="image-20250214191130088"></p>
<p>如果决定吃：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214191301869.png" alt="image-20250214191301869"></p>
<p>🍎接口的继承和多态</p>
<p>3）breed 生baby：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214191346565.png" alt="image-20250214191346565"></p>
<p>而Animal的breed：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214191500891.png" alt="image-20250214191500891"></p>
<p>那么对于Fox来说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214191621358.png" alt="image-20250214191621358"></p>
<p>——我们在Animal里定义了一个变量，叫做<code>breedableAge</code>（可以生baby的年龄）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214191724182.png" alt="image-20250214191724182"></p>
<p>而<code>isBreedable</code>做的事情是说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214191944076.png" alt="image-20250214191944076"></p>
<p>所以对Fox来说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214192225805.png" alt="image-20250214192225805"></p>
<p>对Rabbit来说，也是一样的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214192302302.png" alt="image-20250214192302302"></p>
<p>然后对于主程序来说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214192541455.png" alt="image-20250214192541455"></p>
<p>这就是每一步做的动作，把这些东西组合起来就得到了我们的那个视觉效果。</p>
<blockquote>
<h3 id="Fox-breed-和Rabbit-breed-几乎一样"><a href="#Fox-breed-和Rabbit-breed-几乎一样" class="headerlink" title="Fox.breed()和Rabbit.breed()几乎一样"></a><code>Fox.breed()</code>和<code>Rabbit.breed()</code>几乎一样</h3><p>Q：<code>Fox.breed()</code>和<code>Rabbit.breed()</code>几乎一样，有什么好办法修改？注意Fox和Rabbit的breed()返回的具体类型不同。</p>
<p>A：可以把breed中公共的部分拿出来作为一个方法放在animal里命名为<code>ifBreed()</code>，返回Boolean类型，在子类fox rabbit的breed方法里就根据<code>ifBreed</code>结果判断返回null或者新建对象。</p>
</blockquote>
<h4 id="6-3-3-接口设计模式"><a href="#6-3-3-接口设计模式" class="headerlink" title="6.3.3 接口设计模式"></a>6.3.3 接口设计模式</h4><p>🍎接口的概念和作用</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214192715896.png" alt="image-20250214192715896"></p>
<p>所以这个程序大体上是这样子的：（当然我们在讲解的时候，不可能把所有的细节讲的非常细，一定是你自己要花很多的时间去把这个代码一条一条的读明白）</p>
<p>在这个里面，我们看到我们用了一个新的东西，叫做<strong>interface</strong>（接口）。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214203125882.png" alt="image-20250214203125882"></p>
<p>我们的这个Cell不再是一个<code>public class Cell</code>，我们的Cell是一个：<code>public interface Cell</code>。interface取代了那个class的位置。</p>
<p>🍎接口的定义和实现</p>
<p>在Java当中，interface（接口）是一种Class。</p>
<p>interface是一种特殊的Class，他和Class的地位是一样的。所谓的地位是一样的意思是：你定义出了一个interface，那么所有可以出现class的地方都可以出现interface。</p>
<p>也就是说，如果你是一个class Cell，这个Cell可以出现在什么地方（比如说用来定义变量的类型、用来定义参数的类型、用来定义函数的返回类型），现在我们用这个interface Cell都是一样可以用的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214203516051.png" alt="image-20250214203516051"></p>
<p>当我们有一个类要实现一个interface的时候，我们用另外一个关键字叫做implements。而不是用extends。extends是用来表达继承关系的。implements是用来表达类去实现了某个接口的。——一个类去实现接口。</p>
<p>在实现接口的时候，一个类可以实现多个接口。</p>
<p>接口本身可以做继承：一个接口可以继承自另一个接口，但接口不能继承自别的类。接口自己可以实现接口和接口之间的继承。</p>
<p>接口出现之后，给Java的程序设计带来了全新的面貌。接口是什么？interface、界面接口，讲的就是两个东西之间的那种连接。</p>
<p>所以interface在Java中起到的作用就是：当你需要别人为你提供服务的时候、当你需要一个别的什么东西的时候，你不是去定义一个类出来，而是先去定义一个接口出来。</p>
<p>（比如说，我们从关系说来看：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214204118744.png" alt="image-20250214204118744"></p>
<p>Field的定义说我只认识Cell，我和背后的那个View我们俩只认识那个Cell。你有任何东西想要给我，它得符合Cell的定义、它得是一个Cell、它是一个Cell你就可以给我——这就是接口的含义。其实Cell不是这边Animal这些东西定义的，Cell是由这边的Field和View定义出来的说：所有想要放到我的这个体系当中、能够用由我来管理、能够由View来显示的东西，必须它是一个Cell。然后它可能还是别的东西，我不关系、我不care。）</p>
<p>🍎接口在程序设计中的应用</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214205356279.png" alt="image-20250214205356279"></p>
<p>因此这给Java程序带来一种模式，在设计程序的时候，先定义接口，再实现类。</p>
<p>需要在函数之间传入传出的是接口而不是具体的类。不是把一个具体的（比如说Animal、Fox、Rabbit这样实体的东西）东西传给Field，而是由Field自己定义的Cell、这样一个空的没有任何实际东西的接口，来传进传出。</p>
<p>这样做的好处事实上就是，使得很多人同时做一个程序变得容易了。因为每一个人他只要提出我对别人写的程序样有什么要求，我提出一个接口就好了，然后别人就根据这个接口的要求做他自己的事情。由这个接口去<strong>分隔开</strong>每一个人和每一个人、或者说每一个类、或者是程序的每一个部件和另外一个部件之间的那种关系。</p>
<p>所以这是Java取得成功的很重要的一个关键。很多架构做的好的大型程序我们会看到大量的这样的接口的存在。</p>
<p>但是呢，由于这些接口的存在，原本我可能就写一个类就够了，我现在需要先写一个接口，再写一个类；甚至可能是写几个接口写一个类、或者写几个接口写几个类。那么程序的代码量快速的就膨胀了，程序很快就变得非常复杂。这也是Java这种语言受到很多人批评的地方。</p>
<p>同样也是在这个地方——就是他成功也是因为有接口，所以多人合作做的很好。很多人批评他也是由于有接口这样的东西，所以整个程序非常的臃肿。</p>
<p>🍎接口与程序模块的关系</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214205653475.png" alt="image-20250214205653475"></p>
<p>那么这里面很有意思的一个事情就是Cell和Field的关系：</p>
<p>我们知道Cell在Field当中，但是其实Cell的很多操作是需要Field的数据的，而我们现在的做法，以eat为例：</p>
<p>1）：（方法二）</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214205719519.png" alt="image-20250214205719519"></p>
<p>我们现在方法是说：让这个Field给出这个Cell它周围的邻居，然后在外面由<code>FoxAndRabbit</code>(事务逻辑编辑 Transaction logic editing)、也就是logic的这个类，它来去遍历这个邻居（for循环部分），找到所有的Rabbit，然后再交给这个Fox去吃（ if 判断部分）。</p>
<p>2）（方法一）如果说Cell自己是知道Field的，那么我们其实在这很简单：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214210153408.png" alt="image-20250214210153408"></p>
<p>——这样就完了。甚至如果在这里把这个Field交进去可能也是可以的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214210232429.png" alt="image-20250214210232429"></p>
<p>但是呢，如果这么做就要意味着一件事情就是：Animal是要知道Field的。</p>
<p>🍎接口的优缺点和使用注意事项</p>
<p>其实在我们现在的代码（方法2）里头，Animal也好、Fox也好、Rabbit也好，根本不知道Field是怎么回事，完全不知道。</p>
<p>好处是什么？独立、耦合松。在这个代码当中，如果在中间拉一条线：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214210450318.png" alt="image-20250214210450318"></p>
<p>我可以把这个程序拆成两个，我可以把Animal、Fox、Rabbit用到其他任何别的程序里头去，可以和我现在的业务逻辑没有任何关系。</p>
<p>可是复杂在哪呢？那就是我们从另一个角度去考虑：原本Fox去吃Rabbit这件事情是Fox自己可以完成所有的形式（Fox去看一眼我周围有没有什么东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214210709821.png" alt="image-20250214210709821"></p>
<p>——其实就是一个九宫格嘛，Fox可以去看我周围比如说有这样三只兔子，我决定吃右上角的那个——这个事儿可以由这个东西Fox自己来做的。但现在呢，我们必须有一个第三者，也就是我们的那个<strong>business logic</strong>（业务逻辑）来做。</p>
<p>好处当然很明显：划分开了。</p>
<p>缺点就是这个business logic承担了外面的事情。</p>
<blockquote>
<h3 id="Cell要不要知道Field？"><a href="#Cell要不要知道Field？" class="headerlink" title="Cell要不要知道Field？"></a>Cell要不要知道Field？</h3><p>Q：在城堡游戏中，Handler是知道Game的；在细胞自动机中，Cell是不知道Field的。在现在版本的狐狸与兔子中，Cell也是不知道Field的。</p>
<p>那么，如果让Cell知道Field会怎样呢（我们的程序要怎么改）？两种做法各有什么优缺点呢（这样改出来的程序是更好了还是更糟糕了、或者只是不同的想法有不同的评价标准而已）？</p>
<p>A：<code>cell</code>如果知道field的话，那么cell就可以自己判断邻居情况，move，remove，eat等动作就可以由animal们自己完成了，但是缺点就是，cell和field就是深耦合了。</p>
<p>现在cell不知道field，所以没办法判断邻居情况，所以实现了cell的animal们不能自己move等</p>
<p>两种方法各有利弊</p>
</blockquote>
<blockquote>
<h3 id="要不要Animal-的列表？"><a href="#要不要Animal-的列表？" class="headerlink" title="要不要Animal 的列表？"></a>要不要Animal 的列表？</h3><p>Q：如果另外用一个<code>ArrayList&lt;Animal&gt;</code>来表示所有的动物，每一步遍历这个列表而非整个Field，这样做是否更好？</p>
<p>（实际上这里面还牵扯到另一件事情，Animal是不知道Field的。我们在代码中Animal自己是没有Location的，它不知道自己在哪。所以在business logic（<code>FoxAndRabbit</code>）中是我每次遍历到一个位置拿出来了一个动物，然后让这个动物做些事情。可这些动物做的任何事情（比如说move也好、eat也好、包括breed的时候也好）的时候，都和它自己的位置是相关的。所以如果让它知道自己的位置，会不会这个事情会做的更加巧妙一点呢？）</p>
<p>提示：这样就需要每个Animal知道自己在Field里的位置</p>
<p>A：如果要直接有一个animal的<code>ArrayList</code>的话，那么animal需要知道自己location，那么他和location之间必然是耦合的，没必要</p>
</blockquote>
<blockquote>
<h3 id="要不要把数据和表现进一步分离？"><a href="#要不要把数据和表现进一步分离？" class="headerlink" title="要不要把数据和表现进一步分离？"></a>要不要把数据和表现进一步分离？</h3><p>Q：现在Cell接口其实是承担了两个责任的。在Field看过来，它只认识Cell，它认为Cell是存放在其中的数据。而对于View来说，它看到的是Cell所具有的draw方法，从这个角度来说Cell表示了表现。</p>
<p>有没有必要两种分开。比如有一个Cell抽象类表示可以放进Field的东西，另一个Drawable接口表示可以被Vier画出来的东西？</p>
<p>A：就目前来看，cell这个接口也没干活就只干了一个draw一个活，没必要进一步分离了；后续随着代码量增多，项目变庞大之前可以考虑拆开。</p>
<p>将数据和表现进一步分离可以使代码清晰，可维护和可扩展</p>
</blockquote>
<p>所以这些就留给你来做进一步的讨论，拿我们现在的这个代码去做一些修改，按照各种可能的方式来试试看把代码写出来。实际的代码和我现在这边给的这种代码做一个比较，看看哪一种更加符合你自己的心意。</p>
<h2 id="第7周控制反转与MVC模式"><a href="#第7周控制反转与MVC模式" class="headerlink" title="第7周	控制反转与MVC模式"></a>第7周	控制反转与<code>MVC</code>模式</h2><h3 id="7-1-控制反转"><a href="#7-1-控制反转" class="headerlink" title="7.1 控制反转"></a>7.1 控制反转</h3><blockquote>
<p>[!NOTE]</p>
<h3 id="图形用户界面GUI"><a href="#图形用户界面GUI" class="headerlink" title="图形用户界面GUI"></a>图形用户界面GUI</h3><p>GUI（图形用户界面（<code>[ˌdʒi ju ˈaɪ]</code>，注意发音，类似于“咕意”））给应用程序提供界面,其中包括窗口、菜单、按钮和其他图形组件,这就是今天大多数人所熟悉的“典型”应用程序界面。</p>
<p>图形用户界面所涉及的细节很多,我们的课程并不打算教授GUI，但是我们打算借助GUI来介绍两个设计思想：控制反转和MVC设计模式。</p>
<p>部件是创建GUI的独立部分,比如像按钮、菜单、菜单项、选择框、滑动条、文本框等。Java类库中有不少现成的部件。</p>
<p>布局是指如何在屏幕上放置组件。过去,大多数简单的GUI系统让程序员在二维坐标系上 指定每个组件的x和y坐标(以像素点为单位),这对于现代的GUI系统来说太简单了。因为现代的GUI系统还得考虑不同的屏幕分辨率、不同的字体、用户可改变的窗口尺寸,以及许多其他使得布局困难的因素。所以需要有一种能更通用地指定布局的方法,比如,要求“这个部件应该在那个部件的下面“或者”这个部件在窗口改变尺寸时能自动拉伸,但是其他部件保持尺寸不变”。这些可以通过布局管理器(layout manager)来实现。</p>
<p>事件处理是用来响应用户输入的技术。创建了部件并且放在屏幕上合适的位置以后,就得 要有办法来处理诸如用户点击按钮这样的事情。Java类库处理这类事情的模型是基于事件的。 如果用户激活了一个部件(比如,点击按钮或者选择菜单项),系统就会产生一个事件。应用 程序可以收到关于这个事件的通知(以程序的一个方法被调用的方式),然后就可以采取程序该做的动作了。</p>
</blockquote>
<h4 id="7-1-1-布局管理器"><a href="#7-1-1-布局管理器" class="headerlink" title="7.1.1 布局管理器"></a>7.1.1 布局管理器</h4><p>🍎按钮的添加与布局管理器</p>
<p>我们的这个狐狸与兔子的程序是挺好，不过呢，有一个很大的缺点：它只会自己动，而且一步一步走的挺快的（当然我们在程序里面可以去调它的速度&#x2F;每一次延时的那个时间）。可是好像还是觉得看不清楚它每一步到底是怎么变的。</p>
<p>我们能不能给他加个按钮？既然这是一个图形程序嘛，能不能加个按钮？然后呢，按钮按一下走一步，按钮按一下走一步。这事儿要怎么做呢？</p>
<p>首先，要有一个按钮，我们可以把它放在这儿，在这个<code>FoxAndRabbit</code>类初始化的时候：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214222414802.png" alt="image-20250214222414802"></p>
<p>——我们在做了这个frame之后，我们需要往这个窗口里头加一个按钮。你看，现在是这样：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214222536457.png" alt="image-20250214222536457"></p>
<p>我们现在的这个整个窗口就是我们现在的画面。我们做了一个自己的View，然后整个View就占据了整个窗口，然后呢，只有左上角三个窗口的控制按钮、没有其他东西了。</p>
<p>我们想要加一个按钮进去，这事要怎么做呢？我们不妨在这儿（38行），我们把这个View加到这个frame窗口里头去之后，我们来做一个按钮出来：</p>
<p>🍎容器与部件的关系</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214223002150.png" alt="image-20250214223002150"></p>
<p>——我们先来看如果这样行不行。我们来跑一下这个程序，我们看到整个程序就只剩下这个单步按钮了，别的什么都没有了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214223040533.png" alt="image-20250214223040533"></p>
<p>怎么回事呢？因为我们加错了：我们加这个按钮的时候我们得再给一个参数<code>BorderLayout.NORTH</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">theView = <span class="keyword">new</span> <span class="title class_">View</span>(theField);</span><br><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"><span class="comment">//做了一堆设置</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">frame.setResizable(<span class="literal">false</span>); <span class="comment">//不可以改变大小</span></span><br><span class="line">frame.setTitle(<span class="string">&quot;Cells&quot;</span>); <span class="comment">//它的title是Cells</span></span><br><span class="line">frame.add(theView); <span class="comment">//在这个frame里面把刚才的那个view给加进去</span></span><br><span class="line"><span class="comment">//加一个按钮，然后加到frame里去</span></span><br><span class="line"><span class="type">JButton</span> <span class="variable">btnStep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;单步&quot;</span>);</span><br><span class="line">frame.add(btnStep, BorderLayout.NORTH);</span><br><span class="line">frame.pack(); <span class="comment">//让它自己决定一下大小</span></span><br><span class="line">frame.setVisible(<span class="literal">true</span>); <span class="comment">//把整个图形窗口显示出来</span></span><br></pre></td></tr></table></figure>

<p>我们先来运行一下，然后我来解释怎么回事：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214223308552.png" alt="image-20250214223308552"></p>
<p>现在在我们的网格上面多了一个按钮，当然这个按钮非常大，好看难看这是另外一回事，至少我们现在有了一个按钮。——这个按钮和网格是分开的、这个按钮显示了单步这两个字、并且看上去是能够按的、并且按了以后它是有反应的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214223455085.png" alt="image-20250214223455085"></p>
<p>——当然现在下面的程序还没做，所以它还没有任何的动作可以发生。</p>
<p>为什么我们在这儿说NORTH呢？为什么要说是<code>BorderLayout.NORTH</code>？</p>
<p>🍎布局管理器与容器的管理</p>
<p>这个故事在这儿：</p>
<p>我们现在用的图形的这一套东西，这套机制叫做swing。swing的基本概念是说：你在界面&#x2F;图形当中看到的所有东西都叫做部件。</p>
<p>所以我们有那么一个窗口，然后呢我们看到是说这个窗口的左上角有三个按钮。然后下面呢是我们做的单步按钮，再下面是网格：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214223930602.png" alt="image-20250214223930602"></p>
<p>那swing的基本概念是说：所有的东西都是叫做部件，然后呢另外有一种东西叫做容器。</p>
<p>把名字放在这里大家就应该能猜得出来，它基本的想法是说：我有一个容器（比如叫frame），然后我可以在容器里面放一个部件（比如说那个button）。——部件可以被放在容器里面：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214224200621.png" alt="image-20250214224200621"></p>
<p>而另外一个层次来说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214224223969.png" alt="image-20250214224223969"></p>
<p>——你看我们画成这个样子，你应该从之前我们讲继承的时候看到过这样的东西，标明说：<strong>容器本身也是一种部件</strong>。所以容器也能被放在另外一个容器里面：</p>
<p>比如说，在我们的程序里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">theView = <span class="keyword">new</span> <span class="title class_">View</span>(theField);</span><br><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"><span class="comment">//做了一堆设置</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">frame.setResizable(<span class="literal">false</span>); <span class="comment">//不可以改变大小</span></span><br><span class="line">frame.setTitle(<span class="string">&quot;Cells&quot;</span>); <span class="comment">//它的title是Cells</span></span><br><span class="line">frame.add(theView); <span class="comment">//在这个frame里面把刚才的那个view给加进去</span></span><br><span class="line"><span class="comment">//加一个按钮，然后加到frame里去</span></span><br><span class="line"><span class="type">JButton</span> <span class="variable">btnStep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;单步&quot;</span>);</span><br><span class="line">frame.add(btnStep, BorderLayout.NORTH);</span><br><span class="line">frame.pack(); <span class="comment">//让它自己决定一下大小</span></span><br><span class="line">frame.setVisible(<span class="literal">true</span>); <span class="comment">//把整个图形窗口显示出来</span></span><br></pre></td></tr></table></figure>

<p>我们的frame（第2行）是一个容器，这是一个大窗口。</p>
<p>我们的View（第1行）也是一个容器，在这个View里，我们可以画出网格。View是要被加到这个frame里面去的（第7行）。所以容器可以被加到另外一个容器里面去。</p>
<p>而我们的button（第9行）也得要加到容器里面去（第10行）——我们通过add这种动作把一个部件加到另外一个容器里面去，使得这个部件在那个容器里面出现、在那个容器里面存在、并且在那个容器里面受它的管理。</p>
<p>🍎<code>BorderLayout</code>布局管理器</p>
<p>那容器对当中的部件的管理呢，其中有一个重要的作用就是要去管这个部件在哪里，这个部件显示出&#x2F;成多大——这是容器要去管的事情。</p>
<p>容器去管里面的部件用的手段叫做布局管理器（<code>Layout manager</code>）。因为里面有什么样的东西放在什么地方，这件事情叫做布局（Layout）。所以<code>Layout manager</code>用来管这个。</p>
<p>对于frame来说，默认采用的布局管理器是叫做border，就是我们刚才看到的那个<code>BorderLayout.NORTH</code>的那个border——也就是<code>BorderLayout</code>。</p>
<p><code>BorderLayout</code>它以一种特殊的方式来管里面的东西。是这样子的，对frame这样的容器来说，它用了<code>BorderLayout</code>它就把整个frame划分成了五块区域：北面NORTH（north）、南面SOUTH（south）、东面EAST（east）、西面WEST（west）、中间叫做CENTER（center）。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214225325732.png" alt="image-20250214225325732"></p>
<p>——所以当你把东西把部件加到一个有<code>BorderLayout</code>的容器里头去的时候，其实你是需要指定你把它加到哪去的。</p>
<p>我们一开始犯得错误是什么呢？如果你不指定加到哪里（就像<code>frame.add(theView);</code>并没有指定加到哪里），它的意思相当于我在这说我要add到<code>BorderLayout</code>的那个CENTER（<code>frame.add(theView, BorderLayout.CENTER);</code>，这是一样的。</p>
<p>所以我们一开始,，add button的时候没有加上<code>BorderLayout.NORTH</code>结果是什么呢？就是我们把那个button也加到CENTER去了。然后在同一个位置上面，同一时间它只能有一个部件——所以我第一次加了一个View在CENTER，第二次如果我把step又加到CENTER里去的话，它就把那个CENTER给替换掉了，那个View就不在存在于这个容器当中，而是由后面加入的按钮存在那里。</p>
<p>所以就变成是说，我的frame里面只有这个按钮而没有那个View了。</p>
<p>🍎<code>Layout Manager</code>的优势与使用</p>
<p>我们可以再试一下如果我们把这个加在不是NORTH，加在别的地方：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214230251045.png" alt="image-20250214230251045"></p>
<p>——我们在程序的左边有了一个按钮：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250214230323100.png" alt="image-20250214230323100"></p>
<p>所以<code>BorderLayout</code>就是以这种方式做事情的，就是你需要指定说我要把它加到哪里。</p>
<p>那么当然我们当初那个程序呢，我们NORTH有东西、CENTER有东西，另外三边没有东西，没有东西怎么办？CENTER就可以膨胀出来把另外三边都给占据了。</p>
<p>另外我们刚才看到说，当我们把那个按钮放在NORTH的时候，那个按钮是占据了整个窗口那么宽，然后呢高度只是他自己那点文字能够显示出来的高度；而当我们把它放在WEST的时候，它的宽度就刚好能够把【单步】这两个字给显示出来那么一点点宽，而高度是占据了整个窗口的高度。</p>
<p>所以<code>BorderLayout</code>的好处就是：它会帮我们去计算、根据你里面放的东西来计算应该把你放在什么样的地方、放成什么样子。</p>
<p>Layout Manager是Java的swing机制当中一个蛮特殊的东西，因为在其他的GUI（<code>[ˌdʒi ju ˈaɪ]</code>，注意发音，类似于“咕意”）平台当中、GUI的类库当中，没有看到类似的这种手段。</p>
<p>Layout Manager的好处是什么呢？就是你不是自己去指定说我要把这个按钮比如说显示在坐标为x多少y多少的地方、我要显示这个按钮的长是多少高是多少…这种参数不是由程序员自己去指定，而是由底下的类库帮你去计算。</p>
<p>那么这样做的好处是什么呢？就是当你的显示的环境发生变化的时候，Layout Manager能够帮你根据当时的实际的显示的情况（比如说你实际窗口大小等等），来帮你计算出一个合适的视觉效果出来。</p>
<p>那么当然它不见得是最漂亮的。通常它不是最漂亮的，但是它能保证所有东西都能够被用户看见。——因为假如说你采用绝对坐标，你说我的这个按钮一定要在x&#x3D;600，y&#x3D;200的地方，那么如果你的浏览器比如说在一个手机上面，它的分辨率根本没有达到600（根本600这个坐标是显示不出来的），那么你整个按钮就看不见了。</p>
<p>而Java的这种做法，最起码能让你的用户看见这个按钮在哪儿，虽然它可能不见得很漂亮。</p>
<h4 id="7-1-2-控制反转"><a href="#7-1-2-控制反转" class="headerlink" title="7.1.2 控制反转"></a>7.1.2 控制反转</h4><blockquote>
<p>[!NOTE]</p>
<h3 id="Swing的事件机制"><a href="#Swing的事件机制" class="headerlink" title="Swing的事件机制"></a>Swing的事件机制</h3><p>Swing使用一个非常灵活的模型来处理GUI的输入:采用事件监听器的事件处理(event handling)模型。</p>
<p>Swing框架本身以及大部分部件在发生一些情况时会触发相关的事件,而其他的对象也许会对这些事件感兴趣。不同类型的动作会导致不同类型的事件。当点击一个按钮或选中一个菜单项,部件就会触发动作事件;而当点击或移动鼠标时,会触发鼠标事件;当框架被关闭或最小化时,会触发窗口事件。另外还有许多种其他事件。</p>
<p>所有的对象都可以成为任何这些事件的监听器,而一旦成为监听器,就可以得到这些事件触发的通知。</p>
<p>实现了众多监听器接口之一的对象就成为一个事件监听器。如果对象实现了恰当的接口, 就可以注册到它想监听的组件上。</p>
</blockquote>
<p>🍎消息机制</p>
<p>现在呢，我们的这个按钮有了，可是我们的按钮按下去是没反应的，那么怎么能够让它有反应呢？</p>
<p>也就是说，按下按钮之后，我的程序怎么能够知道这个按钮被按下去了？——用户在图形界面上面做了一个操作，这个操作怎么能够让程序知道，这中间走过去的那个路径，我们把它叫做<strong>消息机制</strong>。</p>
<p>Java的swing实现了一个很有意思的消息机制，我们来看看它是怎么做的：</p>
<p>在7.1.1的代码当中，我们实现了说，我们加入了一个按钮，这个按钮确实能够被显示出来。但是呢，我们并没有说如果这个按钮被按下去，它怎么能够让我们的程序知道，所以我们得要这么做：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215132100101.png" alt="image-20250215132100101"></p>
<p>——敲完之后它自动给我出现了这么一大堆的东西：我们先在这个函数里做点事情（比如说System out），说按下啦！：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">theView = <span class="keyword">new</span> <span class="title class_">View</span>(theField);</span><br><span class="line"><span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"><span class="comment">//做了一堆设置</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">frame.setResizable(<span class="literal">false</span>); <span class="comment">//不可以改变大小</span></span><br><span class="line">frame.setTitle(<span class="string">&quot;Cells&quot;</span>); <span class="comment">//它的title是Cells</span></span><br><span class="line">frame.add(theView); <span class="comment">//在这个frame里面把刚才的那个view给加进去</span></span><br><span class="line"><span class="comment">//加一个按钮，然后加到frame里去</span></span><br><span class="line"><span class="type">JButton</span> <span class="variable">btnStep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;单步&quot;</span>);</span><br><span class="line">frame.add(btnStep, BorderLayout.NORTH);</span><br><span class="line"><span class="comment">//让这个buttonStepadd一个ActionListener。</span></span><br><span class="line"><span class="comment">//这个函数要的是一个ActionListener的对象，所以我们就制造一个给它。</span></span><br><span class="line">btnStep.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;按下啦！&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">frame.pack(); <span class="comment">//让它自己决定一下大小</span></span><br><span class="line">frame.setVisible(<span class="literal">true</span>); <span class="comment">//把整个图形窗口显示出来</span></span><br></pre></td></tr></table></figure>

<p>我们通过这个可以知道说：如果我们在console（控制台）得到了这么一个【按下啦！】的文字，我们就知道说这个按钮真的被按下了。至于这当中是怎么走过来的我们待会再来看，我们先来看这事情是不是可以做的到：</p>
<p>🍎按钮被按下</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215132503270.png" alt="image-20250215132503270"></p>
<p>——我们按一下这个【单步】按钮，console出现了一个按下啦！。再来按一次，又出现了一次按下啦。</p>
<p>也就是说，我们每次按下这个单步按钮，我们就会走到这个System out的地方（16行）来、这里的代码会被执行。</p>
<p>那这儿到底发生了什么呢？我们到底做了什么东西呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215132713956.png" alt="image-20250215132713956"></p>
<p>看起来这里非常古怪的代码，我们一点点来解释这件事情：</p>
<p>我们现在的问题是说，我们现在有了一个按钮，按钮自己的代码（显然按钮肯定自己有代码）能够知道说某一个时刻按钮被按下了。</p>
<p>然后我们自己有一个代码，实际上我们自己已经写好了一个代码：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215132926695.png" alt="image-20250215132926695"></p>
<p>——我们的程序中有一个step函数，这个函数做的事情是单步。然后我们另外一个start的函数是循环的去做那一步。——其实我们现在只要把System out的地方加上一个对step的调用（我们待会再来说为什么这里能调那个step），然后让frame去repaint一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215133147602.png" alt="image-20250215133147602"></p>
<p>当然在这之前我们还要做个改造：我们要把这个frame给它拿出来，成为我们这个类的一个成员变量：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215133306927.png" alt="image-20250215133306927"></p>
<p>然后呢这样它就是对那个成员变量frame做操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">theView = <span class="keyword">new</span> <span class="title class_">View</span>(theField);</span><br><span class="line">frame = <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"><span class="comment">//做了一堆设置</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">frame.setResizable(<span class="literal">false</span>); <span class="comment">//不可以改变大小</span></span><br><span class="line">frame.setTitle(<span class="string">&quot;Cells&quot;</span>); <span class="comment">//它的title是Cells</span></span><br><span class="line">frame.add(theView); <span class="comment">//在这个frame里面把刚才的那个view给加进去</span></span><br><span class="line"><span class="comment">//加一个按钮，然后加到frame里去</span></span><br><span class="line"><span class="type">JButton</span> <span class="variable">btnStep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;单步&quot;</span>);</span><br><span class="line">frame.add(btnStep, BorderLayout.NORTH);</span><br><span class="line"><span class="comment">//让这个buttonStepadd一个ActionListener。</span></span><br><span class="line"><span class="comment">//这个函数要的是一个ActionListener的对象，所以我们就制造一个给它。</span></span><br><span class="line">btnStep.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;按下啦！&quot;</span>);	</span><br><span class="line">		step();</span><br><span class="line">		frame.repaint();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">frame.pack(); <span class="comment">//让它自己决定一下大小</span></span><br><span class="line">frame.setVisible(<span class="literal">true</span>); <span class="comment">//把整个图形窗口显示出来</span></span><br></pre></td></tr></table></figure>

<p>再接下去，我们要把main里面的这个start给去掉：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215133432655.png" alt="image-20250215133432655"></p>
<p>——我们不要你主动的开始，我们希望的是在每次按下按钮之后，我们去单步做一个词，然后去repaint一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215133537496.png" alt="image-20250215133537496"></p>
<p>我们出现了这个静止的画面，然后按一下单步按钮它就会单步走一步。</p>
<p>🍎控制反转</p>
<p>这中间是怎么回事呢？我们说到，我们有那个按钮<code>btnStep</code>(button step）、我们有一个step函数，这是预先写好的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215133815411.png" alt="image-20250215133815411"></p>
<p>我们希望发生的事情是：按钮被按下去的时候，它能去调用这个函数。</p>
<p>怎么做到的？我们知道的是，按钮是一个类，按钮这个类里面它一定有代码知道自己被按下去了（这个事情我们先不用去操心，比如说它是怎么检测到鼠标现在移动到按钮上面、然后鼠标左键又按下去了），而且我们已经看到它视觉效果也给你做出来了，然后它怎么能够调我们的step函数？</p>
<p>我们之前学过的所有的东西都知道说：如果你要去调我的step函数，一定是你在某个地方写了那么一个，比如说按钮现在有一个函数叫做depressed，按下去了之后在这个函数里面做出了那个显示效果，然后它来调了我们的<code>FoxAndRabbit</code>的一个对象（比如说叫做f）<code>FoxAndRabbit f</code>，然后这个f去做了step的动作<code>f.step()</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215134436807.png" alt="image-20250215134436807"></p>
<p>——如果我的按钮里面有这样一个代码，那么当然这个代码是可以去调用我的step的。</p>
<p>但这样就意味着：（因为我的button step是<code>JButton</code>类的对象）我在写这个<code>JButton</code>类的时候，我要在它的代码里面把这些东西给放进去。也就是说，<code>JButton</code>类在写出来的时候，它得要知道我今天在这里做的这个<code>FoxAndRabbit</code>长什么样子、得要知道我这里有一个step、得要知道那个<code>JButton</code>类对象按下去的时候，它能够调用的step。</p>
<p><code>JButton</code>类，这是Oracle、更准确的说是当年Sun做出来的东西，它怎么可能知道我的<code>FoxAndRabbit</code>。</p>
<p>🍎动态注入</p>
<p>那怎么做这件事呢？如果现在要你来想，说我面临这么一个局面、我有一个按钮是事先写好的，然后我有一个函数，我需要这个事先写好的按钮里头某一个函数执行的时候，能够去执行我的这个函数。你会有什么办法？</p>
<p>也许我能不能这样子做：我实现做一个类，叫做my button，它从这个button里派生出来（继承）。在这个my button里头，它要去Override那个（比如说有一个叫做<code>dopress</code>的函数）。（去继承那个类去改写那个函数）</p>
<p>Override这个函数以后，在这个函数里面（因为这是我自己写的）所以我可以去做这件事：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215135317904.png" alt="image-20250215135317904"></p>
<p>——但原来的那个做不了这件事。</p>
<p>这是一种思路，但是swing没有采用这个思路。swing觉得这个思路还不够先进，我含义更先进的：</p>
<p>说我这里有一个按钮，这是<code>JButton</code>类的，在某个时候它会被按下去，它自己能够知道它被按下去了。于是呢，它说这样：我给你一个接口，这个接口叫做<code>ActionListener</code>（动作守&#x2F;监听者）。然后呢，我有一对函数，叫做<code>addActionListener</code>和<code>removeActionListener</code>。如果你对我被按下去这件事感兴趣，那么你就实现一个<code>ActionListener</code>接口的对象。</p>
<p>这个<code>ActionListener</code>接口就定义了一个事情，叫做<code>actionPerformed</code>（动作执行了）函数。所以如果你去实现了这个接口，当然你里面也会有这样一个<code>actionPerformed</code>的函数。然后你就把这个类（<code>actionPerformed</code>）制造出来的一个对象，通过这个add函数（<code>addActionListener</code>）注册给我（按钮）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215140001334.png" alt="image-20250215140001334"></p>
<p>——注册进去的东西这是一个运行时刻动态的对象，然后一旦按钮被按下去，它就要做这件事情：检查一下现在有没有人注册在我这儿，说对我被按下去这件事情感兴趣？</p>
<p>如果有的话，那个注册上来的东西它一定是实现了这个<code>ActionListener</code>接口的一个东西，而<code>ActionListener</code>是<code>JButton</code>发布的，<code>JButton</code>当然知道<code>ActionListener</code>长什么样、知道<code>ActionListener</code>里有<code>actionPerformed</code>的函数。于是它就可以循着这条线回过来调你的<code>actionPerformed</code>的函数。</p>
<p>🍎反转控制</p>
<p>也就是说，<code>JButton</code>作为一个已经存在的类，它公布一个接口，任何人对它被按下去这件事感兴趣，只要遵循这个接口去实现这个接口的一个类，把这个类的对象交给你（我注册一个实现了<code>ActionListener</code>的接口类的对象，给<code>JButton</code>）。一旦被按下去，就会反过来找到你自己写的那个<code>actionPerformed</code>函数，并把其中的代码给执行了。——这件事情我们叫做<strong>反转控制</strong>。</p>
<p>（有很多不同的叫法，叫这个<strong>注入反转</strong>啦（因为这是注册进去嘛，所以叫注入反转）（<code>JButton</code>里面原本没有这样一个代码、这个代码是后来人写的，但是通过这么一个动态注入的过程，加进去了，所以叫注入反转））</p>
<p>当然，简单的就说这是swing的消息机制。</p>
<p>这个消息机制在我们的代码里面就说这样子的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215141036906.png" alt="image-20250215141036906"></p>
<p>——我们在代码里面调用了这个按钮（<code>btnStep</code>）的一个叫做<code>addActionListener</code>的函数，并制造了一个实现了<code>ActionListener</code>的类出来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215141206810.png" alt="image-20250215141206810"></p>
<p>——等等，这儿好像又有事情没有讲明白：我们怎么就制造了一个新的类出来？</p>
<p>见7.1.3：</p>
<h4 id="7-1-3-内部类"><a href="#7-1-3-内部类" class="headerlink" title="7.1.3 内部类"></a>7.1.3 内部类</h4><blockquote>
<p>[!NOTE]</p>
<p>内部类就是指一个类定义在另一个类的内部，从而成为外部类的一个成员。因此一个类中可以有成员变量、方法，还可以有内部类。实际上Java的内部类可以被称为成员类，内部类实际上是它所在类的成员。所以内部类也就具有和成员变量、成员方法相同的性质。比如，成员方法可以访问私有变量，那么成员类也可以访问私有变量了。也就是说，成员类中的成员方法都可以访问成员类所在类的私有变量。内部类最重要的特点就是能够访问外部类的所有成员。</p>
<p>内部类（<code>nei4 bu4 lei4</code>），念的时候可得小心了 -_-#。</p>
</blockquote>
<p>🍎控制反转</p>
<p>看到这里，相信你会说：道理我都懂，可是，这个代码是怎么回事呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">theView = <span class="keyword">new</span> <span class="title class_">View</span>(theField);</span><br><span class="line">frame = <span class="keyword">new</span> <span class="title class_">JFrame</span>();</span><br><span class="line"><span class="comment">//做了一堆设置</span></span><br><span class="line">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">frame.setResizable(<span class="literal">false</span>); <span class="comment">//不可以改变大小</span></span><br><span class="line">frame.setTitle(<span class="string">&quot;Cells&quot;</span>); <span class="comment">//它的title是Cells</span></span><br><span class="line">frame.add(theView); <span class="comment">//在这个frame里面把刚才的那个view给加进去</span></span><br><span class="line"><span class="comment">//加一个按钮，然后加到frame里去</span></span><br><span class="line"><span class="type">JButton</span> <span class="variable">btnStep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;单步&quot;</span>);</span><br><span class="line">frame.add(btnStep, BorderLayout.NORTH);</span><br><span class="line"><span class="comment">//让这个buttonStepadd一个ActionListener。</span></span><br><span class="line"><span class="comment">//这个函数要的是一个ActionListener的对象，所以我们就制造一个给它。</span></span><br><span class="line">btnStep.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;按下啦！&quot;</span>);	</span><br><span class="line">		step();</span><br><span class="line">		frame.repaint();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">frame.pack(); <span class="comment">//让它自己决定一下大小</span></span><br><span class="line">frame.setVisible(<span class="literal">true</span>); <span class="comment">//把整个图形窗口显示出来</span></span><br></pre></td></tr></table></figure>

<p>我们不是说按钮（<code>btnStep</code>，13行）会发出消息，我们这儿的代码说我们对按钮被按下去这件事感兴趣，因此我要用<code>addActionListener</code>。然后还要给它（<code>addActionListener</code>）一个实现了<code>ActionListener</code>的类的对象。</p>
<p>可是，这是什么东西呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215142710133.png" alt="image-20250215142710133"></p>
<p>好吧，这样，我们不要一步到位，一点点来，我们把这段代码给注释掉：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215142750904.png" alt="image-20250215142750904"></p>
<p>我们现在前面做一个类出来：我们的<code>StepListener</code>是实现<code>ActionListener</code>的。当然它会抱怨说这里面有我们没有实现的方法：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215142957324.png" alt="image-20250215142957324"></p>
<p>于是我们要把这个方法给它做出来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215143015784.png" alt="image-20250215143015784"></p>
<p>——然后它在京东帮我们补全了这些东西。</p>
<p>然后我们在里面做的事情依然可以是说：我们要去做step这件事情，做完了以后我们要让frame去repaint：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215143132339.png" alt="image-20250215143132339"></p>
<p>然后这个类做出来之后，我们在这儿做的事情就变成是说，要<code>addActionListener</code>一个我们刚刚做的这个东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215143230312.png" alt="image-20250215143230312"></p>
<p>——我们先来看这个效果是不是一样的。</p>
<p>结果是一样的，但不同在哪呢？</p>
<p>🍎内部类</p>
<p>我们现在的做法是说：我们在这儿放了一个类：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215143427673.png" alt="image-20250215143427673"></p>
<p>诶，等等，这还是有问题呀？我们这个类怎么放到<code>FoxAndRabbit</code>里头去了？</p>
<p>——在一个类的内部一个定义另外的类，那么这个类呢就成为我们叫做<strong>内部类</strong>的东西。内部的类，在别人里头的类叫做内部类。</p>
<p>如果我们把这个类拿到外头去，它就成为一个普通的类：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215143721844.png" alt="image-20250215143721844"></p>
<p>对于一个普通的类，这个private我们得要去掉，因为它在那讲不通：一个在外面的类private它没办法让别人去访问。</p>
<p>如果这个类在外面，对于下面的部分（<code>FoxAndRabbit</code>类）来说，如果我们要制造这个实现了<code>ActionListener</code>的接口的类，然后把它交给<code>btnStep</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215143923448.png" alt="image-20250215143923448"></p>
<p>——从这来说没有任何问题，这很正常。</p>
<p>但是，在这儿有问题：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215144005280.png" alt="image-20250215144005280"></p>
<p>——它不能去调用step，它也不能去访问frame。因为frame是<code>FoxAndRabbit</code>类的内部成员，而step也是一个内部的东西（当然现在它是一个public的函数）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215144104960.png" alt="image-20250215144104960"></p>
<p>所以如果我们把它放在外面去了，我们就不能直接去调step。我们需要：比如说它自己有一个<code>FoxAndRabbit</code>的成员变量&#x2F;对象。它有个构造函数叫<code>StepListener</code>，这个构造函数要一个<code>FoxAndRabbit</code>的对象作为输入，然后在里面把这个东西给记下来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215144328357.png" alt="image-20250215144328357"></p>
<p>它要做aa的step。对于repaint，它也不能直接做repaint，要有一个比如说aa的repaint之类的方法提供给它——那么我们在<code>FoxAndRabbit</code>里要实现一个方法repaint，它做点事情是让那个frame去repaint一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215144502535.png" alt="image-20250215144502535"></p>
<p>我们得要这么才能去实现这个东西，因为这个时候，<code>StepListener</code>和<code>FoxAndRabbit</code>没有关系，它们只是碰巧出现在同一个<code>.java</code>文件里而已，但是这两个类之间没有关系。</p>
<p>——我们不是这么做的，我们把这个东西拿进来。我们就不需要这个方法（27~29行）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215144705992.png" alt="image-20250215144705992"></p>
<p>也不需要这些东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215144803992.png" alt="image-20250215144803992"></p>
<p>我们可以直接使用它外面的所有成员（<code>StepListener</code>外，<code>FoxAndRabbit</code>的所有成员）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215144902351.png" alt="image-20250215144902351"></p>
<p>因为它是一个内部类。</p>
<p>Java的内部类是一个内部的成员，它和其他成员（成员函数、成员变量）一样。作为成员，它有成员的权力，就是可以去访问成员的东西（其他的成员、其他的成员函数、其他的成员变量）。——我们在这里正好就演示了这两点，它<code>StepListener</code>调用了其他的成员函数（step），也访问了其他的成员变量（frame），然后让那个成员变量又去调用了一个函数（repaint）。</p>
<p>——这是作为内部类的特权，我和那个frame和step一样，是这个<code>FoxAndRabbit</code>的一个成员，所以我可以使用这些东西。我不用考虑其他的。</p>
<p>作为一个内部类，它最大的<strong>好处</strong>就是：可以自由访问外部的东西。</p>
<p>🍎匿名类</p>
<p>那么我们一开始看到的东西是什么呢？我们现在把这个注释解掉：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215145349811.png" alt="image-20250215145349811"></p>
<p>如果没有下面高亮的部分：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215145419860.png" alt="image-20250215145419860"></p>
<p>我们是new了一个<code>ActionListener()</code>。当然这样子肯定是不行的，因为<code>ActionListener()</code>本身是一个interface（接口），它是不可以做这个事情的。</p>
<p>那么在这里本来就已经结束了的构造函数的名字的后面：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215145610396.png" alt="image-20250215145610396"></p>
<p>我们又出现了一对大括号，而且呢，这对大括号后面还有一个圆括号（这个圆括号（63行）是和new前面的圆括号对应的（56行）），是<code>addActionListener()</code>函数调用的圆括号。在这里面，我们本来是要去构造一个<code>ActionListener()</code>的东西的，我们在后面给它来了一对大括号。</p>
<p>所以这一对大括号做的事情是说：我们在这个地方定义了一个新的类，这个类实现了<code>ActionListener</code>的接口。</p>
<p>既然这是在定义类，在这个大括号里面我们就要去Override（覆盖那个<code>ActionPerformed</code>函数），然后在这个<code>ActionPerformed</code>函数里去做些事情。</p>
<p>这个在Java我们叫做<strong>匿名类</strong>。</p>
<p>所以我们有内部类，内部类还可以去做匿名类。因为这是一个没有名字的类（这个类就没有名字了）。</p>
<p>所以我们刚才实际上看到的是什么？就是你在new一个对象的时候，如果给出一个新的类的定义，那么这个新的类的定义就成为一个<strong>匿名类</strong>。</p>
<p>这个匿名类它<strong>一定</strong>是一个内部类。</p>
<p>🍎内部类访问外部类成员</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215150256286.png" alt="image-20250215150256286"></p>
<p>而对于内部类，我们知道内部类就是定义在别的类的内部的类。</p>
<p>🍎注入控制与注入反转</p>
<p>但实际上呢，它可以出现的地方，我们刚才给大家看到的就已经是两个地方：</p>
<p>内部类是有两种：（当然它们都叫做内部类）</p>
<p>1）定义在类的内部的类</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215150406066.png" alt="image-20250215150406066"></p>
<p>2）函数内部的类</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215150431659.png" alt="image-20250215150431659"></p>
<p>那么作为内部类来说，最核心的一点就是内部类可以自由的访问外部类的任何成员，哪怕是私有的。（因为内部类也是成员）</p>
<p>但是如果作为函数的内部的类（2），有一个<strong>小细节</strong>就是它能够访问那个函数里面所有的本地变量，也能够访问那个函数所在的类的所有的成员变量和成员函数。但当它访问它所在函数的本地变量的时候，那些本地变量必须是final的。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215150150406.png" alt="image-20250215150150406"></p>
<p>当我们在new它的时候，给出的类的定义就形成了一个匿名的类。为什么会有匿名的类呢？</p>
<p>这正是由swing的这种消息机制所引起的。在swing的这种消息机制里面，每一个部件会发出的消息就需要有一个新的类去实现一个新的方法，然后去接收那个消息。</p>
<p>那么当你的程序里面有很多按钮、有很多这样的控件、甚至每一个菜单项它都是像按钮一样会发出一个<code>ActionPerformed</code>的消息，那每一个菜单项我们都要去为它设计一个类、然后去为它那么写一个函数。如果我们没有匿名类这个机制的话，那就意味着在这个事情当中，我们要做一个非常费脑筋的事情，就是<strong>起名字</strong>。</p>
<p>起名字很麻烦。</p>
<p>那匿名类的好处就是：我不要起名字了，我就告诉你说，我现在给你一个类，现在这个类就是起到<code>ActionListener</code>的作用，至于它叫什么名字，我不关系、你也不用关心。反正我给你的就是，我现在设计的实现了<code>ActionListener</code>接口的类，这个类里面有那个<code>ActionPerformed</code>函数，它就可以注入到你那个里面去来形成注入控制，这也就是我们前面在说的<strong>注入反转</strong>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215151619993.png" alt="image-20250215151619993"></p>
<p>我们的按钮公布一对函数：<code>addActionListener</code>和<code>removeActionListener</code>。</p>
<p>remove（<code>removeActionListener</code>）是什么意思：remove就意味着：你可以在程序运行的过程当中加上一个Listener，也可以随时撤走以Listener。（比如说我现在对你的这个按钮突然不感兴趣了，这些事情都是可以动态调整的。）</p>
<p>——按钮和你的代码之间的关系是由你的程序来维护的，因此它是动态的。</p>
<p>按钮公布了一对函数和一个接口，我们就用这个接口来实现了自己的一个类，由这个类去访问我们这个类内部的一些东西来完成你的消息（最后的那一步工作，即消息发生以后我们这边做什么）。</p>
<p>通过内部类和匿名类的机制来得以实现。</p>
<blockquote>
<p><strong>城堡的Handler类</strong><br>Q：在第5周的城堡程序那里，我们做的Handler是需要在构造的时候注入Game的。那么，在学习了内部类之后，能否用Game的内部类来实现这些Handler呢？应该怎么做？</p>
<p>A：直接把<code>handlerBye</code>这个类挪到game类里面就可以正常用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HandlerBye</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HandlerBye</span><span class="params">(Game game)</span>&#123;</span><br><span class="line">            <span class="built_in">super</span>(game);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBye</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cmdExp</span><span class="params">(String roomDes)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;如：\tbye&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>
<h3 id="7-2-MVC模式"><a href="#7-2-MVC模式" class="headerlink" title="7.2 MVC模式"></a>7.2 <code>MVC</code>模式</h3><h4 id="7-2-1-JTable"><a href="#7-2-1-JTable" class="headerlink" title="7.2.1 JTable"></a>7.2.1<code> JTable</code></h4><p>🍎课程表程序</p>
<p>我们做了这样一个课程表程序，我们来看看它跑起来是什么样子的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215152856126.png" alt="image-20250215152856126"></p>
<p>我们可以输入：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215152912291.png" alt="image-20250215152912291"></p>
<p>我们生成了一个表格、在这个程序里头有一张表格画出来，就像大家用到的Excel电子表格一样。这么做到这个效果的？我们一点点来做做看：</p>
<p>🍎<code> JFrame</code>和<code> JTable</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kechengbiao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kechengbiao</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(); <span class="comment">//我们想要出一个图形的东西需要有一个JFrame</span></span><br><span class="line">		frame.pack(); <span class="comment">//自己把自己的大小计算一下</span></span><br><span class="line">		frame.setVisible(<span class="literal">true</span>); <span class="comment">//让frame显示出来</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样以后就是一个空空的窗口，我们已经做过了。</p>
<p>接下来我们想要有一个表格，它有对应的类，叫做<code>JTable</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kechengbiao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kechengbiao</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//我们知道JFrame是一个容器，在这个容器中加点东西它就能怎么怎么样</span></span><br><span class="line">		<span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(); <span class="comment">//我们想要出一个图形的东西需要有一个JFrame</span></span><br><span class="line">		<span class="comment">//表格</span></span><br><span class="line">		<span class="type">JTable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTable</span>(); <span class="comment">//做一个table出来</span></span><br><span class="line">		frame.add(table); <span class="comment">//把这个table add到这个frame里面</span></span><br><span class="line">		frame.pack(); <span class="comment">//自己把自己的大小计算一下</span></span><br><span class="line">		frame.setVisible(<span class="literal">true</span>); <span class="comment">//让frame显示出来</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看到这样是不是能够我们显示出一个表格呢：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215153857520.png" alt="image-20250215153857520"></p>
<p>啥也没有，我们就得到了这么一个空的窗口，为什么？说明还有地方用错了。</p>
<p>我们的这个table，不是这么用的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215154029629.png" alt="image-20250215154029629"></p>
<p>看到Table这个类，我们很容易认为：Table表示一个表格。这句话呢，部分是正确的。</p>
<p><code>JTable</code>在swing中确实表达一个表格，在这个表格当中，我们可以有格子（格子叫做Cell）；我们可以有一行一行的行（row）；可以有一列一列的列（<code>column</code>）；我们还可以有表头——这些作为一个表格的基本元素都有。</p>
<p>但是，<code>JTable</code>这个类是表达你看见的那个东西，而不是表达整个表格，它不管数据（数据在别的地方）。</p>
<p>我们之前其实提到过这个事情：数据和表现应该要分离。<code>JTable</code>实现了这个原则，它的数据和它的表现是分开放在不同的地方的。</p>
<p>🍎<code> TableModel</code>接口</p>
<p>我们做了一个<code>JTable</code>出来，我们只是说我们有了一个这样的表现它的数据在哪呢？它的数据在其他的地方。</p>
<p>我们在构造这个<code>JTable</code>对象的时候，需要给它另外一个东西，就是这个表格它的数据到底在哪里，所以我们需要另外做一个类出来，它实现了一个新的接口叫做<code>TableModel</code>：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215155119972.png" alt="image-20250215155119972" style="zoom:50%;" />

<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215155149521.png" alt="image-20250215155149521" style="zoom:67%;" />

<p>我们让它给我们自动产生出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kechengbiao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.event.TableModelListener;</span><br><span class="line"><span class="keyword">import</span> javax.swing.table.TableModel;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JTable的数据部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kechengbiao</span> <span class="keyword">implements</span> <span class="title class_">TableModel</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRowCount</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getColumnCount</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getColumnName</span><span class="params">(<span class="type">int</span> columnIndex)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getColumnClass(<span class="type">int</span> columnIndex) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCellEditable</span><span class="params">(<span class="type">int</span> rowIndex, <span class="type">int</span> columnIndex)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getValueAt</span><span class="params">(<span class="type">int</span> rowIndex, <span class="type">int</span> columnIndex)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValueAt</span><span class="params">(Object aValue, <span class="type">int</span> rowIndex, <span class="type">int</span> columnIndex)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTableModelListener</span><span class="params">(TableModelListener l)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeTableModelListener</span><span class="params">(TableModelListener l)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后它就自动帮我们把所有<code>TableMode</code>应该覆盖的函数都列在这儿了。</p>
<p>我们只要把这些函数都按照我们的想法去做完了，我们就能够得到一张表格。</p>
<p>我们先来一点点看：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215160201500.png" alt="image-20250215160201500"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215160232936.png" alt="image-20250215160232936"></p>
<p>我们来看这样行不行：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215160250411.png" alt="image-20250215160250411"></p>
<p>🍎表格数据和表现分离</p>
<p>我们看起来呢，有了一个大一点的窗口，但是下面出现了很多的<code>NullPointException</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215160336816.png" alt="image-20250215160336816"></p>
<p>很正常，因为我们还没有把刚才的那个数据里的东西都实现全。至少我们看到这些东西都起作用了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215160759234.png" alt="image-20250215160759234"></p>
<p>现在已经有了一些像样子的东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215160828175.png" alt="image-20250215160828175"></p>
<p>可是为什么我们的表头没有被实现出来？每一个里头有没有什么数据也不知道。</p>
<p>🍎添加表格功能</p>
<p>所以接下来我们还要增加一些东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162023565.png" alt="image-20250215162023565"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162045415.png" alt="image-20250215162045415"></p>
<p>现在我们再来看一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162107173.png" alt="image-20250215162107173"></p>
<p>可是为什么我们还是没有表头呢？我们还是没有表头的原因在另一个地方：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162251435.png" alt="image-20250215162251435"></p>
<p>在Main中，我们的Table没有实现滚卷（roll）。没有实现滚卷它就不能够做：所有的内容的呈现，它只能呈现其中的一部分内容。</p>
<p>所以我们不能直接把这个table加到frame里面去，你得做另外一个东西叫做<code>JScrollPane</code>。做这个<code>JScrollPane</code>的时候把table放进去；然后add到frame里面去的是pane而不是table：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162508686.png" alt="image-20250215162508686"></p>
<p>当然我们作为整个frame来说其实我们还要做些东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162550322.png" alt="image-20250215162550322"></p>
<p>——要不然我们关不掉它</p>
<p>现在，我们看起来就跟刚才一样了：我们有表头、我们每个地方都能够修改&#x2F;加东西、最后我们也能把它关掉</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162608246.png" alt="image-20250215162608246"></p>
<h4 id="7-2-2-MVC设计模式"><a href="#7-2-2-MVC设计模式" class="headerlink" title="7.2.2 MVC设计模式"></a>7.2.2 <code>MVC</code>设计模式</h4><p>🍎<code>MVC</code>模式</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215162713024.png" alt="image-20250215162713024"></p>
<p>在swing的<code>JTable</code>的模型里面，我们看到它符合我们之前提到过的一个很重要的设计原则：<strong>数据和表现要分离</strong>。</p>
<p><code>JTable</code>这个类只是用来管&#x2F;表达视图的（你看见的那个东西）、只是表现。</p>
<p>而数据放在对于的<code>JTable Model</code>（实现了<code>TableModel</code>接口的一个类）里面。</p>
<p>事实上，它们的关系是这样子的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215163031001.png" alt="image-20250215163031001"></p>
<p>我们看见的东西是一个<code>JTable</code>的一个对象，这个<code>JTable</code>在构造的时候我们给了它一个<code>TableModel</code>的对象。<code>TableModel</code>是一个接口，这个接口是和<code>JTable</code>一起来的。因此<code>JTable</code>知道<code>TableModel</code>长什么样。</p>
<p>你自己做了一个实现了<code>TableModel</code>的对象给它（），在那个类里面，你必须去Override（覆盖）它所要求的那么多的函数。那些函数是在这个<code>JTable</code>被显示&#x2F;操作的过程当中，会逐一调用的。那么那些调用的过程就会回来调你的函数。</p>
<p><code>eg</code>：在你的<code>TableModel</code>里面（实现了<code>TableModel</code>接口的Kechengbiao类）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215163552193.png" alt="image-20250215163552193"></p>
<p>当它决定说我要显示多少列的时候，它会调你的<code>getColunmCount</code>……</p>
<p>——这些函数都是由那个<code>JTable</code>在运行的过程当中反过来调你的函数的。所以你的数据是由你自己写的那个<code>TableModel</code>（对应途中Table Data）来维护，而<code>JTable</code>只管表现。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215163820726.png" alt="image-20250215163820726"></p>
<p>🍎数据、表现和控制的关系</p>
<p>事实上这件事情我们还要往前推一步，因为和我们之前做细胞自动机不一样的地方是：现在我们在用户界面上面对这个Table本身是有控制的。</p>
<p>我们在讲到细胞自动机的时候我们说我们是把数据和表现做了分离，其实我们现在又增加了一个东西：我们不仅仅有数据和表现，我们还有控制——我们用鼠标用键盘在这个表格里面做的动作，这是控制。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215164027287.png" alt="image-20250215164027287"></p>
<p>🍎<code>MVC</code>三者关系</p>
<p>我们现在表现出来的是三样东西：数据、表现和控制。</p>
<p>这三样东西它们的关系是怎么样的呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215164306695.png" alt="image-20250215164306695"></p>
<p>我们有一个叫做View的东西，叫做表现。</p>
<p>我们有一个叫做Model的东西，叫做数据。</p>
<p>我们还有一个叫做Control的东西，这是接收用户输入的地方。</p>
<p>这三者之间的关系是怎么样的呢？或者是每一个他各自做什么事情呢？</p>
<p>View做的事情很单纯，它只做一件事情，就是当它被通知数据被修改了，那么它就从Model获得数据，然后把整个画面重新画一遍。</p>
<p>Model做的事情就是他可能由于各种外界的原因数据修改了，数据修改了以后他它会通知View：“我数据修改过了，你需要拿数据来更新”。</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215164851905.png" alt="image-20250215164851905" style="zoom:50%;" />

<p>所以这两者之间只是这样的关系。</p>
<p>🍎Control的作用</p>
<p>那么Control是什么呢？Control是说：用户在界面上做了什么动作：比如说在表格中做了修改——这个事情是由Control知道的，Control知道了之后它做的事情就调用这个接口：</p>
<p>因为Model提供了接口给外界说，你要修改我的数据你就通过这个接口来修改；Control说，（你用户做了什么什么修改，）比如说用户填了一个什么东西aa进去，那么他就会跟Model说在某一个二行一列的地方现在内容是aa了。而Model一旦知道这个数据修改过来，就跟View说：我数据修改过了，你把我的数据重新拿过去重新整个画出来。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215165746765.png" alt="image-20250215165746765"></p>
<p>——这就是<code>MVC</code>设计模式。</p>
<p>🍎<code>MVC</code>设计模式</p>
<p>在这三样东西的设计当中，很重要的一件事情就是Control和View是没关系的——它们中间没有任何联系、Control不直接和View打交道。</p>
<p>也就是说：用户在界面上做的任何操作，<strong>不直接</strong>去修改界面上的显示。而是用户的输入去用来调整内部的数据，内部的数据去触发说：你表现（View）把我所有的数据拿过去重新画一遍。</p>
<p>这样做的好处是什么？每一个部分都很单纯，尤其是View很单纯。View不用去想那么多事（怎么去画每一个细节东西，这它不管），就是把所有的数据拿过来统统重画一遍就OK了。你数据自己想办法去变。</p>
<p>——不要去考虑每一个细节的事情。这是<code>MVC</code>的<strong>核心</strong>所在。</p>
<p>在我们的<code>JTable</code>模型里面，很容易看出来什么是什么：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215170506072.png" alt="image-20250215170506072"></p>
<p>Model就是那个<code>TableModel</code>，View就是<code>JTable</code>，那Control呢？</p>
<p>Control和View在这个体系当中被合并成为<code>JTable</code>了。</p>
<p>——这是<code>MVC</code>的常见的一种做法。因为控制（得到用户的输入）本来就是在图形界面上实现的，所以在表达图形界面的类里头，它做了表现；同时也是由它得到了用户的输入，然后由它来控制我们的Model。</p>
<p>——这和<code>MVC</code>并不矛盾，只是在具体的实现当中，我们把View和Control合并起来了。</p>
<p>这就是我们的<code>MVC</code>设计模式。</p>
<h2 id="第8周异常处理与输入输出"><a href="#第8周异常处理与输入输出" class="headerlink" title="第8周	异常处理与输入输出"></a>第8周	异常处理与输入输出</h2><h3 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h3><h4 id="8-1-1-捕捉异常"><a href="#8-1-1-捕捉异常" class="headerlink" title="8.1.1 捕捉异常"></a>8.1.1 捕捉异常</h4><p>🍎数组下标越界异常</p>
<p>在讲到数组的时候，我们曾经提到过这么一个细节：</p>
<p>假如说我们有这样的一个数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];	<span class="comment">//一个0~9的数组</span></span><br><span class="line">		<span class="comment">//因为数组的下标是从0开始排的，所以我们能用到的最大的下标其实是a[9]不是a[10]</span></span><br><span class="line">		a[<span class="number">10</span>] = <span class="number">10</span>; <span class="comment">//越界</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们当时就知道说：编译器不会给我们发现任何错误，然后如果我们试图去运行它，我们就会得到：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215193148330.png" alt="image-20250215193148330"></p>
<p>Exception，这个单词的意思叫做<strong>异常</strong>。</p>
<p>它说：在这个main里面有异常，在我们的<code>ArrayIndex</code>（类的名字）源代码的第8行（<code>ArrayIndex.java:8</code>）。</p>
<p>在这个地方出了一个事：<code>ArrayIndexOutOfBounds</code>（数组的下标越界），越界的下标是10（<code>...: Index 10 out...</code>）</p>
<p>——这就是异常。</p>
<p>所以其实我们很早就见过异常，但是呢，我们当时不知道如果你的程序里面有异常，我们该这么处理它。</p>
<p>所以我们今天就来看，面对异常我们怎么对付&#x2F;处理它。（我们怎么知道这儿有异常了、我们怎么以恰当的方式来处理这样的异常）。</p>
<p>首先是：我们怎么知道这儿出异常了：</p>
<p>如果这个代码的执行是会出异常的，以上例为例：我们看到说第8行出异常了，那么第8行的代码是<strong>没有</strong>被执行的。——这是一个很重要的知识，我们后面还会仔细的来提到这件事情。</p>
<p>🍎异常处理基础</p>
<p>如果我们在第8行的这个操作是会出异常的，从Java的角度来说呢，我们就可以把相关的这些操作（比如说从第8行开始，到第9行这些操作）我们把它放在一个语句块里头，成为一个单独的语句块。那么这个单独的语句块呢，在前面我们放一个try：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215194112865.png" alt="image-20250215194112865"></p>
<p>——大家看到这个颜色会知道说：这是一个关键字。try的意思是尝试。</p>
<p>即：我们尝试来做一下这两件事情。因为我们知道说我们希望这两个事情是都要做的（我们希望给一个数组当中的单元赋值，我们也希望它能够输出hello），当然了我们现在有可能在这个过程当中抛出异常来。</p>
<p>然后呢，我们这么做了以后这里会有问题：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215194403369.png" alt="image-20250215194403369"></p>
<p>——说语法错误，这个地方需要一些别的东西来完成这个<code>TryStatement</code>。</p>
<p>这个try语句我们需要catch一些东西。我们要catch什么？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215194535645.png" alt="image-20250215194535645"></p>
<p>——异常中说，这个叫做<code>ArrayIndexOutOfBoundsException</code>。那么我们就要来catch这个<code>ArrayIndexOutOfBoundsException</code>。以这样的方式我们就可以去捕捉这个异常：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215194734687.png" alt="image-20250215194734687"></p>
<p>也就是说，在这个try里面如果出现了异常（当然我们现在这个代码其实写成好像一定会有异常的），就会运行catch后的语句块。</p>
<p>🍎try-catch语句</p>
<p>我们稍微再改一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215194926331.png" alt="image-20250215194926331"></p>
<p>这样就不一定会抛异常了，只有在用户输入的<code>idx</code>不合适的时候（因为我们在程序里面没有去检查这个<code>idx</code>），那么它会抛异常。</p>
<p>🍎捕捉异常</p>
<p>而抛异常之后呢，我们就会由后面的catch把它给捕捉到，所以我们可能在这里会做一点事情，比如说输出一些东西说捉到了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215195144656.png" alt="image-20250215195144656"></p>
<p>我们来跑一下这个程序：</p>
<p>1）如果我们输入一个有效的、合理的数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215195229944.png" alt="image-20250215195229944"></p>
<p>因为现在是没有抛异常的，然后这个hello就显示出来了。</p>
<p>2）如果我们输出一个错误的值：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215195312142.png" alt="image-20250215195312142"></p>
<p>——我们没有看到刚才我们出现过的那种红色的Exception的那些东西。但是我们看到它输出了Caught：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215195405860.png" alt="image-20250215195405860"></p>
<p>它输出了Caught就意味着它运行到了第17行，它运行到了第17行其实还意味着第15行是没有做的，它从第14行就直接跳到了第17行。</p>
<p>🍎Java异常处理机制</p>
<p>这是因为在第14行它抛出了一个异常，然后呢，这个异常因为在try的语句块里头，就被try后面的这个catch给捕捉到了，而这个catch捕捉的时候，它会说这个catch捕捉的是<code>ArrayIndexOutOfBoundsException</code>的，现在它抛出的也是那个Exception，现在我们就捕捉到了那个异常，因此我们到了Caught。</p>
<p>到了Caught这里之后，我们还看到一件事情：它并没有再回去（我们把第14行的异常捕捉到了以后，它并没有回到第15行去，而是继续往下走了）。</p>
<p>这就是Java的异常处理机制，我们把可能出现异常的东西放在try里头，然后在try后面对于的catch里面去处理所以可能的异常。</p>
<p>处理完了以后，我们会继续往下走，而不会去重复在try的语句块里面被落掉的&#x2F;没有来得及做的那些事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		a[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];	<span class="comment">//一个0~9的数组</span></span><br><span class="line">		<span class="comment">//因为数组的下标是从0开始排的，所以我们能用到的最大的下标其实是a[9]不是a[10]</span></span><br><span class="line">		<span class="type">int</span> idx;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//一个输入</span></span><br><span class="line">		idx = in.nextInt();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			a[idx] = <span class="number">10</span>; <span class="comment">//可能越界</span></span><br><span class="line">			System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Caught&quot;</span>); <span class="comment">//说捉到了</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-2-异常捕捉机制"><a href="#8-1-2-异常捕捉机制" class="headerlink" title="8.1.2 异常捕捉机制"></a>8.1.2 异常捕捉机制</h4><p>🍎异常捕捉机制</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215200141990.png" alt="image-20250215200141990"></p>
<p>所以我们的try-catch是这么用的：我们会在try后面有一堆大括号，在这里面会放可能会出问题的语句。然后在这个try后面就会有一系列的catch，虽然8.1.1的例子中只有一个catch，但实际上可以有很多不同的catch。因为有可能在这个try里头会有很多不同的异常发生，面对这些不同的异常我们需要有不同的catch来处理每一种不同的异常。</p>
<p>在我们刚才的例子中，事情的发生就在try里头，很多时候不是这么简单直接的，比如说有可能：我们是另外有一个函数f：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215201618605.png" alt="image-20250215201618605"></p>
<p>这种情况下如果去调用f函数，在f函数就会抛异常，在这种情况下我们这么知道&#x2F;捕捉到这个异常？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215201904511.png" alt="image-20250215201904511"></p>
<p>如果在第9行出现了异常，那么我们的程序是不是立刻就结束了呢？还是会回到调用f的地方（main这里）？</p>
<p>也就是说，如果第9行出现了异常，我们知道第10行的代码是不会被执行的，那么第15行的代码还有没有可能执行呢？</p>
<p>然后，如果说我把这个f的调用放在一个try的语句块里会发生什么呢？我能不能以这种方式捕捉到在f函数调用过程当中产生的这种异常？我们能不能在第17行说一下捕捉到了呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215202120213.png" alt="image-20250215202120213"></p>
<p>我们先跑一下看：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215202210830.png" alt="image-20250215202210830"></p>
<p>我们现在发现说：我们在main里面去调了f，在f里面呢，我们已经知道第9行是会抛出异常的，所以我们看到第10行的的hello是没有显示的（没有被执行）。但是明显它会回到第15行来，然后被catch给捕捉到，所以我们会显示这个caught。处理完了之后，我们会显示出这个main来。</p>
<p>——换句话说，异常一旦发生，并不意味着程序一定要终止，而是说当我在第9行发生了这个异常的时候，我们需要有一种机制来找到一个合适的地方来处理这个异常。</p>
<p>🍎异常处理流程</p>
<p>当然，第9行出现异常之后，对于第9行所在的大括号（语句块）来说，第9行之后的所有的句子都不会被执行了。</p>
<p>然后呢，我们就需要离开这个f函数，回到调用它的地方，然后我们要来看看调用它的地方到底是不是一个try，然后再来看在这个过程中我们是不是有相应的catch来捕捉这个异常。</p>
<p>我们总结了这样一张图，当有异常抛出来的时候我们可以根据这张图来判断 我们到底应该在什么地方捕捉这个异常：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215202647817.png" alt="image-20250215202647817"></p>
<p>我们可以构造一些程序来测试这件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215202834067.png" alt="image-20250215202834067"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215202942959.png" alt="image-20250215202942959"></p>
<p>——显然k函数catch的异常和我们在第9行会抛出的异常不是一个异常：</p>
<p>这个时候我们根据那个流程图来看：f函数的第9行抛出了一个异常，它所在的语句块不是try（是函数的），所以否 -&gt; 所处的确实是函数，是 -&gt; 于是我们做的事情是返回调用者g；返回调用者我们要沿着虚线回到判断【所处的是不是try】，否 -&gt;  所处的还是函数 -&gt; 返回调用者h函数 -&gt; 不是try -&gt; 不是函数 -&gt; 退出的外层（退出所在的大括号，到外面的那层大括号去）-&gt; 不是try -&gt; 是函数 -&gt; 返回h函数调用者k函数 -&gt; 是try -&gt; 没有catch匹配 -&gt; 退出到外层 -&gt; 不是try -&gt; 是函数 -&gt; 返回k函数的调用者main -&gt; 是try -&gt;  有catch匹配 -&gt; 继续下面的语句，也就是输出caught</p>
<p>——这就是我们刚才这一系列的try-catch这一系列函数调用。它走的是这样复杂的路径，最后到了<strong>能够捕捉</strong>我们跑出来的这个异常<strong>并且进行处理</strong>的那个地方。</p>
<h4 id="8-1-3-捕捉到的异常"><a href="#8-1-3-捕捉到的异常" class="headerlink" title="8.1.3 捕捉到的异常"></a>8.1.3 捕捉到的异常</h4><p>🍎异常处理的输出结果</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215203924388.png" alt="image-20250215203924388"></p>
<p>那么我们捉到了这个异常以后能够做什么呢？</p>
<p>当拿到这个异常对象之后那个catch其实它长得很像一个函数对不对：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215204023006.png" alt="image-20250215204023006"></p>
<p>——这里有一个类型还有一个变量。</p>
<p>当我们拿到了这个e以后其实我们可以做一些事情：比如说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215204251866.png" alt="image-20250215204251866"></p>
<p>要求e去<code>getMessage</code>一下；我们知道任何的Java对象都可以去试一下直接拿来做输出（相当于做了一个<code>toString</code>）；其实我们还可以做一件事情是，e自己可以有一个叫做<code>printStackTrace</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215204409717.png" alt="image-20250215204409717"></p>
<p>——又看上去出现了红色的东西了，是不是感觉上很不安，但是我们可以看一下它实际上是怎么回事。</p>
<p>它显示了一个caught（catch语句块第一个语句）。</p>
<p>①<code>getMessage</code>是10，这是这个异常发生的时候放在这个异常对象里面的一个值，这个值是10。</p>
<p>🍎异常的调用堆栈</p>
<p>②<code>toString</code>的结果是：这个异常类的名字是叫做<code>java.lang.ArrayIndexOutOfBoundsException</code>，它的Message是10。</p>
<p>③然后我们看到了main（catch语句块下的第一行），而<code>printStackTrace</code>出于某种原因，它真正的输出被延后了。</p>
<p>④可以看到<code>printStackTrace</code>输出的是这样一系列东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215204941050.png" alt="image-20250215204941050"></p>
<p>这一系列东西这么解读呢：</p>
<p>1）第一行就是<code>toString</code>的那个结果，它告诉我们说：这是一个<code>java.lang.ArrayIndexOutOfBounds</code>的Exception发生了，那个实际出问题的那个值是10。</p>
<p>2）第二行：这个异常是在<code>ArrayIndex.java</code>源代码文件的第9行发生的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215205252765.png" alt="image-20250215205252765"></p>
<p>并且这个异常发生在<code>ArrayIndex</code>这个类的f函数里头。</p>
<p>3）第三行：它告诉你说然后f函数是被g函数所调用的，调用的地方是在第14行，也就是这：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215205358465.png" alt="image-20250215205358465"></p>
<p>4）第四行：而这个g函数是被h函数所调用的，调用的位置是在第20行：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215205503466.png" alt="image-20250215205503466"></p>
<p>5）第五行：这个h函数是被k函数所调用的，调用的位置是在第26行：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215205529121.png" alt="image-20250215205529121"></p>
<p>6）第六行：最后，这个k函数是被main函数所调用的，调用的位置是在第34行：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215205604561.png" alt="image-20250215205604561"></p>
<p>——这个就叫做<code>StackTrace</code>。就是我的函数调用过程当中，这么到了我的那个发生异常的那个地方的？在最外面从哪一个main开始，实际上我们倒过来看就是：main调了k，k调了h，h调了g，g调了f。——所以这就叫做<strong>调用堆栈</strong>。</p>
<p>🍎异常的处理和抛出</p>
<p>所以当我们捕捉到了一个异常以后，我们可以通过<code>printStackTrace</code>这样一个手段可以知道这个异常到底在哪发生的、中间调用的轨迹是怎么样子的？</p>
<p>这对我们设法来解决&#x2F;处理这里面的问题是很有效的一些手段。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215210001941.png" alt="image-20250215210001941"></p>
<p>当然，一旦抛出了异常之后我们有很多的机制来捕捉到它，但是你肯定是回不去了——你不能再回到异常发生的那个地方，哪怕你捕捉了、处理完了，你也回不去了。</p>
<p>但是具体要做什么，这是取决于你的业务逻辑的需要。</p>
<p>异常机制只是一种机制，具体这么去使用它、利用它，这个取决于你的业务逻辑的需要。</p>
<p>🍎异常的再次抛出</p>
<p>如果你捕捉到了一个异常，但是呢，你觉得你处理不了它、或者说：你捕捉了你处理了但是你觉得你并不能最后的把它全部的处理掉，那么你可以用这个手段再把它抛出来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215210200601.png" alt="image-20250215210200601"></p>
<p>你可以用一个动词叫做throw，你可以说我要把这个异常的对象再次跑出来。</p>
<p>我们可以试一下这件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215210422539.png" alt="image-20250215210422539"></p>
<p>我们会看到：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215210434981.png" alt="image-20250215210434981"></p>
<p>k有输出了——这说明在k函数里面捕捉到了这个异常，但是捕捉完了以后并不是处理完了，它又做了一次throw把它抛出了，所以在main里面我们还是捕捉到了异常。</p>
<p>🍎异常的捕捉和处理</p>
<p>我们可以比较一下如果我没有29行这一句：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215210605368.png" alt="image-20250215210605368"></p>
<p>我们再来执行的时候：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215210617658.png" alt="image-20250215210617658"></p>
<p>就只有k和main。</p>
<p>因为在k里面它已经把这个异常处理掉了——它捕捉到了，对这件事情来说到这就结束了。然后到了main里面，在main里面对k的调用来说，事实上它就认为k没有抛出异常，因为在k里面已经被处理掉了。</p>
<p>所以你加上<code>throw e;</code>就能够让这个异常再一次的抛出了，那么我们就需要再有一个异常的处理机制去try-catch来捕捉这个异常了。</p>
<h3 id="8-2-异常机制"><a href="#8-2-异常机制" class="headerlink" title="8.2 异常机制"></a>8.2 异常机制</h3><h4 id="8-2-1-异常"><a href="#8-2-1-异常" class="headerlink" title="8.2.1 异常"></a>8.2.1 异常</h4><p>🍎文件操作流程</p>
<p>我们现在想要做这样一个程序：打开一个文件，然后把里面的内容读出来（读到程序里头、或者说读到内存里头），一般来说我们要做这么5件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215210930137.png" alt="image-20250215210930137"></p>
<p>但是你得要知道一件事情就是，我们如果写程序的只是这么直白的把这五句话给写出来了，这个程序能工作，但是它很容易遇到一些什么样的情况就不能正常工作了。</p>
<p>（比如说给的文件名根本不存在）</p>
<p>（比如说很有可能这个文件并不真的是一个磁盘上的文件，当我们在做比如说socket通信的时候，我们的客户端和服务端通信的时候，我们也是以文件的方式去访问它的。这个时候，如果另外一端还在不断的写数据，那么我们就没有办法知道这个文件到底什么时候结束了）</p>
<p>（就算前面两部都OK了，分配足够的内存空间这件事也可能会失败。比如说我们一个高清电影4个G，能不能拿到那么大的一个内存空间呢？很可能是有问题的）</p>
<p>（就算这些都没有问题，那么在读文件的过程当中会不会有问题呢？比如说我这个文件是能找到的，但是很不幸我硬盘上有坏块，读了一半就读不出东西来了。或者我这是个网络流，读一半网络断了，或者服务器坏了等等）</p>
<p>——有很多情况可能会发生。</p>
<p>在很多语言里头（包括Java）做这么五件事情都很简单，每件事情都是调了一个函数就把这件事情给做了，那么面对这样的五件事情，如果我们只是直白的把五个步骤给做&#x2F;写下来，那么将来这个程序运行的时候，很难说什么时候就遇到问题了。</p>
<p>🍎异常处理的重要性</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215212417174.png" alt="image-20250215212417174"></p>
<p>而且我们发现这里头这五件事情是有时间上的前后依赖的。比如说第二件事情是依赖于第一件事情的，如果文件没打开那么判断文件大小是不可能的……</p>
<p>每一件事情都是依赖于前面所有的事情能够成功完成然后它才能做下面的事情。</p>
<p>所以这样的一个代码如果希望它在运行的时候，不管遇到什么样的情况都能够安全的正常的运行的话（当然我们说安全的正常的运行并不意味着都把事情给完成，比如说用户要求你打开<code>a.txt</code>，但实际上那个<code>a.txt</code>是不存在的，那么当然你这个程序是不可能完成这个既定的任务的）——但是你的程序总不能崩溃吧。（你的程序能不能好好的跟用户说你的<code>a.txt</code>是打不开的）</p>
<p>我们面对着这样的一些事情， 我们其实希望我们的程序能够对运行过程当中可能出现的各种情况能够有所提前的<strong>防范</strong>。（文件打开是一种情况，文件打不开呢？你该怎么办呢？）</p>
<p>早期（40年前），所有的这种操作&#x2F;函数（和外界打交道的操作）都会有一些特定的返回值，或者说有一些办法让程序知道不行这事它没成功。没成功怎么办呢？于是我们就可以根据打开文件的操作所得到的一些返回值或者得到的一些状态来决定该这么办或者该那么办。</p>
<p>如果是这样子，我们可以把我们的程序写成这样：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215213201777.png" alt="image-20250215213201777"></p>
<p><code>if (thrFilesOpen) &#123;</code>：如果文件打开了，那么我们去判断大小。</p>
<p>else：如果没打开，那么让<code>errorCode = -5；</code>，然后在最后返回<code>errorCode</code>。</p>
<p>所有如果这五件事情都做完了，那<code>errorCode</code>一定是0。</p>
<p>——这么一大段代码（30多行）。这个代码好不好？这个代码很好是吧？它会去判断各种可能的的情况，根据运行时各种可能的状况，分别的去做不同的处理，保证你的程序不会崩溃。</p>
<p>🍎异常处理代码的问题</p>
<p>所以这是一个好代码，但是这个代码有亮很严重的问题：</p>
<p>1）你能够一下子从在30几行里面看明白它到底要干嘛吗？如果刚才我没有给你看那5行，我一下子给你看这35行，你能不能看明白它是要去打开文件读进内存这件事情呢？——可读性很差。一下子看不明白。</p>
<p>2）在这样子的一段代码里头，如果我们要做一点点修改，非常的费劲。比如说我们希望你打开文件以后，跳过前面的1w个字节，从第10001个字节来给我读。这就意味着要在读之前插入一个新的动作：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215213912002.png" alt="image-20250215213912002"></p>
<p>比如说skip——但这个动作也可能会失败，围绕着这个动作我们有一堆的if怎么样怎么样，然后有一堆的else怎么样怎么样，你能保证你的else插对地方了吗？——很容易犯错误。</p>
<p>所以这段代码是好的，但它还不够好。</p>
<p>怎么样的代码是好的呢？这样的是好的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215214102117.png" alt="image-20250215214102117"></p>
<p>try后的语句块中就是我们做的五件事情——我们把这个叫做business logic（业务逻辑，BL）。我们把这个业务逻辑放在一起连贯的写下来、连贯的表达把它放在try的语句块里头。</p>
<p>🍎异常机制的好处</p>
<p>然后下面有五个catch，如果这个try里头出了问题，然后我们就用后面的catch来解决问题。</p>
<p>比如说文件没打开，我们通常能做什么：比如说弹一个对话框告诉用户打不开，然后根据用户的选择来决定。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215214757214.png" alt="image-20250215214757214"></p>
<p>这就是我们的异常机制。</p>
<p>异常的意思就是有不寻常的事情发生了，当这个事情发生的时候，原本打算要接着做的事情不能再继续了，必须得要停下来，然后让其他地方的某一段代码来处理这个问题。</p>
<p>这个异常机制最大的好处就是清晰的分开了正常的业务逻辑代码和遇到情况时的处理代码。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215214911126.png" alt="image-20250215214911126"></p>
<p>每一部分都清清爽爽，这就是我们异常机制的好处。</p>
<h4 id="8-2-2-抛出异常"><a href="#8-2-2-抛出异常" class="headerlink" title="8.2.2 抛出异常"></a>8.2.2 抛出异常</h4><p>🍎异常抛出机制</p>
<p>如果我们希望在打开文件不成功的时候返回-1（我们这都是仿真的代码）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215221058867.png" alt="image-20250215221058867"></p>
<p>如果我们 在<code>readFile</code>的时候发现了它返回-1，我们这么能够让别人知道说这个事情是一个异常发生了呢？</p>
<p>我们前面已经知道说：如果有异常发生，那么我们可以try-catch。那么如果这儿已经有这么一个情况了，我怎么能够告诉别人这儿发生异常了呢？我们要用到一个东子叫做<strong>throw</strong>，当然这个动词是个关键字。这个动词说：我现在在这要抛一个异常，抛什么呢？什么东西是可以直接跑出去的呢？</p>
<p>如果我抛一个1或者-1，会报错：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215221415037.png" alt="image-20250215221415037"></p>
<p>说：int类型是不能被抛的。</p>
<p>它也说了，什么是能被抛的呢：必须是<code>Throwable</code>的子类。也就是说，如果我们想要在这抛一个什么东西，我们就得做一个自己的类（比如说叫做<code>OpenException</code>），它继承自<code>Throwable</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215221643041.png" alt="image-20250215221643041"></p>
<p>🍎自定义异常类</p>
<p><code>Throwable</code>这个父类就是可以任何可以抛的东西，然后就可以throw一个new <code>OpenException</code>出去： </p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215221725370.png" alt="image-20250215221725370"></p>
<p>这样做的时候，它说这个时候会有问题：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215221816616.png" alt="image-20250215221816616"></p>
<p>为什么这么做会有问题呢？它说：会有一个<code>Unhandleded exception type OpenException</code>（有一个<code>OpenException</code>是一个没有处理的exception）。为什么呢？</p>
<p>我们在这儿抛了一个异常，但是你看我前后的代码，我在这个代码里没有try它。我既然没有try它，按照我们之前学过的异常捕捉的逻辑的话，在这抛异常就会到这个<code>readFile</code>这个函数的调用被终止，然后回到被调用的函数——我们现在和没调用这个函数呢。</p>
<p>如果我们在main函数里调用这个函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215225052060.png" alt="image-20250215225052060"></p>
<p>但问题不在这，如果这个异常<code>readFile</code>要被终止，可是我没跟人家说啊？我们既没有在这个地方去处理这个抛出来的异常，我们也没有告诉别人说<code>readFile</code>是会抛出异常的函数：你看，我们在灯泡这点一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215225234273.png" alt="image-20250215225234273"></p>
<p>它会告诉你说我们有两条路可走：要不加上throws declaration；要不Surround with try&#x2F;catch。</p>
<p>如果Surround with try&#x2F;catch，那么它就会在这个throw的外面加上try，然后说catch那个<code>OpenException</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215225429768.png" alt="image-20250215225429768"></p>
<p>我们如果这么做了之后，大家都知道这个异常就不存在了。</p>
<p>🍎异常处理方式</p>
<p>如果不怎么做，它给的另一个选项是Add throws declaration。这事什么呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215225534009.png" alt="image-20250215225534009"></p>
<p>它在这个函数的后面加上了一句<code>throws OpenException</code>，这句话的意思是说这个<code>readFile</code>这个函数会抛出<code>OpenException</code>这个异常——注意：这个时候这个动词throws加了【s】，为什么？</p>
<p>这是陈述句，第三人称单数，动词加s：声明我的这个函数是会抛出异常；在你抛的时候，这是祈使句：请抛出一个<code>OpenException</code>的异常。</p>
<p>这么做完之后，<code>readFile</code>没有抱怨啦，main函数又抱怨了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215225938807.png" alt="image-20250215225938807"></p>
<p><code>Unhandled exception type OpenException</code>，为什么在这儿又有了呢？</p>
<p>因为我们在<code>readFile</code>函数那里声明了说这个函数是会抛出<code>OpenException</code>就意味着当我去调用这个<code>readFile</code>函数的时候，我是存在风险的、我是有可能这个函数的运行过程中抛出异常的，那么调用这个函数的代码就必须为此做好准备。</p>
<p>于是它给出的解决方案又是两条：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215230310068.png" alt="image-20250215230310068"></p>
<p>我们Surround with try&#x2F;catch——我得尝试着去做<code>readFile</code>这件事情。</p>
<p>不过在这有一个小问题，如果要抛异常的地方你就要声明这个东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215230431019.png" alt="image-20250215230431019"></p>
<p>那好像我们之前还试过一个代码说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215230516245.png" alt="image-20250215230516245"></p>
<p>我们知道这个过程中是有可能抛异常的，为什么这个没有throws呢？一会儿来解释，这和另外一个事儿有关。</p>
<p>我们先来说我们这个事儿：</p>
<p>如果我的函数（<code>readFile</code>）会抛出异常（<code>OpenException</code>）的，那么我就得在这个函数的前面去声明说我要抛这个异常（<code>public static void readFile() OpenException &#123;</code>，然后所有调用这个函数那个的地方就得为这个事情做好准备。</p>
<p>——你要么try-catch把它捕捉了，你要么就在调用那个函数的外头说我会抛<code>OpenException</code>的。</p>
<p>🍎异常声明与捕获</p>
<p>甚至你如果是这样都不行：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215231002903.png" alt="image-20250215231002903"></p>
<p>——虽然你有try，但是我们知道根据我们之前学过的规则，在这个时候如果这个异常发生，这个catch是捉不到它的。</p>
<p>不过这里我们有第三条路可走，可以Add catch——因为我们可以在这个catch后再加一个catch：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215231219256.png" alt="image-20250215231219256"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215231234083.png" alt="image-20250215231234083"></p>
<p>也就是说，如果你的函数可能抛出异常，你就必须在函数的头部加以声明。但是你可以声明并不会真的抛出的异常：比如说我们还有一个异常：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215231336355.png" alt="image-20250215231336355"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215231346783.png" alt="image-20250215231346783"></p>
<p>实际上根据我<code>readFile</code>现在的代码，它只可能抛出open不可能抛出close、它也不调用别的函数别的函数也不会抛出别的异常，但是这是可以的。</p>
<p>🍎继承自<code>Throwable</code>的异常类</p>
<p>然后调用<code>readFile</code>的时候它会说你只处理了open，没有close：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215231521892.png" alt="image-20250215231521892"></p>
<p>得加上close，这才满意：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215231601127.png" alt="image-20250215231601127"></p>
<p>我们经常会看到这样的代码写出来，为什么呢？很有一种可能是说：现在的这个<code>readFile</code>它只有可能抛出open，但是也许我将来可以会改版（修改这个函数、修改里面的代码），使得它不仅能够抛出open、还能抛出close。那么如果我在现在的这个版本上面就把open、close都提前写上了。</p>
<p>好处是什么呢？就是所有调用我<code>readFile</code>都会已经为open和close这两种异常做好准备了，那么将来我在这个<code>readFile</code>的新版本里面再增加新的异常的抛出就没有任何问题了，因为所有调用它的地方都已经做好准备了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215232017565.png" alt="image-20250215232017565"></p>
<p>那么我们刚才说你能够扔的东西是继承自<code>Throwable</code>的。而另外有一个类叫做Exception，它继承了<code>Throwable</code>，所以我们更常见的是Exception类、更常见的是我们的类要从Exception得到继承。</p>
<p>而这个Exception类有两个构造：一个构造是不带任何参数的，另一个是带一个String的。所以我们通常做自己的构造的时候<strong>也会</strong>给它做上这两个构造，然后我们就可以用字符串来表达一些东西。</p>
<h4 id="8-2-3-异常捕捉时的匹配"><a href="#8-2-3-异常捕捉时的匹配" class="headerlink" title="8.2.3 异常捕捉时的匹配"></a>8.2.3 异常捕捉时的匹配</h4><p>🍎异常匹配</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216130543033.png" alt="image-20250216130543033"></p>
<p>那么当我们自己做的这个Exception类比较复杂（关系比较复杂，有子类有父类）的时候，这个catch的匹配它不是一种绝对的匹配，也就是说它符合一种Is-A的关系：如果你抛的是一个子类的异常出来，而你捕捉的是一个父类的捕捉器（catch捕捉的是父类的类型），是会被它捕捉到的。我们来试一下这个事情：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123; <span class="comment">//让opex继承自Exception</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloseException</span> <span class="keyword">extends</span> <span class="title class_">OpenException</span> &#123; <span class="comment">//让close继承自open（虽然这可能不太合理。</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//		int[] a = new int[10];</span></span><br><span class="line"><span class="comment">//		a[10] = 10;</span></span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> OpenException, CloseException &#123;</span><br><span class="line">		<span class="keyword">if</span> ( open() == -<span class="number">1</span> ) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CloseException</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			readFile();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (OpenException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">             System.out.println(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line"><span class="comment">//		catch (CloseException e) &#123;</span></span><br><span class="line"><span class="comment">//			// TODO Auto-generated catch block</span></span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;		</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，我这个程序实际抛的是一个Close，那么捕捉器里头只有捕捉Open的、没有捕捉Close的。我们来看能不能把它给捕捉到（也就是第33能不能运行输出）：</p>
<p>🍎异常捕捉顺序</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216131657087.png" alt="image-20250216131657087"></p>
<p>我们出现了Open，说明这个异常确实被它父类的捕捉器给捕捉到了。</p>
<p>而再修改一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		readFile();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (CloseException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		System.out.println(<span class="string">&quot;Close&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (OpenException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		System.out.println(<span class="string">&quot;Open&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在Open捕捉器前面有一个Close，我们知道Close是Open的子类，那么是Close会捕捉到还是Open会捕捉到呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216131958714.png" alt="image-20250216131958714"></p>
<p>现在呢，只有Close捕捉到了。因为对于try-catch机制来说，在try语句块的后面你可以有很多的catch，但是它会按照书写的顺序从第一个catch开始一个一个的找，直到找到了为止——直到找到了就不会再去找第二个catch了。</p>
<p>所以我抛了一个Close的异常之后，被前面的Close的catch去捕捉到了，捕捉完了之后这是就了了，后面的其他东西就不会去检查了。</p>
<p>🍎catch异常类</p>
<p>那么如果我现在把代码写成这样：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216132303147.png" alt="image-20250216132303147"></p>
<p>——现有一个Open再有一个Close，这就不行了。它会说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216132338600.png" alt="image-20250216132338600"></p>
<p>这个catch block是Unreachable——这个地方是不可能来的。如果真的有一个Close Exception抛出来，那么它前面的这个Open Exception的catch就会捕捉到了，轮不到这个Close。所以这样写是不行的。</p>
<p>🍎捕捉所有异常</p>
<p>我们前面说在Java的系统类库当中，所有的异常其实都是继承自Exception的，而Exception再继承自<code>Throwable</code>，<code>Throwable</code>里面有一些公共的方法。</p>
<p>所以主要的异常类是继承自Exception，所以我如果想做一个catch，它能够捕捉到任何异常，那么我只要写这个catch是做Exception的就可以了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216132512370.png" alt="image-20250216132512370"></p>
<p>——在这种情况下任何异常都会被它捕捉到。</p>
<p>如果说：我们把最后的捕捉器改成Exception，捕捉到以后打印Anything</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216132804814.png" alt="image-20250216132804814"></p>
<p>我们可以试一下这件事情：在我们的程序调用过程中，在我们的open里面可能会产生一个<code>ArrayIndexOutOfBounds</code>也会有Close：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216132945865.png" alt="image-20250216132945865"></p>
<p>在这种情况下它会怎么样呢：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216133015613.png" alt="image-20250216133015613"></p>
<p>——main在调用<code>readFile</code>之后，在第18行<code>readFile</code>去调用了open，任何在第14行就抛出了一个异常，这个异常是<code>ArrayIndexOutOfBounds</code>。</p>
<p>这个异常的抛出使得第15行的<code>return = -1;</code>根本就没做。然后try的语句块中就抛出了一个<code>ArrayIndexOutOfBounds</code>。而下面的catch没有能直接匹配的，但是<code>ArrayIndexOutOfBounds</code>也是Exception的子类，于是就打印出了<code>Anything</code>。并且程序是正常结束的而不是因为异常结束的。</p>
<p>🍎系统运行时刻异常</p>
<p>所以做一个<code>&#125; catch (Exception e) &#123;</code>就可以捕捉到所有的异常，包括那些系统产生的异常：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216133538405.png" alt="image-20250216133538405"></p>
<p>所以这就是另一个故事 ，我们前面提到过说：像<code>ArrayIndexOutOfBounds</code>这种异常是不需要在函数的前面做声明的，这一类的异常叫做<strong>系统运行时刻异常</strong>。</p>
<p>这种运行时刻异常因为太容易在代码各处出现，所以这些异常不需要你去声明。（如果需要声明那完了，所有的Java函数都要带上一长串这样的东西，所以这些是不要 。）</p>
<p>但是如果在你的程序中没有恰当的机制去捕捉它的话，那么我们程序的运行就会导致程序被终止，但是程序终止的时候还是会输出相应的信息：是什么样的异常、在什么地方调用等等的信息，来供我们做debug。比如说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216133844722.png" alt="image-20250216133844722"></p>
<h4 id="8-2-4-异常遇到继承"><a href="#8-2-4-异常遇到继承" class="headerlink" title="8.2.4 异常遇到继承"></a>8.2.4 异常遇到继承</h4><p>🍎函数声明抛出异常</p>
<p>我们前面说到，如果你的函数可能抛出异常，那么必须在函数的头部加以声明：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216150102745.png" alt="image-20250216150102745"></p>
<p>那么如果你调用一个声明会抛出异常的函数，那么你必须把这个函数的调用放在try的语句块里面、并且设置catch；或者你还得去声明自己会抛出无法处理的异常：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216150141637.png" alt="image-20250216150141637"></p>
<p>而当你覆盖一个函数的时候，情况就更复杂了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216150311072.png" alt="image-20250216150311072"></p>
<p>在父类当中你的某个函数可能会声明抛出一些异常，而这种情况下呢，子类就不能声明抛出比父类版本更多的异常。这句话挺绕口的，什么意思呢 ，我们来看一下：</p>
<p>🍎子类覆盖函数异常限制</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216150722861.png" alt="image-20250216150722861"></p>
<p>现在当然没什么问题啦，但是如果这个new class有一个f函数，throws <code>NewException</code>，这就不行了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216150905101.png" alt="image-20250216150905101"></p>
<p>这是为什么呢？为什么这个f必须是Open或者Open的子类呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216151437971.png" alt="image-20250216151437971"></p>
<p>如果我们对这个p去做f的动作，这个时候当然会出问题，它会说有<code>Unhandled exception</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216151538119.png" alt="image-20250216151538119"></p>
<p>但类型是<code>OpenException</code>。也就是说，因为<code>ArrayIndex</code>的这个f已经声明了它会抛<code>OpenException</code>，所以所有调用<code>ArrayIndex</code>的f函数的地方（虽然这个p里面实际上放的是<code>NewClass</code>，但是从<strong>字面</strong>上面来看，我们是在调用<code>ArrayIndex</code>的f函数），编译器会替我们检查你也没有对<code>ArrayIndex</code>的f函数所可能抛出来的所有异常做处理。</p>
<p>🍎向上造型异常处理</p>
<p>然后我们选择去做处理（try-catch）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125; <span class="comment">//让opex继承自Exception</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloseException</span> <span class="keyword">extends</span> <span class="title class_">OpenException</span> &#123;&#125; <span class="comment">//让close继承自open（虽然这可能不太合理。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line">	<span class="comment">//它不用做事情，只是说明有这么一个函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> OpenException &#123;&#125; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewClass</span> <span class="keyword">extends</span> <span class="title class_">ArrayIndex</span> &#123;</span><br><span class="line"><span class="comment">//	public void f() &#123;&#125; //保证这个f函数不会抛出任何异常</span></span><br><span class="line"><span class="comment">//	public void f() throws CloseException&#123;&#125; //会抛出Close。这也是ok的，因为close是open的子类</span></span><br><span class="line"><span class="comment">//	public void f() throws NewException&#123;&#125; //这不行</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> OpenException&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//有一个父类的变量p = new一个子类的变量出来。这是可以的，这就是一种我们叫做up cast，</span></span><br><span class="line">		<span class="comment">//即：向上造型（Upcast）。</span></span><br><span class="line">		<span class="type">ArrayIndex</span> <span class="variable">p</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewClass</span>(); <span class="comment">//ArrayIndex的对象里所管理/指向的其实是它的子类的变量。</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			p.f();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (OpenException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就OK了，我们的try回去catch这个<code>OpenException</code>。可是这个时候问题来了：如果在这个时候你说你的<code>NewClass</code>不仅仅会抛Open，还会抛<code>NewException</code>。第20行没有叉叉：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216152041138.png" alt="image-20250216152041138"></p>
<p>——能让你过就意味着什么呢？就意味着当我在try这个<code>p.f();</code>的时候其实我是存在风险的（我只会知道怎么去对付这个Open，我并不知道怎么对付New）。</p>
<p>——我捕捉到你这个p这个时候所管理的那个<code>ArrayIndex</code>的某一个子类居然它的f还能抛出来一个<code>NewException</code>来。</p>
<p>🍎子类构造函数异常声明</p>
<p>所以因为这个目的，当你子类要去继承父类，要去Override（覆盖）父类的某个函数的时候，你不能抛出比它更多的异常。但你可以不抛出：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216152539121.png" alt="image-20250216152539121"></p>
<p>——虽然别人已经做好了准备，但你说我不发生异常，这不是挺好的事情？</p>
<p>这是第一件事情，就是如果你要去覆盖父类的一个版本，那么你不能声明更多的异常。</p>
<p>第二件事情：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216152842113.png" alt="image-20250216152842113"></p>
<p>虽然在构造了里抛异常这是一个不好的事情，但这是可以的。不过<code>NewClass</code>已经有错了：它说：默认构造器不能处理<code>exception type OpenException thrown by implicit super constructor</code>——在我们这里我们没有为<code>NewClass</code>做构造函数，那么它就会用系统的。系统的构造函数显然不会抛任何异常，可是这不行，因为它需要说：</p>
<p>我们可以试一下如果让这个<code>NewClass</code>有构造函数，可是它不抛任何异常（<code>public NewClass() &#123;&#125;</code>）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216153305450.png" alt="image-20250216153305450"></p>
<p>它说不行，为什么？想象一下，如果有一刻我们要去new一个<code>NewClass</code>了，在高亮位置的里头：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216153401874.png" alt="image-20250216153401874"></p>
<p>它会去做构造的这件事情。但是我们知道，因为这是一个子类，所以在做这个构造的过程当中，其实父类的构造函数是会被调用的，而父类的构造被调用的时候是也可能抛出<code>OpenException</code>的。现在在你的子类这里你没有声明，这是不对的。</p>
<p>🍎子类构造函数异常处理</p>
<p>为什么你必须声明？是因为当别人去制造你这个子类的对象的时候，它并没有能力去知道你的父类会怎么样。它去new这个<code>NewClass</code>的时候，它一切的信息来源就是你这个<code>NewClass</code>，它无从知道你的父类怎么样。</p>
<p>——所以你必须在构造函数这里声明上你的父类可能会抛的所有的异常：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216154022225.png" alt="image-20250216154022225"></p>
<p>——并且这个时候你完全可以在这之后加上你自己的新的异常（比如说<code>NewException</code>）。</p>
<p>为什么作为成员函数你不可以添加更多的异常，而构造函数可能呢？</p>
<p>因为作为构造函数来说，它的关系和成员函数是不一样的：成员函数不能增加更多的异常是因为，我们有可能拿着子类的对象当作父类对象来看待，在那个时候如果通过父类的变量去调用子类的函数的时候，我们得要处理好所有的异常；</p>
<p>但是在构造的时候是另外一个故事：构造的时候是构造的过程当作，它会自动调用父类的构造，所以父类的构造所会抛的所有的异常你都得声明了。完了以后你当然还可以加自己的。</p>
<p>所以这是两个完全不同的范畴上的事情。因此我们总结一下规律就是：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216154436075.png" alt="image-20250216154436075"></p>
<h3 id="8-3-流"><a href="#8-3-流" class="headerlink" title="8.3 流"></a>8.3 流</h3><h4 id="8-3-1-流"><a href="#8-3-1-流" class="headerlink" title="8.3.1 流"></a>8.3.1 流</h4><p>🍎输入输出流的概念</p>
<p>任何程序都是有输入输出的，你不能想象我写了一个软件，它既不从用户那里读点什么东西，也不往用户那输出点什么东西，那程序干嘛呢？哪怕是放在服务器后台运行的程序，它也要接受网络上客户端的连接、接收客户端发来的请求，然后做些计算、发送一些数据到客户端去。</p>
<p>每一个程序都有一定的方式去做输入和输出，所以任何一个编程语言都需要给这个语言的编程者去提供某一些输入输出的方式，通过这些输入输出的方式让这个程序可以和外界打交道。</p>
<p>那么对于Java语言（以及事实上是从Java开始之后所有的新语言都一样），处理输入输出的手段叫做<strong>流</strong>（Stream）。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216162733464.png" alt="image-20250216162733464"></p>
<p>流在英文当中的单词叫做Stream，这个词恰好也是小溪的意思。所以在某种程度上来说，在程序里面的这个流和溪流是有很多相似的地方。比如说：它们都是一维的、它们都是单方向的。</p>
<p>所谓一维是说：如果我有一条溪流，那么当我们要想在这个溪流上面某一个位置的时候：比如说上面有座桥，下游两公里的地方我在这个地方等你，这是我们<code>UML</code>人的画法对不对</p>
<p>🍎流的特点和用途</p>
<p>——我用一个数字两公里就足以表达这个河流上面的那个位置了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216163205317.png" alt="image-20250216163205317"></p>
<p>而如果不是一维的，比如说在西湖中间上面某个地方，你要如何告诉别人你在哪里呢？</p>
<p>你得有俩数字：比如说你可能会说，我在什么什么庙的东边三公里，什么什么庙的南边两公里，大概在那个地方。或者如果你懂经纬度你可以拿个GPS跟人家说东经多少多少度，北纬多少多少度，我在那个地方等你。</p>
<p>二维的东西你需要两个数字来表达它，而一维的东西呢，你用一个数字就可以表达它在哪里。</p>
<p>另外我们说流都是单方向的，所谓单方向是说它永远只是从一个方向向另外一个方向流。就像你家门前那条小河，你今天早上起来它是从左往右流的，你明天早上起来它还是从左往右流——永远是单方向的。</p>
<p>我们在程序当中的流也是这样子的：一维的就表明说我们在程序当中用一个数字可以表达我现在在这个流的什么地方；</p>
<p>单方向的就是说，我如果要从这个流里面读东西，那么我就是读东西；我如果要往这个流里面写东西，那么我就是写东西。</p>
<p>🍎Java中的输入输出流</p>
<p>这个流提供了一个非常简单的接口给程序、给程序员，让我们以一种非常简单的方式可以去和输入输出打交道。</p>
<p>实际上我们第一次讲的那个程序Hello World它就是一个使用了流的程序：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216164942462.png" alt="image-20250216164942462"></p>
<p>我们的Hello World要输出给用户看，那么当然这个输出的方式它也是流。</p>
<p>对于<code>System.out.println</code>这里头：System是一个类；out是System这个类里面的一个静态成员；<code>println</code>是out这个成员可以做的一件事情。</p>
<p>而out这个成员它就是某种用来做输出的流。我们之前知道说：在out上面我们可以做<code>println</code>和做print，它们之间有细微的差异（一个输出的时候会换行，一个不会）。除了这些还有没有其他的东西？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216165308203.png" alt="image-20250216165308203"></p>
<p>在Java的基本类库当中，所有的输出都是基于<code>OutputStream</code>这个类的，而所有的输入都是基于<code>InputStream</code>这个类的——这两个类构成了输入和输出的基础。</p>
<p>可是我们要从哪里去知道说，这两个类它们有一些什么样的子类？——显然具体的我们不是在用<code>InputStream</code>和<code>OutputStream</code>，这两个类都是抽象的，我们可能在用它某一个具体的子类。</p>
<p>那么我们要想知道它有些什么样的具体的子类、另外我们还想要知道对于那个<code>System.out</code>，我除了可以做print和<code>println</code>之外，还能够做什么样的事情？</p>
<p>当然之前我们也看到在eclipse里面我们能够看到这样的一些细节，比如说：当我在eclipse里输入<code>System.out</code>，它就会出现<code>System.out</code>能够做的各种动作：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216165715419.png" alt="image-20250216165715419"></p>
<p>print和<code>println</code>是我们认识的，flush我们不认识，然后右边这个黄色的区域它就会告诉你说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216165901317.png" alt="image-20250216165901317"></p>
<p>Flushes the stream。冲那个流，把这个实际写出去的东西写到实际的介质上面去。</p>
<p>我们还有close、还有append、还有equals、还有format、还有<code>printf</code>（如果你学过c语言你可能会觉得<code>printf</code>非常的亲切）、还有<code>toString</code>……</p>
<p>所以这里有很多我们见过或者我们没见过的东西，除了在eclipse【 . 】出来以外，还有没有地方可以看到这些信息呢？</p>
<p>当然有，不过所有的这些东西都是联线的（包括eclipse的这些东西其实它现在也都是连线的）如果你现在用的电脑当时正好是不联网的，那么这些信息是出不来的。因为现在一般大家都会觉得，你在用计算机，你就应该在网上。</p>
<p>我们在这给出了一个网址：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170415183.png" alt="image-20250216170415183"></p>
<p>这个是oracle官方网站上Java的文档，我们点一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170438438.png" alt="image-20250216170438438"></p>
<p>在这里我们看到的是Java系统类库当中的所有的包。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170503806.png" alt="image-20250216170503806"></p>
<p>我们的所有输入输出相关的东西都在<code>java.io</code>这个包。点进去就会看见我们的<code>InputStream</code>和<code>OutputStream</code>这两个类：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170618464.png" alt="image-20250216170618464"></p>
<p>我们点<code>OutputStream</code>就会看见这个类的一些基本的描述：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170652478.png" alt="image-20250216170652478"></p>
<p>然后关于它所有可用的函数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170725704.png" alt="image-20250216170725704"></p>
<p>我们可以看到，对这个output来说，它可以write、它可以close、它可以flush，但是就没有更多的东西了。</p>
<p>我们可以回头再去看那个input：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170833532.png" alt="image-20250216170833532"></p>
<p>在之前我们说，如果我们要去读什么东西的输入，我们会去构造一个scanner的对象，并且我们交给它的是<code>System.in</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216170914945.png" alt="image-20250216170914945"></p>
<p>——我们知道说System的in和out，应该是输入和输出的两个流。所以<code>System.in</code>大概是<code>InputStream</code>的。</p>
<p>我们之前做的事情都是说拿那个<code>System.in</code>去构造一个Scanner之后，我们可以在Scanner上面去读东西。那么<code>System.in</code>本身能不能去做些什么样的事情呢？</p>
<p>我们在上面看到说：作为一个<code>InputStream</code>它能够做的事情似乎也非常的有限：我们看到它有read函数（[下面的小字部分]read函数会读入下一个字节）、还有一个read一个字节数组……总的看起来很有限对不对？我们<code>InputStream</code>能够做的事情都列在这里了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216171417814.png" alt="image-20250216171417814"></p>
<p>read是用来从这个<code>InputStream</code>里面读字节的。</p>
<p><code>InputStream</code>本身只是把外面的输入当作<strong>字节</strong>的流来看待（<code>OutputStream</code>也是一样）。所以，当我们只有<code>InputStream</code>和<code>OutputStream</code>的时候，我们能够做的事情非常有限——我们只能做<strong>字节</strong>层面上面的读和写。</p>
<p>🍎处理输入输出流的异常</p>
<p>我们看到我们的函数（int read()）可以读一个字节，但是它返回的是一个int：这是因为我们需要用这个函数来表达 文件读到头了（读到文件结束的地方这个read函数返回一个-1）。——所以返回类型不能是char，否则返回的-1会被认为是一个有效的值。只有当返回类型是int的时候，返回一个-1才能够被正确的识别。</p>
<p>然后剩下所有能够读的方式都只有读字节。</p>
<p>另外呢还有一些有趣的比如说mark和reset这一对函数是这样子用的：我可以在流读到某个地方的时候去打一个标记（mark一下），然后再继续往前读，读到后面某个地方的时候我突然说reset，然后我就要回到之前做mark的那个地方。可是这样的mark只能打一次，如果我打两个mark，ok前面的那个mark就没用了。所以mark和reset大概能让你记住读过的某个地方，将来某个时候再回来，回到前面的地方再来重新读一下。</p>
<p>available是用来告诉你说，现在流里面还有多少字节可以读。</p>
<p>然后我们还有一个<code>markSupported</code>用来说明到底能不能做mark这样的事情。因为不是所有的流都能够做mark的，假如说你在处理键盘这种特殊的输入，那可能这样的输入就没办法做mark了。</p>
<p>所以我们先来看一下说，我们能怎么样来简单是使用<code>System.in</code>这么一个<code>InputStream</code>里面最基本的那种read函数：以读字节的方式把我们想要的用户的输入读进来：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216173037968.png" alt="image-20250216173037968"></p>
<p>这一次它就马上出问题了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216173110139.png" alt="image-20250216173110139"></p>
<p>它说：<code>Unhandled exception type</code>。因为所有的I&#x2F;O操作其实都存在风险。（比如说这个read万一读不到那么多东西怎么办呢？）</p>
<p>还有我们现在是<code>System.in</code>的read（从标准输入读东西），但是没有人告诉你说，这个read只能用在<code>System.in</code>上面。所以这样的read如果是用在别的地方的，这样的read有可能会失败。</p>
<p>所以所有的I&#x2F;O操作都是带着Exception的。对于Exception，解决的方案有两个，我们把它放在try-catch里面。</p>
<p>🍎字节流和字符流的区别</p>
<p>我们来看一下这个程序运行会是什么样的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//留着这个可以告诉我们这个程序跑起来了。因为有的时候都不知道是不是跑起来该输入东西了。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">		<span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">//一个字节的数组buffer，有1k字节那么大。</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//这一次到底要读多少东西。让System.in去做一个read，read到buffer里头去。</span></span><br><span class="line">			<span class="comment">//试着去读</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> System.in.read(buffer);</span><br><span class="line">			<span class="comment">//去读：我们用这个buffer里面的从0开始的len个字节来构造一个String。</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> ,len);</span><br><span class="line">			System.out.println(<span class="string">&quot;读到了&quot;</span>+len+<span class="string">&quot;字节&quot;</span>); <span class="comment">//输出读到了多少字节</span></span><br><span class="line">			System.out.println(s); <span class="comment">//输出读到的字符串</span></span><br><span class="line">			System.out.println(<span class="string">&quot;s的长度是：&quot;</span>+s.length()); <span class="comment">//输出s的长度</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入123abc：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216180306786.png" alt="image-20250216180306786"></p>
<p>它告诉我们说：</p>
<p>1）第一行输出：读到了7个字节（1 2 3 a b c，后面还有个回车。我现在在用mark，所以回车是一个字节的。）</p>
<p>2）第二行输出：s是<code>123abc</code>。<code>123abc</code>后面空了一行是什么呢？因为我们读进来的时候是以字节的方式读进来的，所以它会把那个回车也读进来（所以才会是7个字节）。然后这个回车是在s的内容里头，所以输出s的时候本身就会有一个回车，再加上我是用的<code>println</code>，<code>println</code>又会有个回车，所以会有两个回车。</p>
<p>3)第四行输出：s的长度是7。就是s这个字符串里头总共有七个字符，这也符合，因为我们有6个可见的和一个不可见的回车。</p>
<p>我们再来运行一遍：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216180707187.png" alt="image-20250216180707187"></p>
<p>现在它说读到了11个字节，因为一个汉字正好是两个字节（如果用的是国标码的话）。然后它也正确的把它转化成字符串输出了。</p>
<p>最后它说：s的长度是9。——为什么我读到了11个<strong>字节</strong>，生成了字符串以后，<strong>字符串</strong>的长度只有9个<strong>字符</strong>？因为每一个汉字在Unicode里头仍然是一个字符。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216181112398.png" alt="image-20250216181112398"></p>
<p>同样的，对于输出流来说，我们能够做的也只是字节。我们可以输出单个字节或者输出一个字节数组。</p>
<p>然后flush的作用就是保证从缓冲区里面写到这个物理介质上去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//留着这个可以告诉我们这个程序跑起来了。因为有的时候都不知道是不是跑起来该输入东西了。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">		<span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]; <span class="comment">//一个字节的数组buffer，有1k字节那么大。</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//这一次到底要读多少东西。让System.in去做一个read，read到buffer里头去。</span></span><br><span class="line">			<span class="comment">//试着去读</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> System.in.read(buffer);</span><br><span class="line">			<span class="comment">//去读：我们用这个buffer里面的从0开始的len个字节来构造一个String。</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span> ,len);</span><br><span class="line">			System.out.println(<span class="string">&quot;读到了&quot;</span>+len+<span class="string">&quot;字节&quot;</span>); <span class="comment">//输出读到了多少字节</span></span><br><span class="line">			System.out.println(s); <span class="comment">//输出读到的字符串</span></span><br><span class="line">			System.out.println(<span class="string">&quot;s的长度是：&quot;</span>+s.length()); <span class="comment">//输出s的长度</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-3-2-文件"><a href="#8-3-2-文件" class="headerlink" title="8.3.2 文件"></a>8.3.2 文件</h4><p>🍎文件流的概念和使用</p>
<p>那么那个 <code>System.in</code>、<code>System.out</code>是标准输入和标准输出的流。如果我们想要直接写文件、或者直接读文件，我们就要用到文件流：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216181313984.png" alt="image-20250216181313984"></p>
<p>文件流对应的类就是这两个：<code>FileInputStream</code>和<code>FileOutputStream</code>，我们来试一下这个<code>FileOutputStream</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216181735130.png" alt="image-20250216181735130"></p>
<p>当然这里它会说有问题，因为这里面会有Exception：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216181751246.png" alt="image-20250216181751246"></p>
<p>把它放到try-catch里头即可。</p>
<p>🍎文件的创建和写入</p>
<p>通过<code>FileOutputStream</code>试着建立这样一个<code>FileOutputStream</code>的对象。建立起来之后在文件系统当前目录底下，这个文件就被建立起来了：如果这个文件已经有，那么这个文件里的东西会被丢掉；如果这个文件没有，那么会新建一个文件。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216182336354.png" alt="image-20250216182336354"></p>
<p>这个程序运行之后，我们从终端上只能看见hello world被输出了，剩下的东西我们要去文件系统里面找。：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216182420896.png" alt="image-20250216182420896"></p>
<p>——没有出现任何问题并且程序已经结束了。</p>
<p>然后我们去找一下这个文件在哪：</p>
<p>在我们这个（课程中是hello，这次叫demo）工程的根下，原本它是有<code>src</code>是源代码，<code>bin</code>是编译好以后的<code>.class</code>文件那么现在就多了一个<code>.dat</code>文件：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216182855381.png" alt="image-20250216182855381"></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216182909170.png" alt="image-20250216182909170"></p>
<p>🍎文件的读取和查看</p>
<p>我们看到，文件的大小是10个字节：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216182743527.png" alt="image-20250216182743527"></p>
<p>我们要这么看到这个<code>a.dat</code>里面的内容呢？如果有图形化的工具，比如说像这个<code>0xED</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216183023284.png" alt="image-20250216183023284"></p>
<p>我们可以用它来打开我们的那个<code>a.dat</code>我们就可以看到全是二进制的数据:</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216183620168.png" alt="image-20250216183620168"></p>
<p>如果在命令行底下，我们也有一些工具，比如说<code>hexdump</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216183804054.png" alt="image-20250216183804054"></p>
<p>它给我们看到的也是从0开始的0123456789。</p>
<p>🍎文件的读写的应用场景</p>
<p>所以这就是文件的读和写的方式：<code>FileInputStream</code>和<code>FileOutputStream</code>，用来做文件的读和写。</p>
<p>当然现在在实际的产品当中，这样直接的读和写已经比较少用了，只有造轮子的人才会做这样的事情。因为他们要做出工具软件&#x2F;库l来给别人用。但是我们一般情况下不会再自己直接的去打开文件做操作。</p>
<p>如果你要做的是大量的数据的操作，那么通常我们会把这些数据放在数据库里面。</p>
<p>如果你要做的是配置文件，那么我们有专门用来读写配置文件的工具类。</p>
<p>如果你要做日志的输出，我们也有专门的做日志输出的工具类。</p>
<p>所以已经很少会有需求说，要在程序里面自己手工的、裸的去用这样的<code>FileInputStream</code>和<code>FileOutputStream</code>来做事情的机会了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//留着这个可以告诉我们这个程序跑起来了。因为有的时候都不知道是不是跑起来该输入东西了。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">		<span class="comment">// 构造一个字节数组</span></span><br><span class="line">		<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;buf.length; i++ ) &#123; <span class="comment">//遍历一下字节数组</span></span><br><span class="line">			buf[i] = (<span class="type">byte</span>)i; <span class="comment">//放i自己</span></span><br><span class="line">		&#125; <span class="comment">//这样做完之后数组里放的就是0~9这样的数据</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//试着建立这样一个FileOutputStream的对象。</span></span><br><span class="line">			<span class="comment">//建立起来之后在文件系统当前目录底下，这个文件就被建立起来了：</span></span><br><span class="line">			<span class="comment">//如果这个文件已经有，那么这个文件里的东西会被丢掉；</span></span><br><span class="line">			<span class="comment">//如果这个文件没有，那么会新建一个文件</span></span><br><span class="line">			<span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>);</span><br><span class="line">			out.write(buf); <span class="comment">//让out去write。把整个buffer数组都写出去。</span></span><br><span class="line">			out.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-3-3-流过滤器"><a href="#8-3-3-流过滤器" class="headerlink" title="8.3.3 流过滤器"></a>8.3.3 流过滤器</h4><p>🍎过滤器流的作用</p>
<p>那么我们前面看到的这些流，无论是System的in、out，还是<code>FileInputStream</code>和<code>FileOutputStream</code>，它们都只能够处理单个字节。读，单个字节的读；写，单个字节的写。</p>
<p>如果我有一些复杂的东西，不要说很复杂，比如说我有一个int（Java里面的整数）要写到那个文件里面去，我要怎么做？</p>
<p>我们知道，Java的一个int是4个字节，我如何能够把这4个字节写到那个文件里面去？似乎看起来是没有办法的。</p>
<p>所以呢，我们需要用另外一种东西：叫做<strong>过滤器流</strong>。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216190629950.png" alt="image-20250216190629950"></p>
<p>所谓过滤器流是说：我可以在我已经有的那个文件流的基础上，去增加一层层的过滤器，每一层的过滤器可以去做一些事情。其中有一些过滤器就可以帮我们来做那些基础数据基础类型（int、float、double）的读和写。</p>
<p>🍎使用过滤器流写基础数据类型到文件</p>
<p>就在8.3.2的基础上，我们可以来试一下：</p>
<p>我们光用这个<code>FileOutputStream</code>是只能写字节的，我们想要写更多的东西， 需要建立一个叫做<code>DataOutputStream</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216191258991.png" alt="image-20250216191258991"></p>
<p>可是这个<code>DataOutputStream</code>不能像<code>FileOutputStream</code>一样建立。事实上，一个<code>DataOutputStream</code>的对象，是要建立在一个别的流（比如说这个<code>FileOutputStream</code>）的基础上：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216191204647.png" alt="image-20250216191204647"></p>
<p>这样的做法，我们就是用一个<code>FileOutputStream</code>的对象 去构造了一个<code>DataOutputStream</code>。也就是说在<code>FileOutputStream</code>的后面去套了一节过滤器。</p>
<p>那顺便我们就可以加上一些别的过滤器，比如说有一个叫做<code>BufferedOutputStream</code>的过滤器，用于：在流的输出过程中加一个缓冲：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216191708264.png" alt="image-20250216191708264"></p>
<p>所以说现在的局面是我们有一个文件，打开了这个文件之后我们在上面去接了一个缓冲（<code>BufferedOutputStream</code>），缓冲的外面又去接了一个<code>DataOutputStream</code>。</p>
<p>最终我们得到的是一个<code>DataOutputStream</code>的对象out。在这个out上面我们可以去写基础数据，当它写到流里面去的过程当中，因为它前头还有个buffered，所以它会被缓冲。然后最后它要落到一个<code>FileOutputStream</code>的对象上面去，最后这个数据会写到文件里面去。</p>
<p>🍎使用过滤器流读取文件中的基础数据类型</p>
<p>那么一旦有了这样一个<code>DataOutputStream</code>，我们往里面写的东西就可以不仅仅是字节了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216192315933.png" alt="image-20250216192315933"></p>
<p>我们来运行一下然后来看看这个文件里有什么：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216192342389.png" alt="image-20250216192342389"></p>
<p>我们可以看到，在我们的文件里头写下去的就是<code>cafebaby</code>四个字节——以这样的方式，我们就可以以二进制的形式，把基本数据类型写到文件里面去。</p>
<p>所以这个时候我们写文件和我们之前用<code>println</code>去输出一个整数是完全不同的：<code>println</code>是把这个整数输出成人可以阅读的文本的形式；而这个<code>DataOutputStream</code>的写是以二进制的形式，把数据在内存当中的二进制原封不动的写到文件里头去。</p>
<p>所以在内存里面它是4个字节，在输出的二进制文件里头它也是4个字节。</p>
<p>🍎过滤器流的叠加作用</p>
<p>如果我们是要把这个<code>cafebaby</code>以人可以阅读的形式给人看，我们看到的是完全不同的场景。我们可以试一下反过来怎么读这个文件：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216192937221.png" alt="image-20250216192937221"></p>
<p>这个<code>cafebaby</code>十进制的值是一个很大的负的值：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216192948810.png" alt="image-20250216192948810"></p>
<p>如果我们试一下这样：如果我们写进去的不是一个<code>cafebaby</code>，而是一个十进制的123456：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216193106005.png" alt="image-20250216193106005"></p>
<p>运行它可以看到：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216193120330.png" alt="image-20250216193120330"></p>
<p>读回来显示出来的依然是十进制的123456。但是写在文件里面的那个二进制的东西是什么呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216193212459.png" alt="image-20250216193212459"></p>
<p>当然这是16进制的表达方式，如果把它转换成十进制的话，我们看到的应该是123456。我们可以试一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216193319120.png" alt="image-20250216193319120"></p>
<p>然后我们把它转化成十进制的看一下：这就是123456</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216193337228.png" alt="image-20250216193337228"></p>
<p>所以这就是流的过滤器的机制：我们在一个已经打开的文件（或者其他方式已经建立起来的那么一个介质的流）的基础上，我们可以一层层的叠加很多的过滤器，每个过滤器可以起到一定的作用（我们刚才的过滤器里头，buffer起到缓冲的作用，data起到了读写基本数据类型的作用）。</p>
<p>那么如果我们要做更复杂的文本的处理呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//留着这个可以告诉我们这个程序跑起来了。因为有的时候都不知道是不是跑起来该输入东西了。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">		<span class="comment">// 构造一个字节数组</span></span><br><span class="line">		<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;buf.length; i++ ) &#123; <span class="comment">//遍历一下字节数组</span></span><br><span class="line">			buf[i] = (<span class="type">byte</span>)i; <span class="comment">//放i自己</span></span><br><span class="line">		&#125; <span class="comment">//这样做完之后数组里放的就是0~9这样的数据</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//用一个FileOutputStream的对象 去构造了一`DataOutputStream。</span></span><br><span class="line">			<span class="comment">//也就是说在FileOutputStream的后面去套了一节过滤器。</span></span><br><span class="line">			<span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>( <span class="comment">//过滤器，在流的输出过程中加一个缓冲</span></span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.dat&quot;</span>)));</span><br><span class="line">			<span class="comment">//一个十六进制的数组，虽然看上去都是英文字母，但这都是16进制合法的英文字母。</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0xcafebabe</span>; </span><br><span class="line"><span class="comment">//			out.write(buf); //让out去write。把整个buffer数组都写出去。</span></span><br><span class="line">			out.writeInt(i); <span class="comment">//不再是简单的write了，是write一个int</span></span><br><span class="line">			out.close();</span><br><span class="line">			<span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">							<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.dat&quot;</span>)));</span><br><span class="line">			<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">			System.out.println(j); </span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-4-文本输入输出"><a href="#8-4-文本输入输出" class="headerlink" title="8.4 文本输入输出"></a>8.4 文本输入输出</h3><h4 id="8-4-1-文本流"><a href="#8-4-1-文本流" class="headerlink" title="8.4.1 文本流"></a>8.4.1 文本流</h4><p>🍎文本输入输出</p>
<p>那个<code>InputStream</code>和<code>OutputStream</code>只能处理字节，就算加上<code>DataInputStream</code>和<code>DataOutputStream</code>它也只能处理基本数据类型（二进制方式，它所写下来的文件是二进制文件、它能够读的文件也是二进制文件）。</p>
<p>那么我们之前的那个<code>System.out.println();</code>，那个能够输出文本的、人可以读的东西到底是什么呢？</p>
<p>当我们要处理文本的时候，我们要用到reader和writer。当然，在早期的版本里头，Stream也有用来做文本的输入和输出的。但后来出现了<code>reader/writer</code>之后，Stream里的文本输入和输出就被废弃了（过时了，不被提倡使用了）。</p>
<p>那么我们主要是要使用reader和writer这一套机制来做文本的输入和输出：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216194045111.png" alt="image-20250216194045111"></p>
<p>reader和writer是处理Unicode字符的，如果我们的文件本身是Unicode的文件，那么我们可以直接用reader和writer来打开做读和写。</p>
<p>但是呢，现在在一般情况下，我们的文件本身并不是Unicode的文件：文件可能是ASCII码、文件可能是国标码、甚至就算是有Unicode用的也是<code>UTF-8</code>这样的编码形式。</p>
<p>所以在这种情形下，当我们文件本身并不是Unicode的时候，我们就需要<strong>借助</strong>Stream：我们需要由Stream去打开那个文件，然后在Stream的基础上，以过滤流、过滤器的方式，去建立reader writer来做文本的输入和输出。</p>
<p>🍎使用reader和writer处理文本输入输出</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216194727634.png" alt="image-20250216194727634"></p>
<p>所以我们常见的做法是这样子的：（就在刚才的基础上做修改）因为要去写文本了，所以要有一个<code>a.txt</code></p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216195234090.png" alt="image-20250216195234090"></p>
<p>所以你看我们实际上是做了什么呢？我们做了一个<code>FileOutputStream</code>（这是一个Stream，它只能处理字节）；然后在外面我们做了一个这个<code>OutputStreamWriter</code>，这是一个bridge、这是一个桥梁，它构建起了Stream和writer之间的桥梁（它的输入是一个Stream、它的输出就是一个writer了）；然后在这个writer的基础上，我们用前面讲过的那个Stream的过滤器的思路一层层的叠起来我们可以得到一个<code>BufferedWrite</code>；最后我们得到一个<code>PrintWriter</code>。</p>
<p>我们有了<code>PrintWriter</code>之后，我们可以做的事情就是<code>println</code>（去输出那个i）：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216195815530.png" alt="image-20250216195815530"></p>
<p>🍎使用<code>printwriter</code>处理文本输出</p>
<p>我们先来看一下说，我们如果以这样的方式去输出了那个i（int整数：123456），我们会在文件里面读到什么样的东西：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216195931664.png" alt="image-20250216195931664"></p>
<p>我们就有了<code>a.txt</code>：就是7个字节，里面就是123456、还有第七个字节就是那个回车换行。这是一个文本文件，我们直接就可以看到它里面的内容。而<code>a.dat</code>，这是二进制的，人不能直接读，得用工具软件。但是对于<code>a.txt</code>，我们直接就能够打开这个<code>a.txt</code>看到这里面的123456：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216200119403.png" alt="image-20250216200119403"></p>
<p>🍎使用<code>BufferedReader</code>处理文本输入</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216200237705.png" alt="image-20250216200237705"></p>
<p>所以如果你想要让它能够产生相应的文本的内容，那么我们就去建立一个<code>PrintWriter</code>。这个<code>PrintWriter</code>建立在一个<code>OutputStreamWriter</code>的基础上，最终建立在一个<code>FileOutputStream</code>的基础上。这样写下来的文件是一个ASCII码或者国标码的文件（这取决于你当时用的是什么样的系统、你的本机的代码页是什么）。它会自动的去给你产生从Unicode去换算成相应的这些内容。</p>
<p>如果是要读东西呢？如果我要打开一个文本文件来读东西呢？这个时候呢，我们也一样可以去在<code>InputStream</code>的基础上去建立一个buffer的reader，然后由这个<code>BufferedReader</code>来读东西，我们来试一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216201703440.png" alt="image-20250216201703440"></p>
<p>🍎其他reader类和文件操作</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216201647232.png" alt="image-20250216201647232"></p>
<p>——它把这个源代码原封不动的输出了一遍，因为它从那里读到了这个源代码。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216201743287.png" alt="image-20250216201743287"></p>
<p>所以这是我们常用的去读文本文件的方式：我们用一个叫做buffer的reader的类，它可以用<code>readline</code>这样的函数去把文本里面的一整行都读进来。</p>
<p>除了有buffer的reader以外，我们还有的方式是用这个<code>LineNumberReader</code>。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216201914459.png" alt="image-20250216201914459"></p>
<p><code>LineNumberReader</code>可以做一个很神奇的事情，它可以在行号当中跳来跳去，你可以要求它跳到第几行。在一个文本文件当中，在行和行之间转来转去转。</p>
<p>除了这些以外，reader还有一个很神奇的东西是这个<code>FileReader</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216202113678.png" alt="image-20250216202113678"></p>
<p>我们前面提到过说：如果你有一个文件了，那是一个Stream，然后你要用<code>InputStreamReader</code>去把它转成一个reader。<code>FileReader</code>呢，就直接是<code>InputStreamReader</code>的子类，所以他自己就能够在一个二进制的（非Unicode的）文件上面去建立起一个流，然后最后形成一个reader。然后呢从当中就可以去做一些相应的事情。</p>
<p>所以如果你简单一定就是文件的话，那么<code>FileReader</code>会很方便。</p>
<p>但是<code>FileReader</code>其实我们会很少用，根前面提的原因一样，就是我们目前其实用Java写程序的时候，很少会要去裸的去操作文件。大多数情况下都是从其他的方式得到的，一个文件的表达&#x2F;描述方式，然后在它上面去做处理的。</p>
<p>另外<code>FileReader</code>不能做这个当中的文字的编码的处理，我们一会来看看这个编码处理是怎么回事：见8.4.2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//留着这个可以告诉我们这个程序跑起来了。因为有的时候都不知道是不是跑起来该输入东西了。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;hello world&quot;</span>); </span><br><span class="line">		<span class="comment">// 构造一个字节数组</span></span><br><span class="line">		<span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>; i&lt;buf.length; i++ ) &#123; <span class="comment">//遍历一下字节数组</span></span><br><span class="line">			buf[i] = (<span class="type">byte</span>)i; <span class="comment">//放i自己</span></span><br><span class="line">		&#125; <span class="comment">//这样做完之后数组里放的就是0~9这样的数据</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//			//用一个FileOutputStream的对象 去构造了一`DataOutputStream。</span></span><br><span class="line"><span class="comment">//			//也就是说在FileOutputStream的后面去套了一节过滤器。</span></span><br><span class="line"><span class="comment">//			DataOutputStream out = new DataOutputStream(</span></span><br><span class="line"><span class="comment">//					new BufferedOutputStream( //过滤器，在流的输出过程中加一个缓冲</span></span><br><span class="line">			<span class="comment">//我们最终所要的是一个PrintWriter，所以就不需要之前的那个DataOutput了</span></span><br><span class="line">			<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>( <span class="comment">//还是可以再加一个reader/writer机制的缓冲</span></span><br><span class="line">						<span class="comment">//因为PrintWriter是处理Unicode，我们不希望这样，所以中间要加一个过渡：</span></span><br><span class="line">							<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">							<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>)))); <span class="comment">//因为现在要写文本了</span></span><br><span class="line">			<span class="comment">//一个十六进制的数组，虽然看上去都是英文字母，但这都是16进制合法的英文字母。</span></span><br><span class="line"><span class="comment">//			int i = 0xcafebabe;</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line"><span class="comment">//			out.write(buf); //让out去write。把整个buffer数组都写出去。</span></span><br><span class="line"><span class="comment">//			out.writeInt(i); //不再是简单的write了，是write一个int</span></span><br><span class="line">			out.println(i);</span><br><span class="line">			out.close();</span><br><span class="line"><span class="comment">//			DataInputStream in = new DataInputStream(</span></span><br><span class="line"><span class="comment">//					new BufferedInputStream(</span></span><br><span class="line"><span class="comment">//							new FileInputStream(&quot;a.dat&quot;)));</span></span><br><span class="line"><span class="comment">//			int j = in.readInt();</span></span><br><span class="line"><span class="comment">//			System.out.println(j); </span></span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">					<span class="comment">//我们就不让它打开a.txt`，那太简单了。这其实就是我们现在的这个源代码文件</span></span><br><span class="line">							<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/demo/Main2.java&quot;</span>)));</span><br><span class="line">			<span class="comment">//readLine会返回一个String。也就是说它读了一行，然后把这一整行的内容，</span></span><br><span class="line">			<span class="comment">//变成一个String返回回来。而且呢，如果读到了流的末尾，会返回一个null</span></span><br><span class="line">			<span class="comment">//所以说常见的如果说想要把整个文件都读出来，我们经常会这么干：</span></span><br><span class="line">			String line;</span><br><span class="line">			<span class="comment">// 每次读一整行进来，如果没有遇到文件末尾：line管着的就是新的那一行</span></span><br><span class="line">			<span class="keyword">while</span> ( (line=in.readLine() )!= <span class="literal">null</span> ) &#123;</span><br><span class="line">				System.out.println(line);</span><br><span class="line">			&#125; <span class="comment">//如果是null那就说明读到了文件的末尾。</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-4-2-汉字编码"><a href="#8-4-2-汉字编码" class="headerlink" title="8.4.2 汉字编码"></a>8.4.2 汉字编码</h4><p>🍎文本编码问题</p>
<p>为什么说这个<code>FileReader</code>的指令编码是一个问题呢？我们来看一个情况是这个样子的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216202757792.png" alt="image-20250216202757792"></p>
<p>我们现在有一个文件，这个文件里面有几个汉字。这个文件的编码形式呢，是GB 18030（就是国标码）的形式：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216202843859.png" alt="image-20250216202843859"></p>
<p>然后呢文件名叫做<code>gb18030.txt</code>。我们如果让我们的Java程序来打开这个文件，我们看看能不能正确的把里面的汉字给读出来呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216202956513.png" alt="image-20250216202956513"></p>
<p>——我们就把8.4.2中的文件名改一下（我们也把这个txt文件放在这个工程下面），程序都一样。我们来看看它运行起来对不对：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216203119407.png" alt="image-20250216203119407"></p>
<p>我们看到它正确的输出了。</p>
<p>接着呢，我们来试另外一件事情，我们有另外一个文件，里面的内容相同：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216203209993.png" alt="image-20250216203209993"></p>
<p>但是这个文件是Unicode的，可是是UTF-8编码的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216203225991.png" alt="image-20250216203225991"></p>
<p>——UTF-8是一种变形的<code>UTF</code>。因为<code>UTF</code>的编码是两个字节表达一个字符。但是因为在英文的文档里头，大家都是ASCII字符——都是用一个字节可以表达的。</p>
<p>所以UTF-8就说：如果你是英文字符（<code>abcd1234</code>），那么我就用一个字节来表达你；如果你是对他们来说不常见的那些汉字的，我可能用三个字节来表达你一个汉字。所以这样的一种编码形式叫做UTF-8。</p>
<p>这其实在互联网上是非常常见的一种编码形式。它既采用了Unicode的编码（保证在所有平台上都通用），又能够保证英文的字母数字是采用比较短的编码形式的。</p>
<p>那么我们先来看如果我现在这个文件是UTF-8的，我们的Java程序能不能读出来呢：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216203742884.png" alt="image-20250216203742884"></p>
<p>我们看到没有正确的读出来，读出来了一堆乱码。因为我的eclipse里面的运行环境告诉它说，我的汉字的编码是<code>GBK</code> （国标）。</p>
<p>那么怎么能够让我的Java程序正确处理这个事情呢？</p>
<p>🍎解码方式选择</p>
<p>其实这个事情发生在什么地方呢？在我们的代码里面：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216203942223.png" alt="image-20250216203942223"></p>
<p>这个对象是二进制的，它是处理二进制字节的，它不管任何的编码的事情。</p>
<p>而：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216204018403.png" alt="image-20250216204018403"></p>
<p>这个对象就是用来处理文本的。</p>
<p>换句话说：当我们去建立一个<code>InputStreamReader</code>的过程当中，它认为它要以某种方式去把<code>FileInputStream</code>的这个Stream对象的二进制的数据转换成文本的数据。</p>
<p>采用什么方式转换：如果你不给出&#x2F;不去指定方式，那么它就要用系统默认的方式。而如果你给出的话：最简单的参数法就是加个字符串：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216204246523.png" alt="image-20250216204246523"></p>
<p>——但仔细看这是谁的括号？这是<code>InputStreamReader</code>的参数。</p>
<p>换句话说，我们构造这个<code>InputStreamReader</code>给它两个参数，第一个参数是这个文件的Stream；第二个参数是：如果有文件编码转换的问题，那么你要把这个Stream里面的东西当作UTF-8。</p>
<p>现在我们做了这个之后运行是不是对的呢？我们就得到了：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216204532801.png" alt="image-20250216204532801"></p>
<p>Java当然是有能力去处理好各种文字编码的问题，包括各种复杂的汉字编码的问题，但是关键是你要懂得你需要在什么时候采用什么样的方式<strong>告诉</strong>它你的这个数据到底是什么类型的。</p>
<p>我们有几种不同的手段，除了用那个字符串的手段之外，我们也可以用比较复杂的方式来告诉reader我到底怎么做编码、怎么做解码：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216204735191.png" alt="image-20250216204735191"></p>
<h4 id="8-4-3-格式化输入输出"><a href="#8-4-3-格式化输入输出" class="headerlink" title="8.4.3 格式化输入输出"></a>8.4.3 格式化输入输出</h4><p>🍎格式化输出</p>
<p>从一开始我们就知道说，我们用<code>System.out.println(); </code>可以输出各种类型。我们只要在那个圆括号里面放上各种类型的变量，它就有办法把它们输出了。</p>
<p>除了这种方式以外，在那个<code>System.out</code>上面，我们还可以用format、我们还可以用<code>printf</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216204951787.png" alt="image-20250216204951787"></p>
<p>（如果你学过C语言，那么这个<code>printf</code>和C语言的<code>printf</code>基本上是完全一样的。也就是说，首先要有一个字符串，在这个字符串里面我们要用%什么什么去给出它的格式，然后它会把后面的变量变成那种格式。具体的我们就不在这展开了，如果你学过C你直接可以套用C的那个方式，如果你没有学过C你又希望对你的输出做一些比较复杂的控制，那么你可以自己再去琢磨一些C的那个年代是怎么做这些事情的）</p>
<p>这是输出。</p>
<p>🍎文本输入</p>
<p>作为输入呢，我们从一开始就知道说可以用Scanner来做输入。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216205506759.png" alt="image-20250216205506759"></p>
<p>如果你有一个文件，你的文件里面是文本的，然后你需要从这个文本里面解析出一些数字来，我们知道可以用Scanner：我们可以在那个流上面去构造一个scanner，然后呢用这个Scanner去做next什么什么（比如说<code>nextInt</code>读一个整数进来、next读一个单词进来…）。</p>
<p>所以实际上我们在这个流里面是有很多复杂的东西的，我们是有很多类的，我们是有Stream系列（是用来处理二进制数据的）、我们有read writer系列（是用来处理文本的）。在read writer之外，我们还有scanner。</p>
<p>那么面对这么多复杂的类，我们该怎么选择呢？</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250216205922587.png" alt="image-20250216205922587"></p>
<p>我们给大家了这样一张流程图：首先来判断的是说：这个数据是不是二进制的？</p>
<p>如果数据本身是二进制的，那么你只有一个选择就是用Stream。而如果你想要从中读出Java的基本数据类型，那么要用<code>DataInputStream</code>来读。</p>
<p>如果这个文件本身不是二进制的而是文本的（可以像一个<code>txt</code>一样，用一个简单的记事本这样的软件打开，我们能够看见的），我们又要做一个选择了：就是我们这个文本文件表达的是文本、还是表达的是基本数据类型？——也就是说，我们是把它当作一篇文章来读呢？还是把它当作一系列的数据来读：</p>
<p>1）如果把它当作一个文章来读，那么我们在上面去构建一个reader，然后用这个reader的<code>readerLine</code>我们可以把它读进来</p>
<p>2）如果把它当作是一个数据（比如说里面每一行是一个整数、或者里面有很多整数用逗号&#x2F;空格分割），这个时候我们就需要用scanner。用scanner从文本里面解析出各种基本数据类型，然后把它放在基本数据类型的变量里头。</p>
<h3 id="8-5-流的应用"><a href="#8-5-流的应用" class="headerlink" title="8.5 流的应用"></a>8.5 流的应用</h3><h4 id="8-5-1-流的应用"><a href="#8-5-1-流的应用" class="headerlink" title="8.5.1 流的应用"></a>8.5.1 流的应用</h4><p>🍎流的基本操作</p>
<p>我们来看看我们用流可以做些什么样的事情：我们前面已经提过，现在已经很少有程序需要用流的方式去打开一个文件，裸的来对文件进行读和写的操作。我们更多的是以某种方式获得了一个流，然后呢在这个流的基础上要去做一些事情。</p>
<p>那我们先来看一个例子，就是如果我们想要去写一个 socket &#x2F;ˈsɑkət&#x2F;以网络端口的方式去访问一个服务器，然后和那个服务器之间建立一个文本的连接，来进行文本的这个读和写。这个时候程序该怎么做呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//要去连一个服务器，需要有一个类叫做socket。</span></span><br><span class="line">			<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">12345</span>); <span class="comment">//建立一个socket的对象，建立这个对象的时候要给它一些东西，因为我们要去连一个服务器，我们要告诉他服务器的地址在哪，服务器上那个端口是多少。一共两个信息。</span></span><br><span class="line">			<span class="comment">//这样就建立好了一个链接。这个链接会连到本地的一个12345端口。如果链接成功建立了起来，那么这个socket就得到了这个对象，如果链接不能够建立起来，那么在这个new的过程当中它就会抛异常，那么后面就会有exception有catch的异常机制来接管了。</span></span><br><span class="line">		</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎建立socket连接</p>
<p>如果已经得到了，ok，我们就有socket了。那么在这个socket上面呢，最重要的一个事情，如果我们要做通信，我们就可以通过这个socket的对象来得到一个流。为了能够往服务器上写点东西，eg：hello，world！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//要去连一个服务器，需要有一个类叫做socket。</span></span><br><span class="line">			<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">12345</span>); <span class="comment">//建立一个socket的对象，建立这个对象的时候要给它一些东西，因为我们要去连一个服务器，我们要告诉他服务器的地址在哪，服务器上那个端口是多少。一共两个信息。</span></span><br><span class="line">			<span class="comment">//这样就建立好了一个链接。这个链接会连到本地的一个12345端口。如果链接成功建立了起来，那么这个socket就得到了这个对象，如果链接不能够建立起来，那么在这个new的过程当中它就会抛异常，那么后面就会有exception有catch的异常机制来接管了。</span></span><br><span class="line">		</span><br><span class="line">			<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>( <span class="comment">//我们要写文本，需要有一个PrintWriter</span></span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(		<span class="comment">// PrintWriter建筑在一个BufferedWriter基础上</span></span><br><span class="line">							<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(		<span class="comment">// BufferedWriter建筑在一个OutputStreamWriter的基础上</span></span><br><span class="line">									socket.getOutputStream())));<span class="comment">// 对于OutputStreamWriter，之前我们做的是说我们要有个fileoutofthedream（打开一个文件往里面写东西），但现在我们不是要写文件，是要让它写到远端的服务器去。所以用socket.getOutputStream()</span></span><br><span class="line">									<span class="comment">// 用socket的getOutputStream去得到一个stream。也就是说，在这里实际上是我们的socket和服务端连上以后，我们去通过这个函数得到了一个虚拟的流。这个流并不是在任何文件上的，这个流表达的是我的这个程序和服务端那个程序之间的那种网络链接。</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//在上面的网络链接的基础上，我们就构建了一个right，于是我们就可以送东西过去了</span></span><br><span class="line">			out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">			out.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>🍎通过socket发送数据</p>
<p>但上面的程序如果我们直接运行，一定抛异常。因为我们没有任何Connection refused：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250110201613204.png" alt="image-20250110201613204"></p>
<p>我们没有任何服务器程序在12345上听着。怎么去建立这事呢？我们这样子来：</p>
<p>对于unix：用一个unix的程序nc，让它在12345上听着。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250110201729304.png" alt="image-20250110201729304"></p>
<p>如果你是用的Linux，你是：nc -l -p 12345</p>
<p>现在我们就有个程序在12345上听着了。然后我们来运行我们的程序，就可以看到hello被显示出来了</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250110201940040.png" alt="image-20250110201940040"></p>
<p>——这说明我们的程序和远端的服务器联系上了，并且将Hello送过去了。不过由于我们的程序马上就close close关掉了，于是服务器那边也就接着退出了。</p>
<p>🍎通过socket接收数据</p>
<p>那么如果我们想要从服务器那边收东西怎么收呢？那么也很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//要去连一个服务器，需要有一个类叫做socket。</span></span><br><span class="line">			<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">12345</span>); <span class="comment">//建立一个socket的对象，建立这个对象的时候要给它一些东西，因为我们要去连一个服务器，我们要告诉他服务器的地址在哪，服务器上那个端口是多少。一共两个信息。</span></span><br><span class="line">			<span class="comment">//这样就建立好了一个链接。这个链接会连到本地的一个12345端口。如果链接成功建立了起来，那么这个socket就得到了这个对象，如果链接不能够建立起来，那么在这个new的过程当中它就会抛异常，那么后面就会有exception有catch的异常机制来接管了。</span></span><br><span class="line">		</span><br><span class="line">			<span class="comment">//发送：我们要写文本，需要有一个PrintWriter</span></span><br><span class="line">			<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>( </span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(		<span class="comment">// PrintWriter建筑在一个BufferedWriter基础上</span></span><br><span class="line">							<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(		<span class="comment">// BufferedWriter建筑在一个OutputStreamWriter的基础上</span></span><br><span class="line">									socket.getOutputStream())));<span class="comment">// 对于OutputStreamWriter，之前我们做的是说我们要有个fileoutofthedream（打开一个文件往里面写东西），但现在我们不是要写文件，是要让它写到远端的服务器去。所以用socket.getOutputStream()</span></span><br><span class="line">									<span class="comment">// 用socket的getOutputStream去得到一个stream。也就是说，在这里实际上是我们的socket和服务端连上以后，我们去通过这个函数得到了一个虚拟的流。这个流并不是在任何文件上的，这个流表达的是我的这个程序和服务端那个程序之间的那种网络链接。</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//在上面的网络链接的基础上，我们就构建了一个right，于是我们就可以送东西过去了</span></span><br><span class="line">			out.println(<span class="string">&quot;Hello&quot;</span>);<span class="comment">//发送hello</span></span><br><span class="line">            <span class="comment">//out.flush();</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//接收：需要有一个BufferedReader</span></span><br><span class="line">			<span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>( </span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>( <span class="comment">//BufferedReader建筑在InputStreamReader的基础上</span></span><br><span class="line">							socket.getInputStream())); <span class="comment">//InputStream是在socket的一个getInputStream的基础上建立起来的。</span></span><br><span class="line">			String line;<span class="comment">//读一个line进来</span></span><br><span class="line">			line = in.readLine();</span><br><span class="line">			System.out.println(line);</span><br><span class="line">			</span><br><span class="line">			out.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行起来以后：<img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250110202612733.png" alt="image-20250110202612733"></p>
<p>我们并没有看到hello，其实是因为我这边没有flash，一会我们再改一下代码，让它flush（29行）我们就能看到hello，如果我们让它输出一个bye：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250110202744180.png" alt="image-20250110202744180"></p>
<p>我们看到hello了，在控制台也看到bye了。flush（原第29行）：我们刚才说没有先看到hello是因为我在这做了输出之后，没有做一些flush，没有刷以下，它还在缓冲区里头：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.flush();</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250110203112820.png" alt="image-20250110203112820"></p>
<p>🍎阻塞与多线程</p>
<p>我们在这个程序里面其实还看到一件事情，就是当我们在右边做readline的时候，这个程序是停在那里的：当我们右边在等待用户输入的时候它是停在那里的。</p>
<p>一旦你输入了bye之后，左边的line就得到东西了，那么readline这个函数就有一个返回让line得到东西，于是这个陈旭继续下去就把socket给关掉了，于是两头大家都结束了。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250110203411980.png" alt="image-20250110203411980"></p>
<p>在Java的机制里面，最基础的那个<code>inputstream</code>里面的那个reader函数是会阻塞的：如果你去调用reader函数，而当时那个流里面没有东西可读，（eg：上面的readline，readline也是基于reader去做的，它只不过在上面套了几层过滤器以后做的事情比较高级一点而已。所以它会阻塞在那里，会在那里等待）这个阻塞就使得你的程序是停下来的，一直到得到东西才会进行下去。——这就叫阻塞。</p>
<p>如果你想让你的程序不停下来，那么你要么用多线程的方式把这个reader放在一个线程里头，要么你就用<code>NIO</code>（New IO）的方式</p>
<h4 id="8-5-2-对象串行-x-acute-i-ng-化"><a href="#8-5-2-对象串行-x-acute-i-ng-化" class="headerlink" title="8.5.2 对象串行(x$\acute{i}$ng)化"></a>8.5.2 对象串行(x$\acute{i}$ng)化</h4><p>🍎对象串行化</p>
<p>我们前面看过了，二进制的怎么去写基本数据类型：我们要用<code>DataOutputStream</code>；然后读的时候用<code>DataInputStream</code>。</p>
<p> 我们如果要读写文本的内容，那么我们要用reader和writer。</p>
<p>如果是格式化的文本，那么要用Scanner。</p>
<p>那么如果我们想把我们自己写的一个类（这个类里面可能有很多数据的），我们想把这个类的对象整个的写到文件&#x2F;流里头，这个时候我们要怎么做？当然我们也可以考虑说：</p>
<p>我是不是可以把这个类里面的东西都格式化的用<code>println</code>&#x2F;<code>printf</code>去输出了，再用scanner去读进来。或者，把里面的每一个（因为类里面的成员最后都是基本数据类型）都变成基本数据类型用<code>DataOutputStream</code>去输出。</p>
<p>当然都可以，可是呢，我们有更简便&#x2F;更好的方法来 整个的把对象写到流里头去：这个方法叫做<strong>串行化</strong>（Serialization）。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215181013799.png" alt="image-20250215181013799"></p>
<p>我们来看一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215183016958.png" alt="image-20250215183016958"></p>
<p>——非常简单只是说明事情。</p>
<p>如果我们想要把这样的一个类的对象写到文件里头，然后将来还能够读出来，那么我们要怎么做呢？</p>
<p>🍎实现<code>serialization</code>接口</p>
<p>1）首先第一个。这个类它要实现一个接口，叫做<code>serialization</code>（可以串行化的类，它的对象是可以被串行化的）：</p>
<img src="./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215183312305.png" alt="image-20250215183312305" style="zoom:67%;" />

<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215183556785.png" alt="image-20250215183556785"></p>
<p>——我们知道现在是会得到这个John的。</p>
<p>然后我们要去构造一个可以把这样一个<code>s1</code>直接写到文件里面去的方式，这个东西叫做<code>ObjectOutputStream</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215184126786.png" alt="image-20250215184126786"></p>
<p>w吗看到这样我们在<code>s1</code>里面就有了这些数据。那么现在，我们看到，这是一个字符串、有两个整数：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215184246124.png" alt="image-20250215184246124"></p>
<p>也不是一个很大的类，写出来会有多少东西呢？我们可以先看一下写出来的结果，我们用老朋友来打开那个文件：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215184502618.png" alt="image-20250215184502618"></p>
<p>挺大的，远远不止字符串啊那些东西。实际上呢，它里头除了有数据（我们可以看到像John这个名字，我们仔细找找还能找到它的18岁那个18），但是呢还有些别的东西。所以就是写进去的是 除了有原始的数据以外，其他它还会有一些其他的资料，有助于将来能够识别出来它是什么。</p>
<p>那，然后呢？我们写进去之后当然要想办法怎么读出来对不对？</p>
<p>所以我们需要有一个<code>ObjectInputStream</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215185451001.png" alt="image-20250215185451001"></p>
<p>我们想要读到一个Student，可是<code>readObject</code>返回的类型是Object，当然我们现在非常确定的知道：我们写到那个<code>obj.dot</code>里面去的一定是一个Student：</p>
<p>🍎对象的读取和写入</p>
<p>所以我们可以直接做一个cast说我要把你转成Student（<code>Student s2 = (Student)in.readObject();</code>）。</p>
<p>但是呢，它说：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215190113821.png" alt="image-20250215190113821"></p>
<p>这是有风险的，所以这里有没有处理的异常<code>ClassNotFound</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215185838612.png" alt="image-20250215185838612"></p>
<p><code>ClassNotFound</code>就是说：我们要去处理的这个<code>readObject</code>（要去读的那个东西）也许会不认识会怎么样，所以这会有异常。</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215190225159.png" alt="image-20250215190225159"></p>
<p>我们先来跑一下程序，我们看到结果是一模一样的：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215190240690.png" alt="image-20250215190240690"></p>
<p>然后这个时候我们有一个疑问，就是<code>s1</code>和<code>s2</code>是不是一个东西呢？</p>
<p>我们这儿可以输出说<code>s1=s2</code>：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215190341695.png" alt="image-20250215190341695"></p>
<p>我们知道对于Java来说，这样的【&#x3D;】它要判断的是说：<code>s1</code>和<code>s2</code>是不是指向的是同一个对象，我们来看一下：</p>
<p><img src="/./mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java.assets/image-20250215190439263.png" alt="image-20250215190439263"></p>
<p>它说是false。</p>
<p>也就是说，这两个对象里面的内容是一样的，但是它们并不是相同的对象。当我们用<code>readObject</code>从一个流里面重新去反串行化构造一个新的对象出来的时候，它会另外制造一个新的对象给我们。这个对象和我们写进去的那个对象是一模一样的值，但是它们是两个完全不同的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123; <span class="comment">//表达学生的</span></span><br><span class="line">	<span class="comment">// 私有的属性</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> grade; <span class="comment">//打分情况</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> grade)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.grade = grade;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name+<span class="string">&quot; &quot;</span>+age+<span class="string">&quot; &quot;</span>+grade;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;John&quot;</span>, <span class="number">18</span>, <span class="number">5</span>); <span class="comment">//做一个Student的对象</span></span><br><span class="line">			System.out.println(s1);</span><br><span class="line">			<span class="comment">//ObjectOutputStream：直接把对象给写进文件里，但它需要建立在另外一个实体的流的基础上</span></span><br><span class="line">			<span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">					<span class="comment">//实体的流：比如说有一个FileOutputStream</span></span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;obj.dot&quot;</span>));</span><br><span class="line">			<span class="comment">// 有了这个流之后，就可以在这个流上面做一个叫做writeObject的函数</span></span><br><span class="line">			out.writeObject(s1); <span class="comment">//写s1进去</span></span><br><span class="line">			out.close(); <span class="comment">//写完了之后要close掉</span></span><br><span class="line">			<span class="comment">// 读出来</span></span><br><span class="line">			<span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(</span><br><span class="line">					<span class="comment">//也是建立在一个FileInputStream的基础上</span></span><br><span class="line">					<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;obj.dot&quot;</span>));</span><br><span class="line">			<span class="comment">// in可以readObject。我们想要读到一个Student，可是readObject返回的类型是Object,</span></span><br><span class="line">			<span class="comment">// 当然我们现在非常确定的知道：，我们写道那个obj.dot里面去的一定是一个Student,</span></span><br><span class="line">			<span class="comment">// 所以我们可以直接做一个cast说我要把你转成Student。</span></span><br><span class="line">			<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student)in.readObject();</span><br><span class="line">			System.out.println(s2); <span class="comment">//输出一下看看是不是那个John</span></span><br><span class="line">			in.close(); <span class="comment">//把in给close掉</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">tong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/12/Java/mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java/">http://example.com/2025/03/12/Java/mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/./img/touxiang.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/./img/WeChat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/./img/WeChat_pay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/./img/Alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/./img/Alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/02/Java/mooc%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6Java%E8%AF%AD%E8%A8%80/" title="mooc零基础学Java语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">mooc零基础学Java语言</div></div><div class="info-2"><div class="info-item-1">mooc零基础学Java语言2024年02月26日 ~ 2024年06月07日	第16次开课	翁恺  [!CAUTION] ALT + &#x2F;     补全代码 shift + ↓    选中一整行 CTRL + &#x2F;  ...</div></div></div></a><a class="pagination-related" href="/2025/06/13/Hadoop/Hadoop%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%91/" title="Hadoop应用与开发1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hadoop应用与开发1</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/./img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">tong</div><div class="author-info-description">这里是描述</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">现在没有公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java"><span class="toc-number">1.</span> <span class="toc-text">mooc面向对象程序设计——Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E5%91%A8%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">第1周	类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%94%A8%E7%B1%BB%E5%88%B6%E9%80%A0%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 用类制造对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%9A%E4%B9%89%E7%B1%BB-Class"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 定义类 Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 成员变量和成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 对象初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.5.</span> <span class="toc-text">函数重载与类型自动转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E5%91%A8%E5%AF%B9%E8%B1%A1%E4%BA%A4%E4%BA%92"><span class="toc-number">1.2.</span> <span class="toc-text">第2周	对象交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AF%B9%E8%B1%A1%E4%BA%A4%E4%BA%92"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 对象交互</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AF%86%E5%88%AB"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 对象的识别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 对象的交互</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E7%9B%B4%E6%8E%A5%E4%BA%A4%E4%BA%92%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">如何做直接交互？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.2 访问属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%B0%81%E9%97%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.2.1 封闭的访问属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%BC%80%E6%94%BE%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.2.2 开放的访问属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8C%85-Package"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.3 包 Package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.4 类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.4.1 类变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%B1%BB%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.4.2 类函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%B1%BB%E5%87%BD%E6%95%B0%E4%B8%AD%E6%9C%89this%E5%90%97%EF%BC%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">在类函数中有this吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E5%91%A8%E5%AF%B9%E8%B1%A1%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">第3周	对象容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E8%AE%B0%E4%BA%8B%E6%9C%AC%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 记事本的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%B3%9B%E5%9E%8B%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 泛型容器类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-ArrayList%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3 ArrayList的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 对象数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 对象数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%9A%84for-each%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 对象数组的for-each循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%9B%86%E5%90%88%E5%AE%B9%E5%99%A8%EF%BC%88Set%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 集合容器（Set）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%83%BD%E7%94%A8get-%E5%87%BD%E6%95%B0%E6%9D%A5%E8%8E%B7%E5%BE%97%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B8%8A%E7%9A%84%E5%85%83%E7%B4%A0%E5%90%97%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">集合能用get()函数来获得某个位置上的元素吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88Hash%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.4散列表（Hash）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E5%91%A8%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="toc-number">1.4.</span> <span class="toc-text">第4周	继承与多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%AA%92%E4%BD%93%E8%B5%84%E6%96%99%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 媒体资料库的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 子类父类关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E5%AD%90%E7%B1%BB%E7%BB%A7%E6%89%BF%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1 子类继承了什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%AD%90%E7%B1%BB%E5%92%8C%E7%88%B6%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2 子类和父类的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%A4%9A%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%90%91%E4%B8%8A%E9%80%A0%E5%9E%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 多态变量和向上造型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%A4%9A%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">4.3.1 多态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E5%90%91%E4%B8%8A%E9%80%A0%E5%9E%8B"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">4.3.2 向上造型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%81%E6%98%AF%E8%B0%81%E7%9A%84%E7%88%B6%E7%B1%BB%E5%90%88%E9%80%82%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">谁是谁的父类合适？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%A4%9A%E6%80%81"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.4 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Eprint"><span class="toc-number">1.4.6.</span> <span class="toc-text">关于print</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.5 类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-Object%E7%B1%BB"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">4.5.1 Object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-DoME%E7%9A%84%E6%96%B0%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">4.5.2 DoME的新媒体类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E5%91%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text">第5周	设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%9F%8E%E5%A0%A1%E6%B8%B8%E6%88%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 城堡游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%A0%B9%E6%8D%AEcastle%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9B%9E%E7%AD%94%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">请根据castle的代码回答这些问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%B8%AAcastle%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.5.3.</span> <span class="toc-text">这个castle程序有什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%B6%88%E9%99%A4%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.2 消除代码复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%B0%81%E8%A3%85"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.3 封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.4 可扩展性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%A1%86%E6%9E%B6%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.5 框架加数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%BF%98%E6%9C%89%E6%B2%A1%E6%9C%89%E8%83%BD%E4%BB%A5%E6%A1%86%E6%9E%B6%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%9D%A5%E8%A1%A8%E8%BE%BE%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%9F"><span class="toc-number">1.5.8.</span> <span class="toc-text">程序中还有没有能以框架加数据来表达的东西？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.9.</span> <span class="toc-text">5.6 类型系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E5%91%A8%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.</span> <span class="toc-text">第6周	抽象与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A1%A8%E7%8E%B0%E5%88%86%E7%A6%BB%EF%BC%9A%E7%BB%86%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 数据与表现分离：细胞自动机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E7%BB%86%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">6.2.1 细胞自动机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%A1%A8%E7%8E%B0%E5%88%86%E7%A6%BB"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">6.2.2 数据与表现分离</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89Cell-setAlive"><span class="toc-number">1.6.3.</span> <span class="toc-text">为什么没有Cell.setAlive()?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EField-getNeighbour"><span class="toc-number">1.6.4.</span> <span class="toc-text">关于Field.getNeighbour()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cell%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%87%AA%E5%B7%B1%E5%88%A4%E6%96%AD%E9%82%BB%E5%B1%85%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">1.6.5.</span> <span class="toc-text">Cell为什么不自己判断邻居情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E7%8B%90%E7%8B%B8%E4%B8%8E%E5%85%94%E5%AD%90"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.3 接口：狐狸与兔子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E7%8B%90%E7%8B%B8%E4%B8%8E%E5%85%94%E5%AD%90"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">6.3.1 狐狸与兔子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">6.3.2 接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fox-breed-%E5%92%8CRabbit-breed-%E5%87%A0%E4%B9%8E%E4%B8%80%E6%A0%B7"><span class="toc-number">1.6.7.</span> <span class="toc-text">Fox.breed()和Rabbit.breed()几乎一样</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">6.3.3 接口设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cell%E8%A6%81%E4%B8%8D%E8%A6%81%E7%9F%A5%E9%81%93Field%EF%BC%9F"><span class="toc-number">1.6.8.</span> <span class="toc-text">Cell要不要知道Field？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E4%B8%8D%E8%A6%81Animal-%E7%9A%84%E5%88%97%E8%A1%A8%EF%BC%9F"><span class="toc-number">1.6.9.</span> <span class="toc-text">要不要Animal 的列表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E4%B8%8D%E8%A6%81%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%A8%E7%8E%B0%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E7%A6%BB%EF%BC%9F"><span class="toc-number">1.6.10.</span> <span class="toc-text">要不要把数据和表现进一步分离？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E5%91%A8%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E4%B8%8EMVC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">第7周	控制反转与MVC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 控制反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2GUI"><span class="toc-number">1.7.2.</span> <span class="toc-text">图形用户界面GUI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">7.1.1 布局管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">7.1.2 控制反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swing%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.3.</span> <span class="toc-text">Swing的事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">7.1.3 内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-MVC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.2 MVC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-JTable"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">7.2.1 JTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">7.2.2 MVC设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E5%91%A8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.8.</span> <span class="toc-text">第8周	异常处理与输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">8.1.1 捕捉异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E5%BC%82%E5%B8%B8%E6%8D%95%E6%8D%89%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">8.1.2 异常捕捉机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E6%8D%95%E6%8D%89%E5%88%B0%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">8.1.3 捕捉到的异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 异常机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">8.2.1 异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">8.2.2 抛出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E5%BC%82%E5%B8%B8%E6%8D%95%E6%8D%89%E6%97%B6%E7%9A%84%E5%8C%B9%E9%85%8D"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">8.2.3 异常捕捉时的匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-%E5%BC%82%E5%B8%B8%E9%81%87%E5%88%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">8.2.4 异常遇到继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%B5%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E6%B5%81"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">8.3.1 流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-%E6%96%87%E4%BB%B6"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">8.3.2 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-%E6%B5%81%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">8.3.3 流过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 文本输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-%E6%96%87%E6%9C%AC%E6%B5%81"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">8.4.1 文本流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-%E6%B1%89%E5%AD%97%E7%BC%96%E7%A0%81"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">8.4.2 汉字编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.8.4.3.</span> <span class="toc-text">8.4.3 格式化输入输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 流的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">8.5.1 流的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E5%AF%B9%E8%B1%A1%E4%B8%B2%E8%A1%8C-x-acute-i-ng-%E5%8C%96"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">8.5.2 对象串行(x$\acute{i}$ng)化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/16/Hadoop/Hadoop%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%913/" title="Hadoop应用与开发3">Hadoop应用与开发3</a><time datetime="2025-06-16T04:00:00.000Z" title="发表于 2025-06-16 12:00:00">2025-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/16/Hadoop/Hadoop%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%912/" title="Hadoop应用与开发2">Hadoop应用与开发2</a><time datetime="2025-06-16T04:00:00.000Z" title="发表于 2025-06-16 12:00:00">2025-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/16/Hadoop/Hadoop%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%914/" title="Hadoop应用与开发4">Hadoop应用与开发4</a><time datetime="2025-06-16T04:00:00.000Z" title="发表于 2025-06-16 12:00:00">2025-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/13/Hadoop/Hadoop%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%91/" title="Hadoop应用与开发1">Hadoop应用与开发1</a><time datetime="2025-06-13T04:00:00.000Z" title="发表于 2025-06-13 12:00:00">2025-06-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/12/Java/mooc%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94Java/" title="mooc面向对象程序设计——Java">mooc面向对象程序设计——Java</a><time datetime="2025-03-12T10:22:00.000Z" title="发表于 2025-03-12 18:22:00">2025-03-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #ffd6e0, #f5f5f5, #c1f0c1);"><div id="footer-wrap"><div class="copyright">&copy;2025 By tong</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>